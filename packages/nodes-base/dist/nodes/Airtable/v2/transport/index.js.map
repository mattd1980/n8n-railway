{"version":3,"sources":["../../../../../nodes/Airtable/v2/transport/index.ts"],"sourcesContent":["import type {\n\tIBinaryKeyData,\n\tIDataObject,\n\tIExecuteFunctions,\n\tIPollFunctions,\n\tILoadOptionsFunctions,\n\tINodeExecutionData,\n\tIPairedItemData,\n\tIHttpRequestMethods,\n\tIRequestOptions,\n} from 'n8n-workflow';\nimport { ApplicationError } from 'n8n-workflow';\n\nimport type { IAttachment, IRecord } from '../helpers/interfaces';\nimport { flattenOutput } from '../helpers/utils';\n\n/**\n * Make an API request to Airtable\n *\n */\nexport async function apiRequest(\n\tthis: IExecuteFunctions | ILoadOptionsFunctions | IPollFunctions,\n\tmethod: IHttpRequestMethods,\n\tendpoint: string,\n\tbody: IDataObject = {},\n\tquery?: IDataObject,\n\turi?: string,\n\toption: IDataObject = {},\n) {\n\tquery = query || {};\n\n\tconst options: IRequestOptions = {\n\t\theaders: {},\n\t\tmethod,\n\t\tbody,\n\t\tqs: query,\n\t\turi: uri || `https://api.airtable.com/v0/${endpoint}`,\n\t\tuseQuerystring: false,\n\t\tjson: true,\n\t};\n\n\tif (Object.keys(option).length !== 0) {\n\t\tObject.assign(options, option);\n\t}\n\n\tif (Object.keys(body).length === 0) {\n\t\tdelete options.body;\n\t}\n\n\tconst authenticationMethod = this.getNodeParameter('authentication', 0) as string;\n\treturn await this.helpers.requestWithAuthentication.call(this, authenticationMethod, options);\n}\n\n/**\n * Make an API request to paginated Airtable endpoint\n * and return all results\n *\n * @param {(IExecuteFunctions | IExecuteFunctions)} this\n */\nexport async function apiRequestAllItems(\n\tthis: IExecuteFunctions | ILoadOptionsFunctions | IPollFunctions,\n\tmethod: IHttpRequestMethods,\n\tendpoint: string,\n\tbody?: IDataObject,\n\tquery?: IDataObject,\n) {\n\tif (query === undefined) {\n\t\tquery = {};\n\t}\n\tquery.pageSize = 100;\n\n\tconst returnData: IDataObject[] = [];\n\n\tlet responseData;\n\n\tdo {\n\t\tresponseData = await apiRequest.call(this, method, endpoint, body, query);\n\t\treturnData.push.apply(returnData, responseData.records as IDataObject[]);\n\n\t\tquery.offset = responseData.offset;\n\t} while (responseData.offset !== undefined);\n\n\treturn {\n\t\trecords: returnData,\n\t};\n}\n\nexport async function downloadRecordAttachments(\n\tthis: IExecuteFunctions | IPollFunctions,\n\trecords: IRecord[],\n\tfieldNames: string | string[],\n\tpairedItem?: IPairedItemData[],\n): Promise<INodeExecutionData[]> {\n\tif (typeof fieldNames === 'string') {\n\t\tfieldNames = fieldNames.split(',').map((item) => item.trim());\n\t}\n\tif (!fieldNames.length) {\n\t\tthrow new ApplicationError(\"Specify field to download in 'Download Attachments' option\", {\n\t\t\tlevel: 'warning',\n\t\t});\n\t}\n\tconst elements: INodeExecutionData[] = [];\n\tfor (const record of records) {\n\t\tconst element: INodeExecutionData = { json: {}, binary: {} };\n\t\tif (pairedItem) {\n\t\t\telement.pairedItem = pairedItem;\n\t\t}\n\t\telement.json = flattenOutput(record as unknown as IDataObject);\n\t\tfor (const fieldName of fieldNames) {\n\t\t\tif (record.fields[fieldName] !== undefined) {\n\t\t\t\tfor (const [index, attachment] of (record.fields[fieldName] as IAttachment[]).entries()) {\n\t\t\t\t\tconst file = await apiRequest.call(this, 'GET', '', {}, {}, attachment.url, {\n\t\t\t\t\t\tjson: false,\n\t\t\t\t\t\tencoding: null,\n\t\t\t\t\t});\n\t\t\t\t\telement.binary![`${fieldName}_${index}`] = await this.helpers.prepareBinaryData(\n\t\t\t\t\t\tBuffer.from(file as string),\n\t\t\t\t\t\tattachment.filename,\n\t\t\t\t\t\tattachment.type,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (Object.keys(element.binary as IBinaryKeyData).length === 0) {\n\t\t\tdelete element.binary;\n\t\t}\n\t\telements.push(element);\n\t}\n\treturn elements;\n}\n\nexport async function batchUpdate(\n\tthis: IExecuteFunctions | IPollFunctions,\n\tendpoint: string,\n\tbody: IDataObject,\n\tupdateRecords: IDataObject[],\n) {\n\tif (!updateRecords.length) {\n\t\treturn { records: [] };\n\t}\n\n\tlet responseData: IDataObject;\n\n\tif (updateRecords.length && updateRecords.length <= 10) {\n\t\tconst updateBody = {\n\t\t\t...body,\n\t\t\trecords: updateRecords,\n\t\t};\n\n\t\tresponseData = await apiRequest.call(this, 'PATCH', endpoint, updateBody);\n\t\treturn responseData;\n\t}\n\n\tconst batchSize = 10;\n\tconst batches = Math.ceil(updateRecords.length / batchSize);\n\tconst updatedRecords: IDataObject[] = [];\n\n\tfor (let j = 0; j < batches; j++) {\n\t\tconst batch = updateRecords.slice(j * batchSize, (j + 1) * batchSize);\n\n\t\tconst updateBody = {\n\t\t\t...body,\n\t\t\trecords: batch,\n\t\t};\n\n\t\tconst updateResponse = await apiRequest.call(this, 'PATCH', endpoint, updateBody);\n\t\tupdatedRecords.push(...((updateResponse.records as IDataObject[]) || []));\n\t}\n\n\tresponseData = { records: updatedRecords };\n\n\treturn responseData;\n}\n"],"mappings":"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","names":[]}
{"version":3,"sources":["../../../../nodes/EmailReadImap/v2/EmailReadImapV2.node.ts"],"sourcesContent":["import type { ImapSimple, ImapSimpleOptions, Message, MessagePart } from '@n8n/imap';\nimport { connect as imapConnect } from '@n8n/imap';\nimport isEmpty from 'lodash/isEmpty';\nimport type {\n\tITriggerFunctions,\n\tIBinaryData,\n\tICredentialsDecrypted,\n\tICredentialTestFunctions,\n\tIDataObject,\n\tINodeCredentialTestResult,\n\tINodeType,\n\tINodeTypeBaseDescription,\n\tINodeTypeDescription,\n\tITriggerResponse,\n\tJsonObject,\n} from 'n8n-workflow';\nimport { NodeConnectionTypes, NodeOperationError, TriggerCloseError } from 'n8n-workflow';\nimport rfc2047 from 'rfc2047';\n\nimport type { ICredentialsDataImap } from '@credentials/Imap.credentials';\nimport { isCredentialsDataImap } from '@credentials/Imap.credentials';\n\nimport { getNewEmails } from './utils';\n\nconst versionDescription: INodeTypeDescription = {\n\tdisplayName: 'Email Trigger (IMAP)',\n\tname: 'emailReadImap',\n\ticon: 'fa:inbox',\n\ticonColor: 'green',\n\tgroup: ['trigger'],\n\tversion: 2,\n\tdescription: 'Triggers the workflow when a new email is received',\n\teventTriggerDescription: 'Waiting for you to receive an email',\n\tdefaults: {\n\t\tname: 'Email Trigger (IMAP)',\n\t\tcolor: '#44AA22',\n\t},\n\ttriggerPanel: {\n\t\theader: '',\n\t\texecutionsHelp: {\n\t\t\tinactive:\n\t\t\t\t\"<b>While building your workflow</b>, click the 'execute step' button, then send an email to make an event happen. This will trigger an execution, which will show up in this editor.<br /> <br /><b>Once you're happy with your workflow</b>, <a data-key='activate'>activate</a> it. Then every time an email is received, the workflow will execute. These executions will show up in the <a data-key='executions'>executions list</a>, but not in the editor.\",\n\t\t\tactive:\n\t\t\t\t\"<b>While building your workflow</b>, click the 'execute step' button, then send an email to make an event happen. This will trigger an execution, which will show up in this editor.<br /> <br /><b>Your workflow will also execute automatically</b>, since it's activated. Every time an email is received, this node will trigger an execution. These executions will show up in the <a data-key='executions'>executions list</a>, but not in the editor.\",\n\t\t},\n\t\tactivationHint:\n\t\t\t\"Once you’ve finished building your workflow, <a data-key='activate'>activate</a> it to have it also listen continuously (you just won’t see those executions here).\",\n\t},\n\tusableAsTool: true,\n\tinputs: [],\n\toutputs: [NodeConnectionTypes.Main],\n\tcredentials: [\n\t\t{\n\t\t\tname: 'imap',\n\t\t\trequired: true,\n\t\t\ttestedBy: 'imapConnectionTest',\n\t\t},\n\t],\n\tproperties: [\n\t\t{\n\t\t\tdisplayName: 'Mailbox Name',\n\t\t\tname: 'mailbox',\n\t\t\ttype: 'string',\n\t\t\tdefault: 'INBOX',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Action',\n\t\t\tname: 'postProcessAction',\n\t\t\ttype: 'options',\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Mark as Read',\n\t\t\t\t\tvalue: 'read',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Nothing',\n\t\t\t\t\tvalue: 'nothing',\n\t\t\t\t},\n\t\t\t],\n\t\t\tdefault: 'read',\n\t\t\tdescription:\n\t\t\t\t'What to do after the email has been received. If \"nothing\" gets selected it will be processed multiple times.',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Download Attachments',\n\t\t\tname: 'downloadAttachments',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\tformat: ['simple'],\n\t\t\t\t},\n\t\t\t},\n\t\t\tdescription:\n\t\t\t\t'Whether attachments of emails should be downloaded. Only set if needed as it increases processing.',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Format',\n\t\t\tname: 'format',\n\t\t\ttype: 'options',\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'RAW',\n\t\t\t\t\tvalue: 'raw',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Returns the full email message data with body content in the raw field as a base64url encoded string; the payload field is not used',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Resolved',\n\t\t\t\t\tvalue: 'resolved',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Returns the full email with all data resolved and attachments saved as binary data',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Simple',\n\t\t\t\t\tvalue: 'simple',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Returns the full email; do not use if you wish to gather inline attachments',\n\t\t\t\t},\n\t\t\t],\n\t\t\tdefault: 'simple',\n\t\t\tdescription: 'The format to return the message in',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Property Prefix Name',\n\t\t\tname: 'dataPropertyAttachmentsPrefixName',\n\t\t\ttype: 'string',\n\t\t\tdefault: 'attachment_',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\tformat: ['resolved'],\n\t\t\t\t},\n\t\t\t},\n\t\t\tdescription:\n\t\t\t\t'Prefix for name of the binary property to which to write the attachments. An index starting with 0 will be added. So if name is \"attachment_\" the first attachment is saved to \"attachment_0\"',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Property Prefix Name',\n\t\t\tname: 'dataPropertyAttachmentsPrefixName',\n\t\t\ttype: 'string',\n\t\t\tdefault: 'attachment_',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\tformat: ['simple'],\n\t\t\t\t\tdownloadAttachments: [true],\n\t\t\t\t},\n\t\t\t},\n\t\t\tdescription:\n\t\t\t\t'Prefix for name of the binary property to which to write the attachments. An index starting with 0 will be added. So if name is \"attachment_\" the first attachment is saved to \"attachment_0\"',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Options',\n\t\t\tname: 'options',\n\t\t\ttype: 'collection',\n\t\t\tplaceholder: 'Add option',\n\t\t\tdefault: {},\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Custom Email Rules',\n\t\t\t\t\tname: 'customEmailConfig',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdefault: '[\"UNSEEN\"]',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Custom email fetching rules. See <a href=\"https://github.com/mscdex/node-imap\">node-imap</a>\\'s search function for more details.',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Force Reconnect Every Minutes',\n\t\t\t\t\tname: 'forceReconnect',\n\t\t\t\t\ttype: 'number',\n\t\t\t\t\tdefault: 60,\n\t\t\t\t\tdescription: 'Sets an interval (in minutes) to force a reconnection',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport class EmailReadImapV2 implements INodeType {\n\tdescription: INodeTypeDescription;\n\n\tconstructor(baseDescription: INodeTypeBaseDescription) {\n\t\tthis.description = {\n\t\t\t...baseDescription,\n\t\t\t...versionDescription,\n\t\t};\n\t}\n\n\tmethods = {\n\t\tcredentialTest: {\n\t\t\tasync imapConnectionTest(\n\t\t\t\tthis: ICredentialTestFunctions,\n\t\t\t\tcredential: ICredentialsDecrypted,\n\t\t\t): Promise<INodeCredentialTestResult> {\n\t\t\t\tif (isCredentialsDataImap(credential.data)) {\n\t\t\t\t\tconst credentials = credential.data as ICredentialsDataImap;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst config: ImapSimpleOptions = {\n\t\t\t\t\t\t\timap: {\n\t\t\t\t\t\t\t\tuser: credentials.user,\n\t\t\t\t\t\t\t\tpassword: credentials.password,\n\t\t\t\t\t\t\t\thost: credentials.host.trim(),\n\t\t\t\t\t\t\t\tport: credentials.port,\n\t\t\t\t\t\t\t\ttls: credentials.secure,\n\t\t\t\t\t\t\t\tauthTimeout: 20000,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst tlsOptions: IDataObject = {};\n\n\t\t\t\t\t\tif (credentials.allowUnauthorizedCerts) {\n\t\t\t\t\t\t\ttlsOptions.rejectUnauthorized = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (credentials.secure) {\n\t\t\t\t\t\t\ttlsOptions.servername = credentials.host.trim();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!isEmpty(tlsOptions)) {\n\t\t\t\t\t\t\tconfig.imap.tlsOptions = tlsOptions;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst connection = await imapConnect(config);\n\t\t\t\t\t\tawait connection.getBoxes();\n\t\t\t\t\t\tconnection.end();\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tstatus: 'Error',\n\t\t\t\t\t\t\tmessage: (error as Error).message,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstatus: 'OK',\n\t\t\t\t\t\tmessage: 'Connection successful!',\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstatus: 'Error',\n\t\t\t\t\t\tmessage: 'Credentials are no IMAP credentials.',\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t};\n\n\tasync trigger(this: ITriggerFunctions): Promise<ITriggerResponse> {\n\t\tconst credentialsObject = await this.getCredentials('imap');\n\t\tconst credentials = isCredentialsDataImap(credentialsObject) ? credentialsObject : undefined;\n\t\tif (!credentials) {\n\t\t\tthrow new NodeOperationError(this.getNode(), 'Credentials are not valid for imap node.');\n\t\t}\n\t\tconst mailbox = this.getNodeParameter('mailbox') as string;\n\t\tconst postProcessAction = this.getNodeParameter('postProcessAction') as string;\n\t\tconst options = this.getNodeParameter('options', {}) as IDataObject;\n\n\t\tconst staticData = this.getWorkflowStaticData('node');\n\t\tthis.logger.debug('Loaded static data for node \"EmailReadImap\"', { staticData });\n\n\t\tlet connection: ImapSimple;\n\t\tlet closeFunctionWasCalled = false;\n\t\tlet isCurrentlyReconnecting = false;\n\n\t\t// Returns the email text\n\n\t\tconst getText = async (\n\t\t\tparts: MessagePart[],\n\t\t\tmessage: Message,\n\t\t\tsubtype: string,\n\t\t): Promise<string> => {\n\t\t\tif (!message.attributes.struct) {\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\tconst textParts = parts.filter((part) => {\n\t\t\t\treturn (\n\t\t\t\t\tpart.type.toUpperCase() === 'TEXT' && part.subtype.toUpperCase() === subtype.toUpperCase()\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tconst part = textParts[0];\n\t\t\tif (!part) {\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst partData = await connection.getPartData(message, part);\n\t\t\t\treturn partData.toString();\n\t\t\t} catch {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t};\n\n\t\t// Returns the email attachments\n\t\tconst getAttachment = async (\n\t\t\timapConnection: ImapSimple,\n\t\t\tparts: MessagePart[],\n\t\t\tmessage: Message,\n\t\t): Promise<IBinaryData[]> => {\n\t\t\tif (!message.attributes.struct) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Check if the message has attachments and if so get them\n\t\t\tconst attachmentParts = parts.filter(\n\t\t\t\t(part) => part.disposition?.type?.toUpperCase() === 'ATTACHMENT',\n\t\t\t);\n\n\t\t\tconst decodeFilename = (filename: string) => {\n\t\t\t\tconst regex = /=\\?([\\w-]+)\\?Q\\?.*\\?=/i;\n\t\t\t\tif (regex.test(filename)) {\n\t\t\t\t\treturn rfc2047.decode(filename);\n\t\t\t\t}\n\t\t\t\treturn filename;\n\t\t\t};\n\n\t\t\tconst attachmentPromises = [];\n\t\t\tlet attachmentPromise;\n\t\t\tfor (const attachmentPart of attachmentParts) {\n\t\t\t\tattachmentPromise = imapConnection\n\t\t\t\t\t.getPartData(message, attachmentPart)\n\t\t\t\t\t.then(async (partData) => {\n\t\t\t\t\t\t// if filename contains utf-8 encoded characters, decode it\n\t\t\t\t\t\tconst fileName = decodeFilename(\n\t\t\t\t\t\t\t((attachmentPart.disposition as IDataObject)?.params as IDataObject)\n\t\t\t\t\t\t\t\t?.filename as string,\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Return it in the format n8n expects\n\t\t\t\t\t\treturn await this.helpers.prepareBinaryData(partData.buffer, fileName);\n\t\t\t\t\t});\n\n\t\t\t\tattachmentPromises.push(attachmentPromise);\n\t\t\t}\n\n\t\t\treturn await Promise.all(attachmentPromises);\n\t\t};\n\n\t\tconst returnedPromise = this.helpers.createDeferredPromise();\n\n\t\tconst establishConnection = async (): Promise<ImapSimple> => {\n\t\t\tlet searchCriteria = ['UNSEEN'] as Array<string | string[]>;\n\t\t\tif (options.customEmailConfig !== undefined) {\n\t\t\t\ttry {\n\t\t\t\t\tsearchCriteria = JSON.parse(options.customEmailConfig as string) as Array<\n\t\t\t\t\t\tstring | string[]\n\t\t\t\t\t>;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Custom email config is not valid JSON.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst config: ImapSimpleOptions = {\n\t\t\t\timap: {\n\t\t\t\t\tuser: credentials.user,\n\t\t\t\t\tpassword: credentials.password,\n\t\t\t\t\thost: credentials.host.trim(),\n\t\t\t\t\tport: credentials.port,\n\t\t\t\t\ttls: credentials.secure,\n\t\t\t\t\tauthTimeout: 20000,\n\t\t\t\t},\n\t\t\t\tonMail: async () => {\n\t\t\t\t\tif (connection) {\n\t\t\t\t\t\tif (staticData.lastMessageUid !== undefined) {\n\t\t\t\t\t\t\tsearchCriteria.push(['UID', `${staticData.lastMessageUid as number}:*`]);\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * A short explanation about UIDs and how they work\n\t\t\t\t\t\t\t * can be found here: https://dev.to/kehers/imap-new-messages-since-last-check-44gm\n\t\t\t\t\t\t\t * TL;DR:\n\t\t\t\t\t\t\t * - You cannot filter using ['UID', 'CURRENT ID + 1:*'] because IMAP\n\t\t\t\t\t\t\t * won't return correct results if current id + 1 does not yet exist.\n\t\t\t\t\t\t\t * - UIDs can change but this is not being treated here.\n\t\t\t\t\t\t\t * If the mailbox is recreated (lets say you remove all emails, remove\n\t\t\t\t\t\t\t * the mail box and create another with same name, UIDs will change)\n\t\t\t\t\t\t\t * - You can check if UIDs changed in the above example\n\t\t\t\t\t\t\t * by checking UIDValidity.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tthis.logger.debug('Querying for new messages on node \"EmailReadImap\"', {\n\t\t\t\t\t\t\t\tsearchCriteria,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst returnData = await getNewEmails.call(\n\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\tconnection,\n\t\t\t\t\t\t\t\tsearchCriteria,\n\t\t\t\t\t\t\t\tstaticData,\n\t\t\t\t\t\t\t\tpostProcessAction,\n\t\t\t\t\t\t\t\tgetText,\n\t\t\t\t\t\t\t\tgetAttachment,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (returnData.length) {\n\t\t\t\t\t\t\t\tthis.emit([returnData]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tthis.logger.error('Email Read Imap node encountered an error fetching new emails', {\n\t\t\t\t\t\t\t\terror: error as Error,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t// Wait with resolving till the returnedPromise got resolved, else n8n will be unhappy\n\t\t\t\t\t\t\t// if it receives an error before the workflow got activated\n\t\t\t\t\t\t\tawait returnedPromise.promise.then(() => {\n\t\t\t\t\t\t\t\tthis.emitError(error as Error);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tonUpdate: async (seqNo: number, info) => {\n\t\t\t\t\tthis.logger.debug(`Email Read Imap:update ${seqNo}`, info);\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tconst tlsOptions: IDataObject = {};\n\n\t\t\tif (credentials.allowUnauthorizedCerts) {\n\t\t\t\ttlsOptions.rejectUnauthorized = false;\n\t\t\t}\n\n\t\t\tif (credentials.secure) {\n\t\t\t\ttlsOptions.servername = credentials.host.trim();\n\t\t\t}\n\n\t\t\tif (!isEmpty(tlsOptions)) {\n\t\t\t\tconfig.imap.tlsOptions = tlsOptions;\n\t\t\t}\n\n\t\t\t// Connect to the IMAP server and open the mailbox\n\t\t\t// that we get informed whenever a new email arrives\n\t\t\treturn await imapConnect(config).then(async (conn) => {\n\t\t\t\tconn.on('close', async (_hadError: boolean) => {\n\t\t\t\t\tif (isCurrentlyReconnecting) {\n\t\t\t\t\t\tthis.logger.debug('Email Read Imap: Connected closed for forced reconnecting');\n\t\t\t\t\t} else if (closeFunctionWasCalled) {\n\t\t\t\t\t\tthis.logger.debug('Email Read Imap: Shutting down workflow - connected closed');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.logger.error('Email Read Imap: Connected closed unexpectedly');\n\t\t\t\t\t\tthis.emitError(new Error('Imap connection closed unexpectedly'));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tconn.on('error', async (error) => {\n\t\t\t\t\tconst errorCode = ((error as JsonObject).code as string).toUpperCase();\n\t\t\t\t\tthis.logger.debug(`IMAP connection experienced an error: (${errorCode})`, {\n\t\t\t\t\t\terror: error as Error,\n\t\t\t\t\t});\n\t\t\t\t\tthis.emitError(error as Error);\n\t\t\t\t});\n\t\t\t\treturn conn;\n\t\t\t});\n\t\t};\n\n\t\tconnection = await establishConnection();\n\n\t\tawait connection.openBox(mailbox);\n\n\t\tlet reconnectionInterval: NodeJS.Timeout | undefined;\n\n\t\tconst handleReconnect = async () => {\n\t\t\tthis.logger.debug('Forcing reconnect to IMAP server');\n\t\t\ttry {\n\t\t\t\tisCurrentlyReconnecting = true;\n\t\t\t\tif (connection.closeBox) await connection.closeBox(false);\n\t\t\t\tconnection.end();\n\t\t\t\tconnection = await establishConnection();\n\t\t\t\tawait connection.openBox(mailbox);\n\t\t\t} catch (error) {\n\t\t\t\tthis.logger.error(error as string);\n\t\t\t} finally {\n\t\t\t\tisCurrentlyReconnecting = false;\n\t\t\t}\n\t\t};\n\n\t\tif (options.forceReconnect !== undefined) {\n\t\t\treconnectionInterval = setInterval(\n\t\t\t\thandleReconnect,\n\t\t\t\t(options.forceReconnect as number) * 1000 * 60,\n\t\t\t);\n\t\t}\n\n\t\t// When workflow and so node gets set to inactive close the connection\n\t\tconst closeFunction = async () => {\n\t\t\tcloseFunctionWasCalled = true;\n\t\t\tif (reconnectionInterval) {\n\t\t\t\tclearInterval(reconnectionInterval);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (connection.closeBox) await connection.closeBox(false);\n\t\t\t\tconnection.end();\n\t\t\t} catch (error) {\n\t\t\t\tthrow new TriggerCloseError(this.getNode(), { cause: error as Error, level: 'warning' });\n\t\t\t}\n\t\t};\n\n\t\t// Resolve returned-promise so that waiting errors can be emitted\n\t\treturnedPromise.resolve();\n\n\t\treturn {\n\t\t\tcloseFunction,\n\t\t};\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,kBAAuC;AACvC,qBAAoB;AAcpB,0BAA2E;AAC3E,qBAAoB;AAGpB,kBAAsC;AAEtC,mBAA6B;AAE7B,MAAM,qBAA2C;AAAA,EAChD,aAAa;AAAA,EACb,MAAM;AAAA,EACN,MAAM;AAAA,EACN,WAAW;AAAA,EACX,OAAO,CAAC,SAAS;AAAA,EACjB,SAAS;AAAA,EACT,aAAa;AAAA,EACb,yBAAyB;AAAA,EACzB,UAAU;AAAA,IACT,MAAM;AAAA,IACN,OAAO;AAAA,EACR;AAAA,EACA,cAAc;AAAA,IACb,QAAQ;AAAA,IACR,gBAAgB;AAAA,MACf,UACC;AAAA,MACD,QACC;AAAA,IACF;AAAA,IACA,gBACC;AAAA,EACF;AAAA,EACA,cAAc;AAAA,EACd,QAAQ,CAAC;AAAA,EACT,SAAS,CAAC,wCAAoB,IAAI;AAAA,EAClC,aAAa;AAAA,IACZ;AAAA,MACC,MAAM;AAAA,MACN,UAAU;AAAA,MACV,UAAU;AAAA,IACX;AAAA,EACD;AAAA,EACA,YAAY;AAAA,IACX;AAAA,MACC,aAAa;AAAA,MACb,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,IACV;AAAA,IACA;AAAA,MACC,aAAa;AAAA,MACb,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,QACR;AAAA,UACC,MAAM;AAAA,UACN,OAAO;AAAA,QACR;AAAA,QACA;AAAA,UACC,MAAM;AAAA,UACN,OAAO;AAAA,QACR;AAAA,MACD;AAAA,MACA,SAAS;AAAA,MACT,aACC;AAAA,IACF;AAAA,IACA;AAAA,MACC,aAAa;AAAA,MACb,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,MACT,gBAAgB;AAAA,QACf,MAAM;AAAA,UACL,QAAQ,CAAC,QAAQ;AAAA,QAClB;AAAA,MACD;AAAA,MACA,aACC;AAAA,IACF;AAAA,IACA;AAAA,MACC,aAAa;AAAA,MACb,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,QACR;AAAA,UACC,MAAM;AAAA,UACN,OAAO;AAAA,UACP,aACC;AAAA,QACF;AAAA,QACA;AAAA,UACC,MAAM;AAAA,UACN,OAAO;AAAA,UACP,aACC;AAAA,QACF;AAAA,QACA;AAAA,UACC,MAAM;AAAA,UACN,OAAO;AAAA,UACP,aACC;AAAA,QACF;AAAA,MACD;AAAA,MACA,SAAS;AAAA,MACT,aAAa;AAAA,IACd;AAAA,IACA;AAAA,MACC,aAAa;AAAA,MACb,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,MACT,gBAAgB;AAAA,QACf,MAAM;AAAA,UACL,QAAQ,CAAC,UAAU;AAAA,QACpB;AAAA,MACD;AAAA,MACA,aACC;AAAA,IACF;AAAA,IACA;AAAA,MACC,aAAa;AAAA,MACb,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,MACT,gBAAgB;AAAA,QACf,MAAM;AAAA,UACL,QAAQ,CAAC,QAAQ;AAAA,UACjB,qBAAqB,CAAC,IAAI;AAAA,QAC3B;AAAA,MACD;AAAA,MACA,aACC;AAAA,IACF;AAAA,IACA;AAAA,MACC,aAAa;AAAA,MACb,MAAM;AAAA,MACN,MAAM;AAAA,MACN,aAAa;AAAA,MACb,SAAS,CAAC;AAAA,MACV,SAAS;AAAA,QACR;AAAA,UACC,aAAa;AAAA,UACb,MAAM;AAAA,UACN,MAAM;AAAA,UACN,SAAS;AAAA,UACT,aACC;AAAA,QACF;AAAA,QACA;AAAA,UACC,aAAa;AAAA,UACb,MAAM;AAAA,UACN,MAAM;AAAA,UACN,SAAS;AAAA,UACT,aAAa;AAAA,QACd;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACD;AAEO,MAAM,gBAAqC;AAAA,EAGjD,YAAY,iBAA2C;AAOvD,mBAAU;AAAA,MACT,gBAAgB;AAAA,QACf,MAAM,mBAEL,YACqC;AACrC,kBAAI,mCAAsB,WAAW,IAAI,GAAG;AAC3C,kBAAM,cAAc,WAAW;AAC/B,gBAAI;AACH,oBAAM,SAA4B;AAAA,gBACjC,MAAM;AAAA,kBACL,MAAM,YAAY;AAAA,kBAClB,UAAU,YAAY;AAAA,kBACtB,MAAM,YAAY,KAAK,KAAK;AAAA,kBAC5B,MAAM,YAAY;AAAA,kBAClB,KAAK,YAAY;AAAA,kBACjB,aAAa;AAAA,gBACd;AAAA,cACD;AACA,oBAAM,aAA0B,CAAC;AAEjC,kBAAI,YAAY,wBAAwB;AACvC,2BAAW,qBAAqB;AAAA,cACjC;AAEA,kBAAI,YAAY,QAAQ;AACvB,2BAAW,aAAa,YAAY,KAAK,KAAK;AAAA,cAC/C;AACA,kBAAI,KAAC,eAAAA,SAAQ,UAAU,GAAG;AACzB,uBAAO,KAAK,aAAa;AAAA,cAC1B;AACA,oBAAM,aAAa,UAAM,YAAAC,SAAY,MAAM;AAC3C,oBAAM,WAAW,SAAS;AAC1B,yBAAW,IAAI;AAAA,YAChB,SAAS,OAAO;AACf,qBAAO;AAAA,gBACN,QAAQ;AAAA,gBACR,SAAU,MAAgB;AAAA,cAC3B;AAAA,YACD;AACA,mBAAO;AAAA,cACN,QAAQ;AAAA,cACR,SAAS;AAAA,YACV;AAAA,UACD,OAAO;AACN,mBAAO;AAAA,cACN,QAAQ;AAAA,cACR,SAAS;AAAA,YACV;AAAA,UACD;AAAA,QACD;AAAA,MACD;AAAA,IACD;AA1DC,SAAK,cAAc;AAAA,MAClB,GAAG;AAAA,MACH,GAAG;AAAA,IACJ;AAAA,EACD;AAAA,EAwDA,MAAM,UAA4D;AACjE,UAAM,oBAAoB,MAAM,KAAK,eAAe,MAAM;AAC1D,UAAM,kBAAc,mCAAsB,iBAAiB,IAAI,oBAAoB;AACnF,QAAI,CAAC,aAAa;AACjB,YAAM,IAAI,uCAAmB,KAAK,QAAQ,GAAG,0CAA0C;AAAA,IACxF;AACA,UAAM,UAAU,KAAK,iBAAiB,SAAS;AAC/C,UAAM,oBAAoB,KAAK,iBAAiB,mBAAmB;AACnE,UAAM,UAAU,KAAK,iBAAiB,WAAW,CAAC,CAAC;AAEnD,UAAM,aAAa,KAAK,sBAAsB,MAAM;AACpD,SAAK,OAAO,MAAM,+CAA+C,EAAE,WAAW,CAAC;AAE/E,QAAI;AACJ,QAAI,yBAAyB;AAC7B,QAAI,0BAA0B;AAI9B,UAAM,UAAU,OACf,OACA,SACA,YACqB;AACrB,UAAI,CAAC,QAAQ,WAAW,QAAQ;AAC/B,eAAO;AAAA,MACR;AAEA,YAAM,YAAY,MAAM,OAAO,CAACC,UAAS;AACxC,eACCA,MAAK,KAAK,YAAY,MAAM,UAAUA,MAAK,QAAQ,YAAY,MAAM,QAAQ,YAAY;AAAA,MAE3F,CAAC;AAED,YAAM,OAAO,UAAU,CAAC;AACxB,UAAI,CAAC,MAAM;AACV,eAAO;AAAA,MACR;AAEA,UAAI;AACH,cAAM,WAAW,MAAM,WAAW,YAAY,SAAS,IAAI;AAC3D,eAAO,SAAS,SAAS;AAAA,MAC1B,QAAQ;AACP,eAAO;AAAA,MACR;AAAA,IACD;AAGA,UAAM,gBAAgB,OACrB,gBACA,OACA,YAC4B;AAC5B,UAAI,CAAC,QAAQ,WAAW,QAAQ;AAC/B,eAAO,CAAC;AAAA,MACT;AAGA,YAAM,kBAAkB,MAAM;AAAA,QAC7B,CAAC,SAAS,KAAK,aAAa,MAAM,YAAY,MAAM;AAAA,MACrD;AAEA,YAAM,iBAAiB,CAAC,aAAqB;AAC5C,cAAM,QAAQ;AACd,YAAI,MAAM,KAAK,QAAQ,GAAG;AACzB,iBAAO,eAAAC,QAAQ,OAAO,QAAQ;AAAA,QAC/B;AACA,eAAO;AAAA,MACR;AAEA,YAAM,qBAAqB,CAAC;AAC5B,UAAI;AACJ,iBAAW,kBAAkB,iBAAiB;AAC7C,4BAAoB,eAClB,YAAY,SAAS,cAAc,EACnC,KAAK,OAAO,aAAa;AAEzB,gBAAM,WAAW;AAAA,YACd,eAAe,aAA6B,QAC3C;AAAA,UACJ;AAEA,iBAAO,MAAM,KAAK,QAAQ,kBAAkB,SAAS,QAAQ,QAAQ;AAAA,QACtE,CAAC;AAEF,2BAAmB,KAAK,iBAAiB;AAAA,MAC1C;AAEA,aAAO,MAAM,QAAQ,IAAI,kBAAkB;AAAA,IAC5C;AAEA,UAAM,kBAAkB,KAAK,QAAQ,sBAAsB;AAE3D,UAAM,sBAAsB,YAAiC;AAC5D,UAAI,iBAAiB,CAAC,QAAQ;AAC9B,UAAI,QAAQ,sBAAsB,QAAW;AAC5C,YAAI;AACH,2BAAiB,KAAK,MAAM,QAAQ,iBAA2B;AAAA,QAGhE,SAAS,OAAO;AACf,gBAAM,IAAI,uCAAmB,KAAK,QAAQ,GAAG,wCAAwC;AAAA,QACtF;AAAA,MACD;AAEA,YAAM,SAA4B;AAAA,QACjC,MAAM;AAAA,UACL,MAAM,YAAY;AAAA,UAClB,UAAU,YAAY;AAAA,UACtB,MAAM,YAAY,KAAK,KAAK;AAAA,UAC5B,MAAM,YAAY;AAAA,UAClB,KAAK,YAAY;AAAA,UACjB,aAAa;AAAA,QACd;AAAA,QACA,QAAQ,YAAY;AACnB,cAAI,YAAY;AACf,gBAAI,WAAW,mBAAmB,QAAW;AAC5C,6BAAe,KAAK,CAAC,OAAO,GAAG,WAAW,cAAwB,IAAI,CAAC;AAavE,mBAAK,OAAO,MAAM,qDAAqD;AAAA,gBACtE;AAAA,cACD,CAAC;AAAA,YACF;AAEA,gBAAI;AACH,oBAAM,aAAa,MAAM,0BAAa;AAAA,gBACrC;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,cACD;AACA,kBAAI,WAAW,QAAQ;AACtB,qBAAK,KAAK,CAAC,UAAU,CAAC;AAAA,cACvB;AAAA,YACD,SAAS,OAAO;AACf,mBAAK,OAAO,MAAM,iEAAiE;AAAA,gBAClF;AAAA,cACD,CAAC;AAGD,oBAAM,gBAAgB,QAAQ,KAAK,MAAM;AACxC,qBAAK,UAAU,KAAc;AAAA,cAC9B,CAAC;AAAA,YACF;AAAA,UACD;AAAA,QACD;AAAA,QACA,UAAU,OAAO,OAAe,SAAS;AACxC,eAAK,OAAO,MAAM,0BAA0B,KAAK,IAAI,IAAI;AAAA,QAC1D;AAAA,MACD;AAEA,YAAM,aAA0B,CAAC;AAEjC,UAAI,YAAY,wBAAwB;AACvC,mBAAW,qBAAqB;AAAA,MACjC;AAEA,UAAI,YAAY,QAAQ;AACvB,mBAAW,aAAa,YAAY,KAAK,KAAK;AAAA,MAC/C;AAEA,UAAI,KAAC,eAAAH,SAAQ,UAAU,GAAG;AACzB,eAAO,KAAK,aAAa;AAAA,MAC1B;AAIA,aAAO,UAAM,YAAAC,SAAY,MAAM,EAAE,KAAK,OAAO,SAAS;AACrD,aAAK,GAAG,SAAS,OAAO,cAAuB;AAC9C,cAAI,yBAAyB;AAC5B,iBAAK,OAAO,MAAM,2DAA2D;AAAA,UAC9E,WAAW,wBAAwB;AAClC,iBAAK,OAAO,MAAM,4DAA4D;AAAA,UAC/E,OAAO;AACN,iBAAK,OAAO,MAAM,gDAAgD;AAClE,iBAAK,UAAU,IAAI,MAAM,qCAAqC,CAAC;AAAA,UAChE;AAAA,QACD,CAAC;AACD,aAAK,GAAG,SAAS,OAAO,UAAU;AACjC,gBAAM,YAAc,MAAqB,KAAgB,YAAY;AACrE,eAAK,OAAO,MAAM,0CAA0C,SAAS,KAAK;AAAA,YACzE;AAAA,UACD,CAAC;AACD,eAAK,UAAU,KAAc;AAAA,QAC9B,CAAC;AACD,eAAO;AAAA,MACR,CAAC;AAAA,IACF;AAEA,iBAAa,MAAM,oBAAoB;AAEvC,UAAM,WAAW,QAAQ,OAAO;AAEhC,QAAI;AAEJ,UAAM,kBAAkB,YAAY;AACnC,WAAK,OAAO,MAAM,kCAAkC;AACpD,UAAI;AACH,kCAA0B;AAC1B,YAAI,WAAW,SAAU,OAAM,WAAW,SAAS,KAAK;AACxD,mBAAW,IAAI;AACf,qBAAa,MAAM,oBAAoB;AACvC,cAAM,WAAW,QAAQ,OAAO;AAAA,MACjC,SAAS,OAAO;AACf,aAAK,OAAO,MAAM,KAAe;AAAA,MAClC,UAAE;AACD,kCAA0B;AAAA,MAC3B;AAAA,IACD;AAEA,QAAI,QAAQ,mBAAmB,QAAW;AACzC,6BAAuB;AAAA,QACtB;AAAA,QACC,QAAQ,iBAA4B,MAAO;AAAA,MAC7C;AAAA,IACD;AAGA,UAAM,gBAAgB,YAAY;AACjC,+BAAyB;AACzB,UAAI,sBAAsB;AACzB,sBAAc,oBAAoB;AAAA,MACnC;AACA,UAAI;AACH,YAAI,WAAW,SAAU,OAAM,WAAW,SAAS,KAAK;AACxD,mBAAW,IAAI;AAAA,MAChB,SAAS,OAAO;AACf,cAAM,IAAI,sCAAkB,KAAK,QAAQ,GAAG,EAAE,OAAO,OAAgB,OAAO,UAAU,CAAC;AAAA,MACxF;AAAA,IACD;AAGA,oBAAgB,QAAQ;AAExB,WAAO;AAAA,MACN;AAAA,IACD;AAAA,EACD;AACD;","names":["isEmpty","imapConnect","part","rfc2047"]}
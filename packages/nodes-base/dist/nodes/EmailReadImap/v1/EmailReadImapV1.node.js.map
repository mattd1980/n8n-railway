{"version":3,"sources":["../../../../nodes/EmailReadImap/v1/EmailReadImapV1.node.ts"],"sourcesContent":["import type { ImapSimple, ImapSimpleOptions, Message } from '@n8n/imap';\nimport { connect as imapConnect, getParts } from '@n8n/imap';\nimport find from 'lodash/find';\nimport isEmpty from 'lodash/isEmpty';\nimport type { Source as ParserSource } from 'mailparser';\nimport { simpleParser } from 'mailparser';\nimport { NodeConnectionTypes, NodeOperationError } from 'n8n-workflow';\nimport type {\n\tITriggerFunctions,\n\tIBinaryData,\n\tIBinaryKeyData,\n\tICredentialDataDecryptedObject,\n\tICredentialsDecrypted,\n\tICredentialTestFunctions,\n\tIDataObject,\n\tINodeCredentialTestResult,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeBaseDescription,\n\tINodeTypeDescription,\n\tITriggerResponse,\n} from 'n8n-workflow';\n\nexport async function parseRawEmail(\n\tthis: ITriggerFunctions,\n\tmessageEncoded: ParserSource,\n\tdataPropertyNameDownload: string,\n): Promise<INodeExecutionData> {\n\tconst responseData = await simpleParser(messageEncoded);\n\tconst headers: IDataObject = {};\n\tfor (const header of responseData.headerLines) {\n\t\theaders[header.key] = header.line;\n\t}\n\n\t// @ts-ignore\n\tresponseData.headers = headers;\n\t// @ts-ignore\n\tresponseData.headerLines = undefined;\n\n\tconst binaryData: IBinaryKeyData = {};\n\tif (responseData.attachments) {\n\t\tfor (let i = 0; i < responseData.attachments.length; i++) {\n\t\t\tconst attachment = responseData.attachments[i];\n\t\t\tbinaryData[`${dataPropertyNameDownload}${i}`] = await this.helpers.prepareBinaryData(\n\t\t\t\tattachment.content,\n\t\t\t\tattachment.filename,\n\t\t\t\tattachment.contentType,\n\t\t\t);\n\t\t}\n\t\t// @ts-ignore\n\t\tresponseData.attachments = undefined;\n\t}\n\n\treturn {\n\t\tjson: responseData as unknown as IDataObject,\n\t\tbinary: Object.keys(binaryData).length ? binaryData : undefined,\n\t} as INodeExecutionData;\n}\n\nconst versionDescription: INodeTypeDescription = {\n\tdisplayName: 'Email Trigger (IMAP)',\n\tname: 'emailReadImap',\n\ticon: 'fa:inbox',\n\tgroup: ['trigger'],\n\tversion: 1,\n\tdescription: 'Triggers the workflow when a new email is received',\n\teventTriggerDescription: 'Waiting for you to receive an email',\n\tdefaults: {\n\t\tname: 'Email Trigger (IMAP)',\n\t\tcolor: '#44AA22',\n\t},\n\ttriggerPanel: {\n\t\theader: '',\n\t\texecutionsHelp: {\n\t\t\tinactive:\n\t\t\t\t\"<b>While building your workflow</b>, click the 'execute step' button, then send an email to make an event happen. This will trigger an execution, which will show up in this editor.<br /> <br /><b>Once you're happy with your workflow</b>, <a data-key='activate'>activate</a> it. Then every time an email is received, the workflow will execute. These executions will show up in the <a data-key='executions'>executions list</a>, but not in the editor.\",\n\t\t\tactive:\n\t\t\t\t\"<b>While building your workflow</b>, click the 'execute step' button, then send an email to make an event happen. This will trigger an execution, which will show up in this editor.<br /> <br /><b>Your workflow will also execute automatically</b>, since it's activated. Every time an email is received, this node will trigger an execution. These executions will show up in the <a data-key='executions'>executions list</a>, but not in the editor.\",\n\t\t},\n\t\tactivationHint:\n\t\t\t\"Once you’ve finished building your workflow, <a data-key='activate'>activate</a> it to have it also listen continuously (you just won’t see those executions here).\",\n\t},\n\n\tinputs: [],\n\toutputs: [NodeConnectionTypes.Main],\n\tcredentials: [\n\t\t{\n\t\t\tname: 'imap',\n\t\t\trequired: true,\n\t\t\ttestedBy: 'imapConnectionTest',\n\t\t},\n\t],\n\tproperties: [\n\t\t{\n\t\t\tdisplayName: 'Mailbox Name',\n\t\t\tname: 'mailbox',\n\t\t\ttype: 'string',\n\t\t\tdefault: 'INBOX',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Action',\n\t\t\tname: 'postProcessAction',\n\t\t\ttype: 'options',\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'Mark as Read',\n\t\t\t\t\tvalue: 'read',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Nothing',\n\t\t\t\t\tvalue: 'nothing',\n\t\t\t\t},\n\t\t\t],\n\t\t\tdefault: 'read',\n\t\t\tdescription:\n\t\t\t\t'What to do after the email has been received. If \"nothing\" gets selected it will be processed multiple times.',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Download Attachments',\n\t\t\tname: 'downloadAttachments',\n\t\t\ttype: 'boolean',\n\t\t\tdefault: false,\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\tformat: ['simple'],\n\t\t\t\t},\n\t\t\t},\n\t\t\tdescription:\n\t\t\t\t'Whether attachments of emails should be downloaded. Only set if needed as it increases processing.',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Format',\n\t\t\tname: 'format',\n\t\t\ttype: 'options',\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tname: 'RAW',\n\t\t\t\t\tvalue: 'raw',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Returns the full email message data with body content in the raw field as a base64url encoded string; the payload field is not used',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Resolved',\n\t\t\t\t\tvalue: 'resolved',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Returns the full email with all data resolved and attachments saved as binary data',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'Simple',\n\t\t\t\t\tvalue: 'simple',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Returns the full email; do not use if you wish to gather inline attachments',\n\t\t\t\t},\n\t\t\t],\n\t\t\tdefault: 'simple',\n\t\t\tdescription: 'The format to return the message in',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Property Prefix Name',\n\t\t\tname: 'dataPropertyAttachmentsPrefixName',\n\t\t\ttype: 'string',\n\t\t\tdefault: 'attachment_',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\tformat: ['resolved'],\n\t\t\t\t},\n\t\t\t},\n\t\t\tdescription:\n\t\t\t\t'Prefix for name of the binary property to which to write the attachments. An index starting with 0 will be added. So if name is \"attachment_\" the first attachment is saved to \"attachment_0\"',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Property Prefix Name',\n\t\t\tname: 'dataPropertyAttachmentsPrefixName',\n\t\t\ttype: 'string',\n\t\t\tdefault: 'attachment_',\n\t\t\tdisplayOptions: {\n\t\t\t\tshow: {\n\t\t\t\t\tformat: ['simple'],\n\t\t\t\t\tdownloadAttachments: [true],\n\t\t\t\t},\n\t\t\t},\n\t\t\tdescription:\n\t\t\t\t'Prefix for name of the binary property to which to write the attachments. An index starting with 0 will be added. So if name is \"attachment_\" the first attachment is saved to \"attachment_0\"',\n\t\t},\n\t\t{\n\t\t\tdisplayName: 'Options',\n\t\t\tname: 'options',\n\t\t\ttype: 'collection',\n\t\t\tplaceholder: 'Add option',\n\t\t\tdefault: {},\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Custom Email Rules',\n\t\t\t\t\tname: 'customEmailConfig',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdefault: '[\"UNSEEN\"]',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'Custom email fetching rules. See <a href=\"https://github.com/mscdex/node-imap\">node-imap</a>\\'s search function for more details.',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Ignore SSL Issues (Insecure)',\n\t\t\t\t\tname: 'allowUnauthorizedCerts',\n\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\tdefault: false,\n\t\t\t\t\tdescription: 'Whether to connect even if SSL certificate validation is not possible',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Force Reconnect',\n\t\t\t\t\tname: 'forceReconnect',\n\t\t\t\t\ttype: 'number',\n\t\t\t\t\tdefault: 60,\n\t\t\t\t\tdescription: 'Sets an interval (in minutes) to force a reconnection',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport class EmailReadImapV1 implements INodeType {\n\tdescription: INodeTypeDescription;\n\n\tconstructor(baseDescription: INodeTypeBaseDescription) {\n\t\tthis.description = {\n\t\t\t...baseDescription,\n\t\t\t...versionDescription,\n\t\t};\n\t}\n\n\tmethods = {\n\t\tcredentialTest: {\n\t\t\tasync imapConnectionTest(\n\t\t\t\tthis: ICredentialTestFunctions,\n\t\t\t\tcredential: ICredentialsDecrypted,\n\t\t\t): Promise<INodeCredentialTestResult> {\n\t\t\t\tconst credentials = credential.data as ICredentialDataDecryptedObject;\n\t\t\t\ttry {\n\t\t\t\t\tconst config: ImapSimpleOptions = {\n\t\t\t\t\t\timap: {\n\t\t\t\t\t\t\tuser: credentials.user as string,\n\t\t\t\t\t\t\tpassword: credentials.password as string,\n\t\t\t\t\t\t\thost: (credentials.host as string).trim(),\n\t\t\t\t\t\t\tport: credentials.port as number,\n\t\t\t\t\t\t\ttls: credentials.secure as boolean,\n\t\t\t\t\t\t\tauthTimeout: 20000,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t\tconst tlsOptions: IDataObject = {};\n\n\t\t\t\t\tif (credentials.secure) {\n\t\t\t\t\t\ttlsOptions.servername = (credentials.host as string).trim();\n\t\t\t\t\t}\n\t\t\t\t\tif (!isEmpty(tlsOptions)) {\n\t\t\t\t\t\tconfig.imap.tlsOptions = tlsOptions;\n\t\t\t\t\t}\n\t\t\t\t\tconst connection = await imapConnect(config);\n\t\t\t\t\tawait connection.getBoxes();\n\t\t\t\t} catch (error) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstatus: 'Error',\n\t\t\t\t\t\tmessage: error.message,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tstatus: 'OK',\n\t\t\t\t\tmessage: 'Connection successful!',\n\t\t\t\t};\n\t\t\t},\n\t\t},\n\t};\n\n\tasync trigger(this: ITriggerFunctions): Promise<ITriggerResponse> {\n\t\tconst credentials = await this.getCredentials('imap');\n\n\t\tconst mailbox = this.getNodeParameter('mailbox') as string;\n\t\tconst postProcessAction = this.getNodeParameter('postProcessAction') as string;\n\t\tconst options = this.getNodeParameter('options', {}) as IDataObject;\n\n\t\tconst staticData = this.getWorkflowStaticData('node');\n\t\tthis.logger.debug('Loaded static data for node \"EmailReadImap\"', { staticData });\n\n\t\tlet connection: ImapSimple;\n\n\t\t// Returns the email text\n\n\t\tconst getText = async (parts: any[], message: Message, subtype: string): Promise<string> => {\n\t\t\tif (!message.attributes.struct) {\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\tconst textParts = parts.filter((part) => {\n\t\t\t\treturn (\n\t\t\t\t\tpart.type.toUpperCase() === 'TEXT' && part.subtype.toUpperCase() === subtype.toUpperCase()\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tconst part = textParts[0];\n\t\t\tif (!part) {\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst partData = await connection.getPartData(message, part);\n\t\t\t\treturn partData.toString();\n\t\t\t} catch {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t};\n\n\t\t// Returns the email attachments\n\t\tconst getAttachment = async (\n\t\t\timapConnection: ImapSimple,\n\t\t\tparts: any[],\n\t\t\tmessage: Message,\n\t\t): Promise<IBinaryData[]> => {\n\t\t\tif (!message.attributes.struct) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// Check if the message has attachments and if so get them\n\t\t\tconst attachmentParts = parts.filter((part) => {\n\t\t\t\treturn part.disposition && part.disposition.type.toUpperCase() === 'ATTACHMENT';\n\t\t\t});\n\n\t\t\tconst attachmentPromises = [];\n\t\t\tlet attachmentPromise;\n\t\t\tfor (const attachmentPart of attachmentParts) {\n\t\t\t\tattachmentPromise = imapConnection\n\t\t\t\t\t.getPartData(message, attachmentPart)\n\t\t\t\t\t.then(async (partData) => {\n\t\t\t\t\t\t// Return it in the format n8n expects\n\t\t\t\t\t\treturn await this.helpers.prepareBinaryData(\n\t\t\t\t\t\t\tpartData.buffer,\n\t\t\t\t\t\t\tattachmentPart.disposition.params.filename as string,\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\n\t\t\t\tattachmentPromises.push(attachmentPromise);\n\t\t\t}\n\n\t\t\treturn await Promise.all(attachmentPromises);\n\t\t};\n\n\t\t// Returns all the new unseen messages\n\t\tconst getNewEmails = async (\n\t\t\timapConnection: ImapSimple,\n\t\t\tsearchCriteria: Array<string | string[]>,\n\t\t): Promise<INodeExecutionData[]> => {\n\t\t\tconst format = this.getNodeParameter('format', 0) as string;\n\n\t\t\tlet fetchOptions = {};\n\n\t\t\tif (format === 'simple' || format === 'raw') {\n\t\t\t\tfetchOptions = {\n\t\t\t\t\tbodies: ['TEXT', 'HEADER'],\n\t\t\t\t\tmarkSeen: false,\n\t\t\t\t\tstruct: true,\n\t\t\t\t};\n\t\t\t} else if (format === 'resolved') {\n\t\t\t\tfetchOptions = {\n\t\t\t\t\tbodies: [''],\n\t\t\t\t\tmarkSeen: false,\n\t\t\t\t\tstruct: true,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst results = await imapConnection.search(searchCriteria, fetchOptions);\n\n\t\t\tconst newEmails: INodeExecutionData[] = [];\n\t\t\tlet newEmail: INodeExecutionData;\n\t\t\tlet attachments: IBinaryData[];\n\t\t\tlet propertyName: string;\n\n\t\t\t// All properties get by default moved to metadata except the ones\n\t\t\t// which are defined here which get set on the top level.\n\t\t\tconst topLevelProperties = ['cc', 'date', 'from', 'subject', 'to'];\n\n\t\t\tif (format === 'resolved') {\n\t\t\t\tconst dataPropertyAttachmentsPrefixName = this.getNodeParameter(\n\t\t\t\t\t'dataPropertyAttachmentsPrefixName',\n\t\t\t\t) as string;\n\n\t\t\t\tfor (const message of results) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tstaticData.lastMessageUid !== undefined &&\n\t\t\t\t\t\tmessage.attributes.uid <= (staticData.lastMessageUid as number)\n\t\t\t\t\t) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tstaticData.lastMessageUid === undefined ||\n\t\t\t\t\t\t(staticData.lastMessageUid as number) < message.attributes.uid\n\t\t\t\t\t) {\n\t\t\t\t\t\tstaticData.lastMessageUid = message.attributes.uid;\n\t\t\t\t\t}\n\t\t\t\t\tconst part = find(message.parts, { which: '' });\n\n\t\t\t\t\tif (part === undefined) {\n\t\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Email part could not be parsed.');\n\t\t\t\t\t}\n\t\t\t\t\tconst parsedEmail = await parseRawEmail.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\tpart.body as Buffer,\n\t\t\t\t\t\tdataPropertyAttachmentsPrefixName,\n\t\t\t\t\t);\n\n\t\t\t\t\tnewEmails.push(parsedEmail);\n\t\t\t\t}\n\t\t\t} else if (format === 'simple') {\n\t\t\t\tconst downloadAttachments = this.getNodeParameter('downloadAttachments') as boolean;\n\n\t\t\t\tlet dataPropertyAttachmentsPrefixName = '';\n\t\t\t\tif (downloadAttachments) {\n\t\t\t\t\tdataPropertyAttachmentsPrefixName = this.getNodeParameter(\n\t\t\t\t\t\t'dataPropertyAttachmentsPrefixName',\n\t\t\t\t\t) as string;\n\t\t\t\t}\n\n\t\t\t\tfor (const message of results) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tstaticData.lastMessageUid !== undefined &&\n\t\t\t\t\t\tmessage.attributes.uid <= (staticData.lastMessageUid as number)\n\t\t\t\t\t) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tstaticData.lastMessageUid === undefined ||\n\t\t\t\t\t\t(staticData.lastMessageUid as number) < message.attributes.uid\n\t\t\t\t\t) {\n\t\t\t\t\t\tstaticData.lastMessageUid = message.attributes.uid;\n\t\t\t\t\t}\n\t\t\t\t\tconst parts = getParts(message.attributes.struct!);\n\n\t\t\t\t\tnewEmail = {\n\t\t\t\t\t\tjson: {\n\t\t\t\t\t\t\ttextHtml: await getText(parts, message, 'html'),\n\t\t\t\t\t\t\ttextPlain: await getText(parts, message, 'plain'),\n\t\t\t\t\t\t\tmetadata: {} as IDataObject,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\n\t\t\t\t\tconst messageHeader = message.parts.filter((part) => part.which === 'HEADER');\n\n\t\t\t\t\tconst messageBody = messageHeader[0].body as Record<string, string[]>;\n\t\t\t\t\tfor (propertyName of Object.keys(messageBody as IDataObject)) {\n\t\t\t\t\t\tif (messageBody[propertyName].length) {\n\t\t\t\t\t\t\tif (topLevelProperties.includes(propertyName)) {\n\t\t\t\t\t\t\t\tnewEmail.json[propertyName] = messageBody[propertyName][0];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t(newEmail.json.metadata as IDataObject)[propertyName] =\n\t\t\t\t\t\t\t\t\tmessageBody[propertyName][0];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (downloadAttachments) {\n\t\t\t\t\t\t// Get attachments and add them if any get found\n\t\t\t\t\t\tattachments = await getAttachment(imapConnection, parts, message);\n\t\t\t\t\t\tif (attachments.length) {\n\t\t\t\t\t\t\tnewEmail.binary = {};\n\t\t\t\t\t\t\tfor (let i = 0; i < attachments.length; i++) {\n\t\t\t\t\t\t\t\tnewEmail.binary[`${dataPropertyAttachmentsPrefixName}${i}`] = attachments[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tnewEmails.push(newEmail);\n\t\t\t\t}\n\t\t\t} else if (format === 'raw') {\n\t\t\t\tfor (const message of results) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tstaticData.lastMessageUid !== undefined &&\n\t\t\t\t\t\tmessage.attributes.uid <= (staticData.lastMessageUid as number)\n\t\t\t\t\t) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tstaticData.lastMessageUid === undefined ||\n\t\t\t\t\t\t(staticData.lastMessageUid as number) < message.attributes.uid\n\t\t\t\t\t) {\n\t\t\t\t\t\tstaticData.lastMessageUid = message.attributes.uid;\n\t\t\t\t\t}\n\t\t\t\t\tconst part = find(message.parts, { which: 'TEXT' });\n\n\t\t\t\t\tif (part === undefined) {\n\t\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Email part could not be parsed.');\n\t\t\t\t\t}\n\t\t\t\t\t// Return base64 string\n\t\t\t\t\tnewEmail = {\n\t\t\t\t\t\tjson: {\n\t\t\t\t\t\t\traw: part.body,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\n\t\t\t\t\tnewEmails.push(newEmail);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// only mark messages as seen once processing has finished\n\t\t\tif (postProcessAction === 'read') {\n\t\t\t\tconst uidList = results.map((e) => e.attributes.uid);\n\t\t\t\tif (uidList.length > 0) {\n\t\t\t\t\tawait imapConnection.addFlags(uidList, '\\\\SEEN');\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn newEmails;\n\t\t};\n\n\t\tconst returnedPromise = this.helpers.createDeferredPromise();\n\n\t\tconst establishConnection = async (): Promise<ImapSimple> => {\n\t\t\tlet searchCriteria = ['UNSEEN'] as Array<string | string[]>;\n\t\t\tif (options.customEmailConfig !== undefined) {\n\t\t\t\ttry {\n\t\t\t\t\tsearchCriteria = JSON.parse(options.customEmailConfig as string);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Custom email config is not valid JSON.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst config: ImapSimpleOptions = {\n\t\t\t\timap: {\n\t\t\t\t\tuser: credentials.user as string,\n\t\t\t\t\tpassword: credentials.password as string,\n\t\t\t\t\thost: (credentials.host as string).trim(),\n\t\t\t\t\tport: credentials.port as number,\n\t\t\t\t\ttls: credentials.secure as boolean,\n\t\t\t\t\tauthTimeout: 20000,\n\t\t\t\t},\n\t\t\t\tonMail: async () => {\n\t\t\t\t\tif (connection) {\n\t\t\t\t\t\tif (staticData.lastMessageUid !== undefined) {\n\t\t\t\t\t\t\tsearchCriteria.push(['UID', `${staticData.lastMessageUid as number}:*`]);\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * A short explanation about UIDs and how they work\n\t\t\t\t\t\t\t * can be found here: https://dev.to/kehers/imap-new-messages-since-last-check-44gm\n\t\t\t\t\t\t\t * TL;DR:\n\t\t\t\t\t\t\t * - You cannot filter using ['UID', 'CURRENT ID + 1:*'] because IMAP\n\t\t\t\t\t\t\t * won't return correct results if current id + 1 does not yet exist.\n\t\t\t\t\t\t\t * - UIDs can change but this is not being treated here.\n\t\t\t\t\t\t\t * If the mailbox is recreated (lets say you remove all emails, remove\n\t\t\t\t\t\t\t * the mail box and create another with same name, UIDs will change)\n\t\t\t\t\t\t\t * - You can check if UIDs changed in the above example\n\t\t\t\t\t\t\t * by checking UIDValidity.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tthis.logger.debug('Querying for new messages on node \"EmailReadImap\"', {\n\t\t\t\t\t\t\t\tsearchCriteria,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst returnData = await getNewEmails(connection, searchCriteria);\n\t\t\t\t\t\t\tif (returnData.length) {\n\t\t\t\t\t\t\t\tthis.emit([returnData]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tthis.logger.error('Email Read Imap node encountered an error fetching new emails', {\n\t\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t// Wait with resolving till the returnedPromise got resolved, else n8n will be unhappy\n\t\t\t\t\t\t\t// if it receives an error before the workflow got activated\n\t\t\t\t\t\t\tawait returnedPromise.promise.then(() => {\n\t\t\t\t\t\t\t\tthis.emitError(error as Error);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tconst tlsOptions: IDataObject = {};\n\n\t\t\tif (options.allowUnauthorizedCerts === true) {\n\t\t\t\ttlsOptions.rejectUnauthorized = false;\n\t\t\t}\n\n\t\t\tif (credentials.secure) {\n\t\t\t\ttlsOptions.servername = (credentials.host as string).trim();\n\t\t\t}\n\n\t\t\tif (!isEmpty(tlsOptions)) {\n\t\t\t\tconfig.imap.tlsOptions = tlsOptions;\n\t\t\t}\n\n\t\t\t// Connect to the IMAP server and open the mailbox\n\t\t\t// that we get informed whenever a new email arrives\n\t\t\treturn await imapConnect(config).then(async (conn) => {\n\t\t\t\tconn.on('error', async (error) => {\n\t\t\t\t\tconst errorCode = error.code.toUpperCase();\n\t\t\t\t\tif (['ECONNRESET', 'EPIPE'].includes(errorCode as string)) {\n\t\t\t\t\t\tthis.logger.debug(`IMAP connection was reset (${errorCode}) - reconnecting.`, {\n\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t});\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconnection = await establishConnection();\n\t\t\t\t\t\t\tawait connection.openBox(mailbox);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tthis.logger.error('IMAP reconnect did fail', { error: e });\n\t\t\t\t\t\t\t// If something goes wrong we want to run emitError\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.logger.error('Email Read Imap node encountered a connection error', { error });\n\t\t\t\t\t\tthis.emitError(error as Error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn conn;\n\t\t\t});\n\t\t};\n\n\t\tconnection = await establishConnection();\n\n\t\tawait connection.openBox(mailbox);\n\n\t\tlet reconnectionInterval: NodeJS.Timeout | undefined;\n\n\t\tif (options.forceReconnect !== undefined) {\n\t\t\treconnectionInterval = setInterval(\n\t\t\t\tasync () => {\n\t\t\t\t\tthis.logger.debug('Forcing reconnection of IMAP node.');\n\t\t\t\t\tconnection.end();\n\t\t\t\t\tconnection = await establishConnection();\n\t\t\t\t\tawait connection.openBox(mailbox);\n\t\t\t\t},\n\t\t\t\t(options.forceReconnect as number) * 1000 * 60,\n\t\t\t);\n\t\t}\n\n\t\t// When workflow and so node gets set to inactive close the connectoin\n\t\tasync function closeFunction() {\n\t\t\tif (reconnectionInterval) {\n\t\t\t\tclearInterval(reconnectionInterval);\n\t\t\t}\n\t\t\tconnection.end();\n\t\t}\n\n\t\t// Resolve returned-promise so that waiting errors can be emitted\n\t\treturnedPromise.resolve();\n\n\t\treturn {\n\t\t\tcloseFunction,\n\t\t};\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,kBAAiD;AACjD,kBAAiB;AACjB,qBAAoB;AAEpB,wBAA6B;AAC7B,0BAAwD;AAiBxD,eAAsB,cAErB,gBACA,0BAC8B;AAC9B,QAAM,eAAe,UAAM,gCAAa,cAAc;AACtD,QAAM,UAAuB,CAAC;AAC9B,aAAW,UAAU,aAAa,aAAa;AAC9C,YAAQ,OAAO,GAAG,IAAI,OAAO;AAAA,EAC9B;AAGA,eAAa,UAAU;AAEvB,eAAa,cAAc;AAE3B,QAAM,aAA6B,CAAC;AACpC,MAAI,aAAa,aAAa;AAC7B,aAAS,IAAI,GAAG,IAAI,aAAa,YAAY,QAAQ,KAAK;AACzD,YAAM,aAAa,aAAa,YAAY,CAAC;AAC7C,iBAAW,GAAG,wBAAwB,GAAG,CAAC,EAAE,IAAI,MAAM,KAAK,QAAQ;AAAA,QAClE,WAAW;AAAA,QACX,WAAW;AAAA,QACX,WAAW;AAAA,MACZ;AAAA,IACD;AAEA,iBAAa,cAAc;AAAA,EAC5B;AAEA,SAAO;AAAA,IACN,MAAM;AAAA,IACN,QAAQ,OAAO,KAAK,UAAU,EAAE,SAAS,aAAa;AAAA,EACvD;AACD;AAEA,MAAM,qBAA2C;AAAA,EAChD,aAAa;AAAA,EACb,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO,CAAC,SAAS;AAAA,EACjB,SAAS;AAAA,EACT,aAAa;AAAA,EACb,yBAAyB;AAAA,EACzB,UAAU;AAAA,IACT,MAAM;AAAA,IACN,OAAO;AAAA,EACR;AAAA,EACA,cAAc;AAAA,IACb,QAAQ;AAAA,IACR,gBAAgB;AAAA,MACf,UACC;AAAA,MACD,QACC;AAAA,IACF;AAAA,IACA,gBACC;AAAA,EACF;AAAA,EAEA,QAAQ,CAAC;AAAA,EACT,SAAS,CAAC,wCAAoB,IAAI;AAAA,EAClC,aAAa;AAAA,IACZ;AAAA,MACC,MAAM;AAAA,MACN,UAAU;AAAA,MACV,UAAU;AAAA,IACX;AAAA,EACD;AAAA,EACA,YAAY;AAAA,IACX;AAAA,MACC,aAAa;AAAA,MACb,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,IACV;AAAA,IACA;AAAA,MACC,aAAa;AAAA,MACb,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,QACR;AAAA,UACC,MAAM;AAAA,UACN,OAAO;AAAA,QACR;AAAA,QACA;AAAA,UACC,MAAM;AAAA,UACN,OAAO;AAAA,QACR;AAAA,MACD;AAAA,MACA,SAAS;AAAA,MACT,aACC;AAAA,IACF;AAAA,IACA;AAAA,MACC,aAAa;AAAA,MACb,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,MACT,gBAAgB;AAAA,QACf,MAAM;AAAA,UACL,QAAQ,CAAC,QAAQ;AAAA,QAClB;AAAA,MACD;AAAA,MACA,aACC;AAAA,IACF;AAAA,IACA;AAAA,MACC,aAAa;AAAA,MACb,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,QACR;AAAA,UACC,MAAM;AAAA,UACN,OAAO;AAAA,UACP,aACC;AAAA,QACF;AAAA,QACA;AAAA,UACC,MAAM;AAAA,UACN,OAAO;AAAA,UACP,aACC;AAAA,QACF;AAAA,QACA;AAAA,UACC,MAAM;AAAA,UACN,OAAO;AAAA,UACP,aACC;AAAA,QACF;AAAA,MACD;AAAA,MACA,SAAS;AAAA,MACT,aAAa;AAAA,IACd;AAAA,IACA;AAAA,MACC,aAAa;AAAA,MACb,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,MACT,gBAAgB;AAAA,QACf,MAAM;AAAA,UACL,QAAQ,CAAC,UAAU;AAAA,QACpB;AAAA,MACD;AAAA,MACA,aACC;AAAA,IACF;AAAA,IACA;AAAA,MACC,aAAa;AAAA,MACb,MAAM;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,MACT,gBAAgB;AAAA,QACf,MAAM;AAAA,UACL,QAAQ,CAAC,QAAQ;AAAA,UACjB,qBAAqB,CAAC,IAAI;AAAA,QAC3B;AAAA,MACD;AAAA,MACA,aACC;AAAA,IACF;AAAA,IACA;AAAA,MACC,aAAa;AAAA,MACb,MAAM;AAAA,MACN,MAAM;AAAA,MACN,aAAa;AAAA,MACb,SAAS,CAAC;AAAA,MACV,SAAS;AAAA,QACR;AAAA,UACC,aAAa;AAAA,UACb,MAAM;AAAA,UACN,MAAM;AAAA,UACN,SAAS;AAAA,UACT,aACC;AAAA,QACF;AAAA,QACA;AAAA,UACC,aAAa;AAAA,UACb,MAAM;AAAA,UACN,MAAM;AAAA,UACN,SAAS;AAAA,UACT,aAAa;AAAA,QACd;AAAA,QACA;AAAA,UACC,aAAa;AAAA,UACb,MAAM;AAAA,UACN,MAAM;AAAA,UACN,SAAS;AAAA,UACT,aAAa;AAAA,QACd;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACD;AAEO,MAAM,gBAAqC;AAAA,EAGjD,YAAY,iBAA2C;AAOvD,mBAAU;AAAA,MACT,gBAAgB;AAAA,QACf,MAAM,mBAEL,YACqC;AACrC,gBAAM,cAAc,WAAW;AAC/B,cAAI;AACH,kBAAM,SAA4B;AAAA,cACjC,MAAM;AAAA,gBACL,MAAM,YAAY;AAAA,gBAClB,UAAU,YAAY;AAAA,gBACtB,MAAO,YAAY,KAAgB,KAAK;AAAA,gBACxC,MAAM,YAAY;AAAA,gBAClB,KAAK,YAAY;AAAA,gBACjB,aAAa;AAAA,cACd;AAAA,YACD;AACA,kBAAM,aAA0B,CAAC;AAEjC,gBAAI,YAAY,QAAQ;AACvB,yBAAW,aAAc,YAAY,KAAgB,KAAK;AAAA,YAC3D;AACA,gBAAI,KAAC,eAAAA,SAAQ,UAAU,GAAG;AACzB,qBAAO,KAAK,aAAa;AAAA,YAC1B;AACA,kBAAM,aAAa,UAAM,YAAAC,SAAY,MAAM;AAC3C,kBAAM,WAAW,SAAS;AAAA,UAC3B,SAAS,OAAO;AACf,mBAAO;AAAA,cACN,QAAQ;AAAA,cACR,SAAS,MAAM;AAAA,YAChB;AAAA,UACD;AACA,iBAAO;AAAA,YACN,QAAQ;AAAA,YACR,SAAS;AAAA,UACV;AAAA,QACD;AAAA,MACD;AAAA,IACD;AA9CC,SAAK,cAAc;AAAA,MAClB,GAAG;AAAA,MACH,GAAG;AAAA,IACJ;AAAA,EACD;AAAA,EA4CA,MAAM,UAA4D;AACjE,UAAM,cAAc,MAAM,KAAK,eAAe,MAAM;AAEpD,UAAM,UAAU,KAAK,iBAAiB,SAAS;AAC/C,UAAM,oBAAoB,KAAK,iBAAiB,mBAAmB;AACnE,UAAM,UAAU,KAAK,iBAAiB,WAAW,CAAC,CAAC;AAEnD,UAAM,aAAa,KAAK,sBAAsB,MAAM;AACpD,SAAK,OAAO,MAAM,+CAA+C,EAAE,WAAW,CAAC;AAE/E,QAAI;AAIJ,UAAM,UAAU,OAAO,OAAc,SAAkB,YAAqC;AAC3F,UAAI,CAAC,QAAQ,WAAW,QAAQ;AAC/B,eAAO;AAAA,MACR;AAEA,YAAM,YAAY,MAAM,OAAO,CAACC,UAAS;AACxC,eACCA,MAAK,KAAK,YAAY,MAAM,UAAUA,MAAK,QAAQ,YAAY,MAAM,QAAQ,YAAY;AAAA,MAE3F,CAAC;AAED,YAAM,OAAO,UAAU,CAAC;AACxB,UAAI,CAAC,MAAM;AACV,eAAO;AAAA,MACR;AAEA,UAAI;AACH,cAAM,WAAW,MAAM,WAAW,YAAY,SAAS,IAAI;AAC3D,eAAO,SAAS,SAAS;AAAA,MAC1B,QAAQ;AACP,eAAO;AAAA,MACR;AAAA,IACD;AAGA,UAAM,gBAAgB,OACrB,gBACA,OACA,YAC4B;AAC5B,UAAI,CAAC,QAAQ,WAAW,QAAQ;AAC/B,eAAO,CAAC;AAAA,MACT;AAGA,YAAM,kBAAkB,MAAM,OAAO,CAAC,SAAS;AAC9C,eAAO,KAAK,eAAe,KAAK,YAAY,KAAK,YAAY,MAAM;AAAA,MACpE,CAAC;AAED,YAAM,qBAAqB,CAAC;AAC5B,UAAI;AACJ,iBAAW,kBAAkB,iBAAiB;AAC7C,4BAAoB,eAClB,YAAY,SAAS,cAAc,EACnC,KAAK,OAAO,aAAa;AAEzB,iBAAO,MAAM,KAAK,QAAQ;AAAA,YACzB,SAAS;AAAA,YACT,eAAe,YAAY,OAAO;AAAA,UACnC;AAAA,QACD,CAAC;AAEF,2BAAmB,KAAK,iBAAiB;AAAA,MAC1C;AAEA,aAAO,MAAM,QAAQ,IAAI,kBAAkB;AAAA,IAC5C;AAGA,UAAM,eAAe,OACpB,gBACA,mBACmC;AACnC,YAAM,SAAS,KAAK,iBAAiB,UAAU,CAAC;AAEhD,UAAI,eAAe,CAAC;AAEpB,UAAI,WAAW,YAAY,WAAW,OAAO;AAC5C,uBAAe;AAAA,UACd,QAAQ,CAAC,QAAQ,QAAQ;AAAA,UACzB,UAAU;AAAA,UACV,QAAQ;AAAA,QACT;AAAA,MACD,WAAW,WAAW,YAAY;AACjC,uBAAe;AAAA,UACd,QAAQ,CAAC,EAAE;AAAA,UACX,UAAU;AAAA,UACV,QAAQ;AAAA,QACT;AAAA,MACD;AAEA,YAAM,UAAU,MAAM,eAAe,OAAO,gBAAgB,YAAY;AAExE,YAAM,YAAkC,CAAC;AACzC,UAAI;AACJ,UAAI;AACJ,UAAI;AAIJ,YAAM,qBAAqB,CAAC,MAAM,QAAQ,QAAQ,WAAW,IAAI;AAEjE,UAAI,WAAW,YAAY;AAC1B,cAAM,oCAAoC,KAAK;AAAA,UAC9C;AAAA,QACD;AAEA,mBAAW,WAAW,SAAS;AAC9B,cACC,WAAW,mBAAmB,UAC9B,QAAQ,WAAW,OAAQ,WAAW,gBACrC;AACD;AAAA,UACD;AACA,cACC,WAAW,mBAAmB,UAC7B,WAAW,iBAA4B,QAAQ,WAAW,KAC1D;AACD,uBAAW,iBAAiB,QAAQ,WAAW;AAAA,UAChD;AACA,gBAAM,WAAO,YAAAC,SAAK,QAAQ,OAAO,EAAE,OAAO,GAAG,CAAC;AAE9C,cAAI,SAAS,QAAW;AACvB,kBAAM,IAAI,uCAAmB,KAAK,QAAQ,GAAG,iCAAiC;AAAA,UAC/E;AACA,gBAAM,cAAc,MAAM,cAAc;AAAA,YACvC;AAAA,YACA,KAAK;AAAA,YACL;AAAA,UACD;AAEA,oBAAU,KAAK,WAAW;AAAA,QAC3B;AAAA,MACD,WAAW,WAAW,UAAU;AAC/B,cAAM,sBAAsB,KAAK,iBAAiB,qBAAqB;AAEvE,YAAI,oCAAoC;AACxC,YAAI,qBAAqB;AACxB,8CAAoC,KAAK;AAAA,YACxC;AAAA,UACD;AAAA,QACD;AAEA,mBAAW,WAAW,SAAS;AAC9B,cACC,WAAW,mBAAmB,UAC9B,QAAQ,WAAW,OAAQ,WAAW,gBACrC;AACD;AAAA,UACD;AACA,cACC,WAAW,mBAAmB,UAC7B,WAAW,iBAA4B,QAAQ,WAAW,KAC1D;AACD,uBAAW,iBAAiB,QAAQ,WAAW;AAAA,UAChD;AACA,gBAAM,YAAQ,sBAAS,QAAQ,WAAW,MAAO;AAEjD,qBAAW;AAAA,YACV,MAAM;AAAA,cACL,UAAU,MAAM,QAAQ,OAAO,SAAS,MAAM;AAAA,cAC9C,WAAW,MAAM,QAAQ,OAAO,SAAS,OAAO;AAAA,cAChD,UAAU,CAAC;AAAA,YACZ;AAAA,UACD;AAEA,gBAAM,gBAAgB,QAAQ,MAAM,OAAO,CAAC,SAAS,KAAK,UAAU,QAAQ;AAE5E,gBAAM,cAAc,cAAc,CAAC,EAAE;AACrC,eAAK,gBAAgB,OAAO,KAAK,WAA0B,GAAG;AAC7D,gBAAI,YAAY,YAAY,EAAE,QAAQ;AACrC,kBAAI,mBAAmB,SAAS,YAAY,GAAG;AAC9C,yBAAS,KAAK,YAAY,IAAI,YAAY,YAAY,EAAE,CAAC;AAAA,cAC1D,OAAO;AACN,gBAAC,SAAS,KAAK,SAAyB,YAAY,IACnD,YAAY,YAAY,EAAE,CAAC;AAAA,cAC7B;AAAA,YACD;AAAA,UACD;AAEA,cAAI,qBAAqB;AAExB,0BAAc,MAAM,cAAc,gBAAgB,OAAO,OAAO;AAChE,gBAAI,YAAY,QAAQ;AACvB,uBAAS,SAAS,CAAC;AACnB,uBAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC5C,yBAAS,OAAO,GAAG,iCAAiC,GAAG,CAAC,EAAE,IAAI,YAAY,CAAC;AAAA,cAC5E;AAAA,YACD;AAAA,UACD;AAEA,oBAAU,KAAK,QAAQ;AAAA,QACxB;AAAA,MACD,WAAW,WAAW,OAAO;AAC5B,mBAAW,WAAW,SAAS;AAC9B,cACC,WAAW,mBAAmB,UAC9B,QAAQ,WAAW,OAAQ,WAAW,gBACrC;AACD;AAAA,UACD;AACA,cACC,WAAW,mBAAmB,UAC7B,WAAW,iBAA4B,QAAQ,WAAW,KAC1D;AACD,uBAAW,iBAAiB,QAAQ,WAAW;AAAA,UAChD;AACA,gBAAM,WAAO,YAAAA,SAAK,QAAQ,OAAO,EAAE,OAAO,OAAO,CAAC;AAElD,cAAI,SAAS,QAAW;AACvB,kBAAM,IAAI,uCAAmB,KAAK,QAAQ,GAAG,iCAAiC;AAAA,UAC/E;AAEA,qBAAW;AAAA,YACV,MAAM;AAAA,cACL,KAAK,KAAK;AAAA,YACX;AAAA,UACD;AAEA,oBAAU,KAAK,QAAQ;AAAA,QACxB;AAAA,MACD;AAGA,UAAI,sBAAsB,QAAQ;AACjC,cAAM,UAAU,QAAQ,IAAI,CAAC,MAAM,EAAE,WAAW,GAAG;AACnD,YAAI,QAAQ,SAAS,GAAG;AACvB,gBAAM,eAAe,SAAS,SAAS,QAAQ;AAAA,QAChD;AAAA,MACD;AACA,aAAO;AAAA,IACR;AAEA,UAAM,kBAAkB,KAAK,QAAQ,sBAAsB;AAE3D,UAAM,sBAAsB,YAAiC;AAC5D,UAAI,iBAAiB,CAAC,QAAQ;AAC9B,UAAI,QAAQ,sBAAsB,QAAW;AAC5C,YAAI;AACH,2BAAiB,KAAK,MAAM,QAAQ,iBAA2B;AAAA,QAChE,SAAS,OAAO;AACf,gBAAM,IAAI,uCAAmB,KAAK,QAAQ,GAAG,wCAAwC;AAAA,QACtF;AAAA,MACD;AAEA,YAAM,SAA4B;AAAA,QACjC,MAAM;AAAA,UACL,MAAM,YAAY;AAAA,UAClB,UAAU,YAAY;AAAA,UACtB,MAAO,YAAY,KAAgB,KAAK;AAAA,UACxC,MAAM,YAAY;AAAA,UAClB,KAAK,YAAY;AAAA,UACjB,aAAa;AAAA,QACd;AAAA,QACA,QAAQ,YAAY;AACnB,cAAI,YAAY;AACf,gBAAI,WAAW,mBAAmB,QAAW;AAC5C,6BAAe,KAAK,CAAC,OAAO,GAAG,WAAW,cAAwB,IAAI,CAAC;AAavE,mBAAK,OAAO,MAAM,qDAAqD;AAAA,gBACtE;AAAA,cACD,CAAC;AAAA,YACF;AAEA,gBAAI;AACH,oBAAM,aAAa,MAAM,aAAa,YAAY,cAAc;AAChE,kBAAI,WAAW,QAAQ;AACtB,qBAAK,KAAK,CAAC,UAAU,CAAC;AAAA,cACvB;AAAA,YACD,SAAS,OAAO;AACf,mBAAK,OAAO,MAAM,iEAAiE;AAAA,gBAClF;AAAA,cACD,CAAC;AAGD,oBAAM,gBAAgB,QAAQ,KAAK,MAAM;AACxC,qBAAK,UAAU,KAAc;AAAA,cAC9B,CAAC;AAAA,YACF;AAAA,UACD;AAAA,QACD;AAAA,MACD;AAEA,YAAM,aAA0B,CAAC;AAEjC,UAAI,QAAQ,2BAA2B,MAAM;AAC5C,mBAAW,qBAAqB;AAAA,MACjC;AAEA,UAAI,YAAY,QAAQ;AACvB,mBAAW,aAAc,YAAY,KAAgB,KAAK;AAAA,MAC3D;AAEA,UAAI,KAAC,eAAAH,SAAQ,UAAU,GAAG;AACzB,eAAO,KAAK,aAAa;AAAA,MAC1B;AAIA,aAAO,UAAM,YAAAC,SAAY,MAAM,EAAE,KAAK,OAAO,SAAS;AACrD,aAAK,GAAG,SAAS,OAAO,UAAU;AACjC,gBAAM,YAAY,MAAM,KAAK,YAAY;AACzC,cAAI,CAAC,cAAc,OAAO,EAAE,SAAS,SAAmB,GAAG;AAC1D,iBAAK,OAAO,MAAM,8BAA8B,SAAS,qBAAqB;AAAA,cAC7E;AAAA,YACD,CAAC;AACD,gBAAI;AACH,2BAAa,MAAM,oBAAoB;AACvC,oBAAM,WAAW,QAAQ,OAAO;AAChC;AAAA,YACD,SAAS,GAAG;AACX,mBAAK,OAAO,MAAM,2BAA2B,EAAE,OAAO,EAAE,CAAC;AAAA,YAE1D;AAAA,UACD,OAAO;AACN,iBAAK,OAAO,MAAM,uDAAuD,EAAE,MAAM,CAAC;AAClF,iBAAK,UAAU,KAAc;AAAA,UAC9B;AAAA,QACD,CAAC;AACD,eAAO;AAAA,MACR,CAAC;AAAA,IACF;AAEA,iBAAa,MAAM,oBAAoB;AAEvC,UAAM,WAAW,QAAQ,OAAO;AAEhC,QAAI;AAEJ,QAAI,QAAQ,mBAAmB,QAAW;AACzC,6BAAuB;AAAA,QACtB,YAAY;AACX,eAAK,OAAO,MAAM,oCAAoC;AACtD,qBAAW,IAAI;AACf,uBAAa,MAAM,oBAAoB;AACvC,gBAAM,WAAW,QAAQ,OAAO;AAAA,QACjC;AAAA,QACC,QAAQ,iBAA4B,MAAO;AAAA,MAC7C;AAAA,IACD;AAGA,mBAAe,gBAAgB;AAC9B,UAAI,sBAAsB;AACzB,sBAAc,oBAAoB;AAAA,MACnC;AACA,iBAAW,IAAI;AAAA,IAChB;AAGA,oBAAgB,QAAQ;AAExB,WAAO;AAAA,MACN;AAAA,IACD;AAAA,EACD;AACD;","names":["isEmpty","imapConnect","part","find"]}
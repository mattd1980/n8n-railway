{"version":3,"sources":["../../../nodes/TheHive/GenericFunctions.ts"],"sourcesContent":["import moment from 'moment-timezone';\nimport type {\n\tIExecuteFunctions,\n\tIHookFunctions,\n\tILoadOptionsFunctions,\n\tIDataObject,\n\tIHttpRequestMethods,\n\tIRequestOptions,\n} from 'n8n-workflow';\nimport { ApplicationError, jsonParse } from 'n8n-workflow';\n\nimport { Eq } from './QueryFunctions';\n\nexport async function theHiveApiRequest(\n\tthis: IHookFunctions | IExecuteFunctions | ILoadOptionsFunctions,\n\tmethod: IHttpRequestMethods,\n\tresource: string,\n\tbody: IDataObject = {},\n\tquery: IDataObject = {},\n\turi?: string,\n\toption: IDataObject = {},\n) {\n\tconst credentials = await this.getCredentials('theHiveApi');\n\n\tlet options: IRequestOptions = {\n\t\tmethod,\n\t\tqs: query,\n\t\turi: uri || `${credentials.url}/api${resource}`,\n\t\tbody,\n\t\trejectUnauthorized: !credentials.allowUnauthorizedCerts,\n\t\tjson: true,\n\t};\n\n\tif (Object.keys(option).length !== 0) {\n\t\toptions = Object.assign({}, options, option);\n\t}\n\n\tif (Object.keys(body).length === 0) {\n\t\tdelete options.body;\n\t}\n\n\tif (Object.keys(query).length === 0) {\n\t\tdelete options.qs;\n\t}\n\treturn await this.helpers.requestWithAuthentication.call(this, 'theHiveApi', options);\n}\n\n// Helpers functions\nexport function mapResource(resource: string): string {\n\tswitch (resource) {\n\t\tcase 'alert':\n\t\t\treturn 'alert';\n\t\tcase 'case':\n\t\t\treturn 'case';\n\t\tcase 'observable':\n\t\t\treturn 'case_artifact';\n\t\tcase 'task':\n\t\t\treturn 'case_task';\n\t\tcase 'log':\n\t\t\treturn 'case_task_log';\n\t\tdefault:\n\t\t\treturn '';\n\t}\n}\n\nexport function splitTags(tags: string): string[] {\n\treturn tags.split(',').filter((tag) => tag !== ' ' && tag);\n}\n\nexport function prepareOptional(optionals: IDataObject): IDataObject {\n\tconst response: IDataObject = {};\n\tfor (const key in optionals) {\n\t\tif (optionals[key] !== undefined && optionals[key] !== null && optionals[key] !== '') {\n\t\t\tif (['customFieldsJson', 'customFieldsUi'].indexOf(key) > -1) {\n\t\t\t\tcontinue; // Ignore customFields, they need special treatment\n\t\t\t} else if (moment(optionals[key] as string, moment.ISO_8601).isValid()) {\n\t\t\t\tresponse[key] = Date.parse(optionals[key] as string);\n\t\t\t} else if (key === 'artifacts') {\n\t\t\t\ttry {\n\t\t\t\t\tresponse[key] = jsonParse(optionals[key] as string);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow new ApplicationError('Invalid JSON for artifacts', { level: 'warning' });\n\t\t\t\t}\n\t\t\t} else if (key === 'tags') {\n\t\t\t\tresponse[key] = splitTags(optionals[key] as string);\n\t\t\t} else {\n\t\t\t\tresponse[key] = optionals[key];\n\t\t\t}\n\t\t}\n\t}\n\treturn response;\n}\n\nexport async function prepareCustomFields(\n\tthis: IHookFunctions | IExecuteFunctions | ILoadOptionsFunctions,\n\tadditionalFields: IDataObject,\n\tjsonParameters = false,\n): Promise<IDataObject | undefined> {\n\t// Check if the additionalFields object contains customFields\n\tif (jsonParameters) {\n\t\tlet customFieldsJson = additionalFields.customFieldsJson;\n\t\t// Delete from additionalFields as some operations (e.g. alert:update) do not run prepareOptional\n\t\t// which would remove the extra fields\n\t\tdelete additionalFields.customFieldsJson;\n\n\t\tif (typeof customFieldsJson === 'string') {\n\t\t\ttry {\n\t\t\t\tcustomFieldsJson = jsonParse(customFieldsJson);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new ApplicationError('Invalid JSON for customFields', { level: 'warning' });\n\t\t\t}\n\t\t}\n\n\t\tif (typeof customFieldsJson === 'object') {\n\t\t\tconst customFields = Object.keys(customFieldsJson as IDataObject).reduce((acc, curr) => {\n\t\t\t\tacc[`customFields.${curr}`] = (customFieldsJson as IDataObject)[curr];\n\t\t\t\treturn acc;\n\t\t\t}, {} as IDataObject);\n\n\t\t\treturn customFields;\n\t\t} else if (customFieldsJson) {\n\t\t\tthrow new ApplicationError('customFieldsJson value is invalid', { level: 'warning' });\n\t\t}\n\t} else if (additionalFields.customFieldsUi) {\n\t\t// Get Custom Field Types from TheHive\n\t\tconst credentials = await this.getCredentials('theHiveApi');\n\t\tconst version = credentials.apiVersion;\n\t\tconst endpoint = version === 'v1' ? '/customField' : '/list/custom_fields';\n\n\t\tconst requestResult = await theHiveApiRequest.call(this, 'GET', endpoint as string);\n\n\t\t// Convert TheHive3 response to the same format as TheHive 4\n\t\t// [{name, reference, type}]\n\t\tconst hiveCustomFields =\n\t\t\tversion === 'v1'\n\t\t\t\t? requestResult\n\t\t\t\t: Object.keys(requestResult as IDataObject).map((key) => requestResult[key]);\n\t\t// Build reference to type mapping object\n\t\tconst referenceTypeMapping = hiveCustomFields.reduce(\n\t\t\t(acc: IDataObject, curr: IDataObject) => ((acc[curr.reference as string] = curr.type), acc),\n\t\t\t{},\n\t\t);\n\n\t\t// Build \"fieldName\": {\"type\": \"value\"} objects\n\t\tconst customFieldsUi = additionalFields.customFieldsUi as IDataObject;\n\t\tconst customFields: IDataObject = (customFieldsUi?.customFields as IDataObject[]).reduce(\n\t\t\t(acc: IDataObject, curr: IDataObject) => {\n\t\t\t\tconst fieldName = curr.field as string;\n\n\t\t\t\t// Might be able to do some type conversions here if needed, TODO\n\n\t\t\t\tconst updatedField = `customFields.${fieldName}.${[referenceTypeMapping[fieldName]]}`;\n\t\t\t\tacc[updatedField] = curr.value;\n\t\t\t\treturn acc;\n\t\t\t},\n\t\t\t{} as IDataObject,\n\t\t);\n\n\t\tdelete additionalFields.customFieldsUi;\n\t\treturn customFields;\n\t}\n\treturn undefined;\n}\n\nexport function buildCustomFieldSearch(customFields: IDataObject): IDataObject[] {\n\tconst searchQueries: IDataObject[] = [];\n\n\tObject.keys(customFields).forEach((customFieldName) => {\n\t\tsearchQueries.push(Eq(customFieldName, customFields[customFieldName]));\n\t});\n\treturn searchQueries;\n}\n\nexport function prepareSortQuery(sort: string, body: { query: [IDataObject] }) {\n\tif (sort) {\n\t\tconst field = sort.substring(1);\n\t\tconst value = sort.charAt(0) === '+' ? 'asc' : 'desc';\n\t\tconst sortOption: IDataObject = {};\n\t\tsortOption[field] = value;\n\t\tbody.query.push({\n\t\t\t_name: 'sort',\n\t\t\t_fields: [sortOption],\n\t\t});\n\t}\n}\n\nexport function prepareRangeQuery(range: string, body: { query: IDataObject[] }) {\n\tif (range && range !== 'all') {\n\t\tbody.query.push({\n\t\t\t_name: 'page',\n\t\t\tfrom: parseInt(range.split('-')[0], 10),\n\t\t\tto: parseInt(range.split('-')[1], 10),\n\t\t});\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BAAmB;AASnB,0BAA4C;AAE5C,4BAAmB;AAEnB,eAAsB,kBAErB,QACA,UACA,OAAoB,CAAC,GACrB,QAAqB,CAAC,GACtB,KACA,SAAsB,CAAC,GACtB;AACD,QAAM,cAAc,MAAM,KAAK,eAAe,YAAY;AAE1D,MAAI,UAA2B;AAAA,IAC9B;AAAA,IACA,IAAI;AAAA,IACJ,KAAK,OAAO,GAAG,YAAY,GAAG,OAAO,QAAQ;AAAA,IAC7C;AAAA,IACA,oBAAoB,CAAC,YAAY;AAAA,IACjC,MAAM;AAAA,EACP;AAEA,MAAI,OAAO,KAAK,MAAM,EAAE,WAAW,GAAG;AACrC,cAAU,OAAO,OAAO,CAAC,GAAG,SAAS,MAAM;AAAA,EAC5C;AAEA,MAAI,OAAO,KAAK,IAAI,EAAE,WAAW,GAAG;AACnC,WAAO,QAAQ;AAAA,EAChB;AAEA,MAAI,OAAO,KAAK,KAAK,EAAE,WAAW,GAAG;AACpC,WAAO,QAAQ;AAAA,EAChB;AACA,SAAO,MAAM,KAAK,QAAQ,0BAA0B,KAAK,MAAM,cAAc,OAAO;AACrF;AAGO,SAAS,YAAY,UAA0B;AACrD,UAAQ,UAAU;AAAA,IACjB,KAAK;AACJ,aAAO;AAAA,IACR,KAAK;AACJ,aAAO;AAAA,IACR,KAAK;AACJ,aAAO;AAAA,IACR,KAAK;AACJ,aAAO;AAAA,IACR,KAAK;AACJ,aAAO;AAAA,IACR;AACC,aAAO;AAAA,EACT;AACD;AAEO,SAAS,UAAU,MAAwB;AACjD,SAAO,KAAK,MAAM,GAAG,EAAE,OAAO,CAAC,QAAQ,QAAQ,OAAO,GAAG;AAC1D;AAEO,SAAS,gBAAgB,WAAqC;AACpE,QAAM,WAAwB,CAAC;AAC/B,aAAW,OAAO,WAAW;AAC5B,QAAI,UAAU,GAAG,MAAM,UAAa,UAAU,GAAG,MAAM,QAAQ,UAAU,GAAG,MAAM,IAAI;AACrF,UAAI,CAAC,oBAAoB,gBAAgB,EAAE,QAAQ,GAAG,IAAI,IAAI;AAC7D;AAAA,MACD,eAAW,uBAAAA,SAAO,UAAU,GAAG,GAAa,uBAAAA,QAAO,QAAQ,EAAE,QAAQ,GAAG;AACvE,iBAAS,GAAG,IAAI,KAAK,MAAM,UAAU,GAAG,CAAW;AAAA,MACpD,WAAW,QAAQ,aAAa;AAC/B,YAAI;AACH,mBAAS,GAAG,QAAI,+BAAU,UAAU,GAAG,CAAW;AAAA,QACnD,SAAS,OAAO;AACf,gBAAM,IAAI,qCAAiB,8BAA8B,EAAE,OAAO,UAAU,CAAC;AAAA,QAC9E;AAAA,MACD,WAAW,QAAQ,QAAQ;AAC1B,iBAAS,GAAG,IAAI,UAAU,UAAU,GAAG,CAAW;AAAA,MACnD,OAAO;AACN,iBAAS,GAAG,IAAI,UAAU,GAAG;AAAA,MAC9B;AAAA,IACD;AAAA,EACD;AACA,SAAO;AACR;AAEA,eAAsB,oBAErB,kBACA,iBAAiB,OACkB;AAEnC,MAAI,gBAAgB;AACnB,QAAI,mBAAmB,iBAAiB;AAGxC,WAAO,iBAAiB;AAExB,QAAI,OAAO,qBAAqB,UAAU;AACzC,UAAI;AACH,+BAAmB,+BAAU,gBAAgB;AAAA,MAC9C,SAAS,OAAO;AACf,cAAM,IAAI,qCAAiB,iCAAiC,EAAE,OAAO,UAAU,CAAC;AAAA,MACjF;AAAA,IACD;AAEA,QAAI,OAAO,qBAAqB,UAAU;AACzC,YAAM,eAAe,OAAO,KAAK,gBAA+B,EAAE,OAAO,CAAC,KAAK,SAAS;AACvF,YAAI,gBAAgB,IAAI,EAAE,IAAK,iBAAiC,IAAI;AACpE,eAAO;AAAA,MACR,GAAG,CAAC,CAAgB;AAEpB,aAAO;AAAA,IACR,WAAW,kBAAkB;AAC5B,YAAM,IAAI,qCAAiB,qCAAqC,EAAE,OAAO,UAAU,CAAC;AAAA,IACrF;AAAA,EACD,WAAW,iBAAiB,gBAAgB;AAE3C,UAAM,cAAc,MAAM,KAAK,eAAe,YAAY;AAC1D,UAAM,UAAU,YAAY;AAC5B,UAAM,WAAW,YAAY,OAAO,iBAAiB;AAErD,UAAM,gBAAgB,MAAM,kBAAkB,KAAK,MAAM,OAAO,QAAkB;AAIlF,UAAM,mBACL,YAAY,OACT,gBACA,OAAO,KAAK,aAA4B,EAAE,IAAI,CAAC,QAAQ,cAAc,GAAG,CAAC;AAE7E,UAAM,uBAAuB,iBAAiB;AAAA,MAC7C,CAAC,KAAkB,UAAwB,IAAI,KAAK,SAAmB,IAAI,KAAK,MAAO;AAAA,MACvF,CAAC;AAAA,IACF;AAGA,UAAM,iBAAiB,iBAAiB;AACxC,UAAM,gBAA6B,gBAAgB,cAA+B;AAAA,MACjF,CAAC,KAAkB,SAAsB;AACxC,cAAM,YAAY,KAAK;AAIvB,cAAM,eAAe,gBAAgB,SAAS,IAAI,CAAC,qBAAqB,SAAS,CAAC,CAAC;AACnF,YAAI,YAAY,IAAI,KAAK;AACzB,eAAO;AAAA,MACR;AAAA,MACA,CAAC;AAAA,IACF;AAEA,WAAO,iBAAiB;AACxB,WAAO;AAAA,EACR;AACA,SAAO;AACR;AAEO,SAAS,uBAAuB,cAA0C;AAChF,QAAM,gBAA+B,CAAC;AAEtC,SAAO,KAAK,YAAY,EAAE,QAAQ,CAAC,oBAAoB;AACtD,kBAAc,SAAK,0BAAG,iBAAiB,aAAa,eAAe,CAAC,CAAC;AAAA,EACtE,CAAC;AACD,SAAO;AACR;AAEO,SAAS,iBAAiB,MAAc,MAAgC;AAC9E,MAAI,MAAM;AACT,UAAM,QAAQ,KAAK,UAAU,CAAC;AAC9B,UAAM,QAAQ,KAAK,OAAO,CAAC,MAAM,MAAM,QAAQ;AAC/C,UAAM,aAA0B,CAAC;AACjC,eAAW,KAAK,IAAI;AACpB,SAAK,MAAM,KAAK;AAAA,MACf,OAAO;AAAA,MACP,SAAS,CAAC,UAAU;AAAA,IACrB,CAAC;AAAA,EACF;AACD;AAEO,SAAS,kBAAkB,OAAe,MAAgC;AAChF,MAAI,SAAS,UAAU,OAAO;AAC7B,SAAK,MAAM,KAAK;AAAA,MACf,OAAO;AAAA,MACP,MAAM,SAAS,MAAM,MAAM,GAAG,EAAE,CAAC,GAAG,EAAE;AAAA,MACtC,IAAI,SAAS,MAAM,MAAM,GAAG,EAAE,CAAC,GAAG,EAAE;AAAA,IACrC,CAAC;AAAA,EACF;AACD;","names":["moment"]}
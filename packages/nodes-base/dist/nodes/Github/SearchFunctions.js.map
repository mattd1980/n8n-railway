{"version":3,"sources":["../../../nodes/Github/SearchFunctions.ts"],"sourcesContent":["import type {\n\tILoadOptionsFunctions,\n\tINodeListSearchItems,\n\tINodeListSearchResult,\n} from 'n8n-workflow';\n\nimport { githubApiRequest } from './GenericFunctions';\n\ntype UserSearchItem = {\n\tlogin: string;\n\thtml_url: string;\n};\n\ntype RepositorySearchItem = {\n\tname: string;\n\thtml_url: string;\n};\n\ntype UserSearchResponse = {\n\titems: UserSearchItem[];\n\ttotal_count: number;\n};\n\ntype RepositorySearchResponse = {\n\titems: RepositorySearchItem[];\n\ttotal_count: number;\n};\n\ntype RefItem = {\n\tref: string;\n};\n\nexport async function getUsers(\n\tthis: ILoadOptionsFunctions,\n\tfilter?: string,\n\tpaginationToken?: string,\n): Promise<INodeListSearchResult> {\n\tconst page = paginationToken ? +paginationToken : 1;\n\tconst per_page = 100;\n\tconst responseData: UserSearchResponse = await githubApiRequest.call(\n\t\tthis,\n\t\t'GET',\n\t\t'/search/users',\n\t\t{},\n\t\t{ q: filter, page, per_page },\n\t);\n\n\tconst results: INodeListSearchItems[] = responseData.items.map((item: UserSearchItem) => ({\n\t\tname: item.login,\n\t\tvalue: item.login,\n\t\turl: item.html_url,\n\t}));\n\n\tconst nextPaginationToken = page * per_page < responseData.total_count ? page + 1 : undefined;\n\treturn { results, paginationToken: nextPaginationToken };\n}\n\nexport async function getRepositories(\n\tthis: ILoadOptionsFunctions,\n\tfilter?: string,\n\tpaginationToken?: string,\n): Promise<INodeListSearchResult> {\n\tconst owner = this.getCurrentNodeParameter('owner', { extractValue: true });\n\tconst page = paginationToken ? +paginationToken : 1;\n\tconst per_page = 100;\n\tconst q = `${filter ?? ''} user:${owner} fork:true`;\n\tlet responseData: RepositorySearchResponse = {\n\t\titems: [],\n\t\ttotal_count: 0,\n\t};\n\n\ttry {\n\t\tresponseData = await githubApiRequest.call(\n\t\t\tthis,\n\t\t\t'GET',\n\t\t\t'/search/repositories',\n\t\t\t{},\n\t\t\t{ q, page, per_page },\n\t\t);\n\t} catch {\n\t\t// will fail if the owner does not have any repositories\n\t}\n\n\tconst results: INodeListSearchItems[] = responseData.items.map((item: RepositorySearchItem) => ({\n\t\tname: item.name,\n\t\tvalue: item.name,\n\t\turl: item.html_url,\n\t}));\n\n\tconst nextPaginationToken = page * per_page < responseData.total_count ? page + 1 : undefined;\n\treturn { results, paginationToken: nextPaginationToken };\n}\n\nexport async function getWorkflows(\n\tthis: ILoadOptionsFunctions,\n\tpaginationToken?: string,\n): Promise<INodeListSearchResult> {\n\tconst owner = this.getCurrentNodeParameter('owner', { extractValue: true });\n\tconst repository = this.getCurrentNodeParameter('repository', { extractValue: true });\n\tconst page = paginationToken ? +paginationToken : 1;\n\tconst per_page = 100;\n\tconst endpoint = `/repos/${owner}/${repository}/actions/workflows`;\n\tlet responseData: { workflows: Array<{ id: string; name: string }>; total_count: number } = {\n\t\tworkflows: [],\n\t\ttotal_count: 0,\n\t};\n\n\ttry {\n\t\tresponseData = await githubApiRequest.call(this, 'GET', endpoint, {}, { page, per_page });\n\t} catch {\n\t\t// will fail if the repository does not have any workflows\n\t}\n\n\tconst results: INodeListSearchItems[] = responseData.workflows.map((workflow) => ({\n\t\tname: workflow.name,\n\t\tvalue: workflow.id,\n\t}));\n\n\tconst nextPaginationToken = page * per_page < responseData.total_count ? page + 1 : undefined;\n\treturn { results, paginationToken: nextPaginationToken };\n}\n\nexport async function getRefs(\n\tthis: ILoadOptionsFunctions,\n\tfilter?: string,\n\tpaginationToken?: string,\n): Promise<INodeListSearchResult> {\n\tconst owner = this.getCurrentNodeParameter('owner', { extractValue: true });\n\tconst repository = this.getCurrentNodeParameter('repository', { extractValue: true });\n\tconst page = paginationToken ? +paginationToken : 1;\n\tconst per_page = 100;\n\n\tconst responseData: RefItem[] = await githubApiRequest.call(\n\t\tthis,\n\t\t'GET',\n\t\t`/repos/${owner}/${repository}/git/refs`,\n\t\t{},\n\t\t{ page, per_page },\n\t);\n\n\tconst refs: INodeListSearchItems[] = [];\n\n\tfor (const ref of responseData) {\n\t\tconst refPath = ref.ref.split('/');\n\t\tconst refType = refPath[1];\n\t\tconst refName = refPath.slice(2).join('/');\n\n\t\tlet description = '';\n\t\tif (refType === 'heads') {\n\t\t\tdescription = `Branch: ${refName}`;\n\t\t} else if (refType === 'tags') {\n\t\t\tdescription = `Tag: ${refName}`;\n\t\t} else {\n\t\t\tdescription = `${refType}: ${refName}`;\n\t\t}\n\n\t\trefs.push({\n\t\t\tname: refName,\n\t\t\tvalue: refName,\n\t\t\tdescription,\n\t\t});\n\t}\n\n\tif (filter) {\n\t\tconst filteredRefs = refs.filter((ref) =>\n\t\t\tref.name.toLowerCase().includes(filter.toLowerCase()),\n\t\t);\n\t\treturn { results: filteredRefs };\n\t}\n\tconst nextPaginationToken = responseData.length === per_page ? page + 1 : undefined;\n\treturn { results: refs, paginationToken: nextPaginationToken };\n}\n"],"mappings":"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","names":[]}
{"version":3,"sources":["../../../../nodes/Merge/v1/MergeV1.node.ts"],"sourcesContent":["import get from 'lodash/get';\nimport type {\n\tIExecuteFunctions,\n\tGenericValue,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeBaseDescription,\n\tINodeTypeDescription,\n\tIPairedItemData,\n} from 'n8n-workflow';\nimport { NodeConnectionTypes, deepCopy } from 'n8n-workflow';\n\nimport { oldVersionNotice } from '@utils/descriptions';\n\nimport { generatePairedItemData } from '../../../utils/utilities';\n\nexport class MergeV1 implements INodeType {\n\tdescription: INodeTypeDescription;\n\n\tconstructor(baseDescription: INodeTypeBaseDescription) {\n\t\tthis.description = {\n\t\t\t...baseDescription,\n\t\t\ticon: 'fa:code-branch',\n\t\t\tversion: 1,\n\t\t\tdefaults: {\n\t\t\t\tname: 'Merge',\n\t\t\t\tcolor: '#00bbcc',\n\t\t\t},\n\n\t\t\tinputs: [NodeConnectionTypes.Main, NodeConnectionTypes.Main],\n\t\t\toutputs: [NodeConnectionTypes.Main],\n\t\t\tinputNames: ['Input 1', 'Input 2'],\n\t\t\tproperties: [\n\t\t\t\toldVersionNotice,\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Mode',\n\t\t\t\t\tname: 'mode',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\toptions: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Append',\n\t\t\t\t\t\t\tvalue: 'append',\n\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t'Combines data of both inputs. The output will contain items of input 1 and input 2.',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Keep Key Matches',\n\t\t\t\t\t\t\tvalue: 'keepKeyMatches',\n\t\t\t\t\t\t\tdescription: 'Keeps data of input 1 if it does find a match with data of input 2',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Merge By Index',\n\t\t\t\t\t\t\tvalue: 'mergeByIndex',\n\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t'Merges data of both inputs. The output will contain items of input 1 merged with data of input 2. Merge happens depending on the index of the items. So first item of input 1 will be merged with first item of input 2 and so on.',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Merge By Key',\n\t\t\t\t\t\t\tvalue: 'mergeByKey',\n\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t'Merges data of both inputs. The output will contain items of input 1 merged with data of input 2. Merge happens depending on a defined key.',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Multiplex',\n\t\t\t\t\t\t\tvalue: 'multiplex',\n\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t'Merges each value of one input with each value of the other input. The output will contain (m * n) items where (m) and (n) are lengths of the inputs.',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Pass-Through',\n\t\t\t\t\t\t\tvalue: 'passThrough',\n\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t'Passes through data of one input. The output will contain only items of the defined input.',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Remove Key Matches',\n\t\t\t\t\t\t\tvalue: 'removeKeyMatches',\n\t\t\t\t\t\t\tdescription: 'Keeps data of input 1 if it does NOT find match with data of input 2',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Wait',\n\t\t\t\t\t\t\tvalue: 'wait',\n\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t'Waits till data of both inputs is available and will then output a single empty item. Source Nodes must connect to both Input 1 and 2. This node only supports 2 Sources, if you need more Sources, connect multiple Merge nodes in series. This node will not output any data.',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tdefault: 'append',\n\t\t\t\t\tdescription: 'How data of branches should be merged',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Join',\n\t\t\t\t\tname: 'join',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\tdisplayOptions: {\n\t\t\t\t\t\tshow: {\n\t\t\t\t\t\t\tmode: ['mergeByIndex'],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\toptions: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Inner Join',\n\t\t\t\t\t\t\tvalue: 'inner',\n\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t'Merges as many items as both inputs contain. (Example: Input1 = 5 items, Input2 = 3 items | Output will contain 3 items).',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Left Join',\n\t\t\t\t\t\t\tvalue: 'left',\n\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t'Merges as many items as first input contains. (Example: Input1 = 3 items, Input2 = 5 items | Output will contain 3 items).',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Outer Join',\n\t\t\t\t\t\t\tvalue: 'outer',\n\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t'Merges as many items as input contains with most items. (Example: Input1 = 3 items, Input2 = 5 items | Output will contain 5 items).',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tdefault: 'left',\n\t\t\t\t\tdescription:\n\t\t\t\t\t\t'How many items the output will contain if inputs contain different amount of items',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Property Input 1',\n\t\t\t\t\tname: 'propertyName1',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdefault: '',\n\t\t\t\t\thint: 'The name of the field as text (e.g. “id”)',\n\t\t\t\t\trequired: true,\n\t\t\t\t\tdisplayOptions: {\n\t\t\t\t\t\tshow: {\n\t\t\t\t\t\t\tmode: ['keepKeyMatches', 'mergeByKey', 'removeKeyMatches'],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tdescription: 'Name of property which decides which items to merge of input 1',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Property Input 2',\n\t\t\t\t\tname: 'propertyName2',\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tdefault: '',\n\t\t\t\t\thint: 'The name of the field as text (e.g. “id”)',\n\t\t\t\t\trequired: true,\n\t\t\t\t\tdisplayOptions: {\n\t\t\t\t\t\tshow: {\n\t\t\t\t\t\t\tmode: ['keepKeyMatches', 'mergeByKey', 'removeKeyMatches'],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tdescription: 'Name of property which decides which items to merge of input 2',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Output Data',\n\t\t\t\t\tname: 'output',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\tdisplayOptions: {\n\t\t\t\t\t\tshow: {\n\t\t\t\t\t\t\tmode: ['passThrough'],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\toptions: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Input 1',\n\t\t\t\t\t\t\tvalue: 'input1',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Input 2',\n\t\t\t\t\t\t\tvalue: 'input2',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tdefault: 'input1',\n\t\t\t\t\tdescription: 'Defines of which input the data should be used as output of node',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdisplayName: 'Overwrite',\n\t\t\t\t\tname: 'overwrite',\n\t\t\t\t\ttype: 'options',\n\t\t\t\t\tdisplayOptions: {\n\t\t\t\t\t\tshow: {\n\t\t\t\t\t\t\tmode: ['mergeByKey'],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\toptions: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'Always',\n\t\t\t\t\t\t\tvalue: 'always',\n\t\t\t\t\t\t\tdescription: 'Always overwrites everything',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'If Blank',\n\t\t\t\t\t\t\tvalue: 'blank',\n\t\t\t\t\t\t\tdescription: 'Overwrites only values of \"null\", \"undefined\" or empty string',\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'If Missing',\n\t\t\t\t\t\t\tvalue: 'undefined',\n\t\t\t\t\t\t\tdescription: 'Only adds values which do not exist yet',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tdefault: 'always',\n\t\t\t\t\tdescription: 'Select when to overwrite the values from Input1 with values from Input 2',\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\t}\n\n\tasync execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {\n\t\tconst returnData: INodeExecutionData[] = [];\n\n\t\tconst mode = this.getNodeParameter('mode', 0) as string;\n\n\t\tif (mode === 'append') {\n\t\t\t// Simply appends the data\n\t\t\tfor (let i = 0; i < 2; i++) {\n\t\t\t\treturnData.push.apply(returnData, this.getInputData(i));\n\t\t\t}\n\t\t} else if (mode === 'mergeByIndex') {\n\t\t\t// Merges data by index\n\n\t\t\tconst join = this.getNodeParameter('join', 0) as string;\n\n\t\t\tconst dataInput1 = this.getInputData(0);\n\t\t\tconst dataInput2 = this.getInputData(1);\n\n\t\t\tif (dataInput1 === undefined || dataInput1.length === 0) {\n\t\t\t\tif (['inner', 'left'].includes(join)) {\n\t\t\t\t\t// When \"inner\" or \"left\" join return empty if first\n\t\t\t\t\t// input does not contain any items\n\t\t\t\t\treturn [returnData];\n\t\t\t\t}\n\n\t\t\t\t// For \"outer\" return data of second input\n\t\t\t\treturn [dataInput2];\n\t\t\t}\n\n\t\t\tif (dataInput2 === undefined || dataInput2.length === 0) {\n\t\t\t\tif (['left', 'outer'].includes(join)) {\n\t\t\t\t\t// When \"left\" or \"outer\" join return data of first input\n\t\t\t\t\treturn [dataInput1];\n\t\t\t\t}\n\n\t\t\t\t// For \"inner\" return empty\n\t\t\t\treturn [returnData];\n\t\t\t}\n\n\t\t\t// Default \"left\"\n\t\t\tlet numEntries = dataInput1.length;\n\t\t\tif (join === 'inner') {\n\t\t\t\tnumEntries = Math.min(dataInput1.length, dataInput2.length);\n\t\t\t} else if (join === 'outer') {\n\t\t\t\tnumEntries = Math.max(dataInput1.length, dataInput2.length);\n\t\t\t}\n\n\t\t\tlet newItem: INodeExecutionData;\n\t\t\tfor (let i = 0; i < numEntries; i++) {\n\t\t\t\tif (i >= dataInput1.length) {\n\t\t\t\t\treturnData.push(dataInput2[i]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (i >= dataInput2.length) {\n\t\t\t\t\treturnData.push(dataInput1[i]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnewItem = {\n\t\t\t\t\tjson: {},\n\t\t\t\t\tpairedItem: [\n\t\t\t\t\t\tdataInput1[i].pairedItem as IPairedItemData,\n\t\t\t\t\t\tdataInput2[i].pairedItem as IPairedItemData,\n\t\t\t\t\t],\n\t\t\t\t};\n\n\t\t\t\tif (dataInput1[i].binary !== undefined) {\n\t\t\t\t\tnewItem.binary = {};\n\t\t\t\t\t// Create a shallow copy of the binary data so that the old\n\t\t\t\t\t// data references which do not get changed still stay behind\n\t\t\t\t\t// but the incoming data does not get changed.\n\t\t\t\t\tObject.assign(newItem.binary, dataInput1[i].binary);\n\t\t\t\t}\n\n\t\t\t\t// Create also a shallow copy of the json data\n\t\t\t\tObject.assign(newItem.json, dataInput1[i].json);\n\n\t\t\t\t// Copy json data\n\t\t\t\tfor (const key of Object.keys(dataInput2[i].json)) {\n\t\t\t\t\tnewItem.json[key] = dataInput2[i].json[key];\n\t\t\t\t}\n\n\t\t\t\t// Copy binary data\n\t\t\t\tif (dataInput2[i].binary !== undefined) {\n\t\t\t\t\tif (newItem.binary === undefined) {\n\t\t\t\t\t\tnewItem.binary = {};\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const key of Object.keys(dataInput2[i].binary!)) {\n\t\t\t\t\t\tnewItem.binary[key] = dataInput2[i].binary![key] ?? newItem.binary[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturnData.push(newItem);\n\t\t\t}\n\t\t} else if (mode === 'multiplex') {\n\t\t\tconst dataInput1 = this.getInputData(0);\n\t\t\tconst dataInput2 = this.getInputData(1);\n\n\t\t\tif (!dataInput1 || !dataInput2) {\n\t\t\t\treturn [returnData];\n\t\t\t}\n\n\t\t\tlet entry1: INodeExecutionData;\n\t\t\tlet entry2: INodeExecutionData;\n\n\t\t\tfor (entry1 of dataInput1) {\n\t\t\t\tfor (entry2 of dataInput2) {\n\t\t\t\t\treturnData.push({\n\t\t\t\t\t\tjson: {\n\t\t\t\t\t\t\t...entry1.json,\n\t\t\t\t\t\t\t...entry2.json,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tpairedItem: [\n\t\t\t\t\t\t\tentry1.pairedItem as IPairedItemData,\n\t\t\t\t\t\t\tentry2.pairedItem as IPairedItemData,\n\t\t\t\t\t\t],\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn [returnData];\n\t\t} else if (['keepKeyMatches', 'mergeByKey', 'removeKeyMatches'].includes(mode)) {\n\t\t\tconst dataInput1 = this.getInputData(0);\n\t\t\tif (!dataInput1) {\n\t\t\t\t// If it has no input data from first input return nothing\n\t\t\t\treturn [returnData];\n\t\t\t}\n\n\t\t\tconst propertyName1 = this.getNodeParameter('propertyName1', 0) as string;\n\t\t\tconst propertyName2 = this.getNodeParameter('propertyName2', 0) as string;\n\t\t\tconst overwrite = this.getNodeParameter('overwrite', 0, 'always') as string;\n\n\t\t\tconst dataInput2 = this.getInputData(1);\n\t\t\tif (!dataInput2 || !propertyName1 || !propertyName2) {\n\t\t\t\t// Second input does not have any data or the property names are not defined\n\t\t\t\tif (mode === 'keepKeyMatches') {\n\t\t\t\t\t// For \"keepKeyMatches\" return nothing\n\t\t\t\t\treturn [returnData];\n\t\t\t\t}\n\n\t\t\t\t// For \"mergeByKey\" and \"removeKeyMatches\" return the data from the first input\n\t\t\t\treturn [dataInput1];\n\t\t\t}\n\n\t\t\t// Get the data to copy\n\t\t\tconst copyData: {\n\t\t\t\t[key: string]: INodeExecutionData;\n\t\t\t} = {};\n\t\t\tlet entry: INodeExecutionData;\n\t\t\tfor (entry of dataInput2) {\n\t\t\t\tconst key = get(entry.json, propertyName2);\n\t\t\t\tif (!entry.json || !key) {\n\t\t\t\t\t// Entry does not have the property so skip it\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcopyData[key as string] = entry;\n\t\t\t}\n\n\t\t\t// Copy data on entries or add matching entries\n\t\t\tlet referenceValue: GenericValue;\n\t\t\tlet key: string;\n\t\t\tfor (entry of dataInput1) {\n\t\t\t\treferenceValue = get(entry.json, propertyName1);\n\n\t\t\t\tif (referenceValue === undefined) {\n\t\t\t\t\t// Entry does not have the property\n\n\t\t\t\t\tif (mode === 'removeKeyMatches') {\n\t\t\t\t\t\t// For \"removeKeyMatches\" add item\n\t\t\t\t\t\treturnData.push(entry);\n\t\t\t\t\t}\n\n\t\t\t\t\t// For \"mergeByKey\" and \"keepKeyMatches\" skip item\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!['string', 'number'].includes(typeof referenceValue)) {\n\t\t\t\t\tif (referenceValue !== null && referenceValue.constructor.name !== 'Data') {\n\t\t\t\t\t\t// Reference value is not of comparable type\n\n\t\t\t\t\t\tif (mode === 'removeKeyMatches') {\n\t\t\t\t\t\t\t// For \"removeKeyMatches\" add item\n\t\t\t\t\t\t\treturnData.push(entry);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// For \"mergeByKey\" and \"keepKeyMatches\" skip item\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (typeof referenceValue === 'number') {\n\t\t\t\t\treferenceValue = referenceValue.toString();\n\t\t\t\t} else if (referenceValue !== null && referenceValue.constructor.name === 'Date') {\n\t\t\t\t\treferenceValue = (referenceValue as Date).toISOString();\n\t\t\t\t}\n\n\t\t\t\tif (copyData.hasOwnProperty(referenceValue as string)) {\n\t\t\t\t\t// Item with reference value got found\n\n\t\t\t\t\tif (['null', 'undefined'].includes(typeof referenceValue)) {\n\t\t\t\t\t\t// The reference value is null or undefined\n\n\t\t\t\t\t\tif (mode === 'removeKeyMatches') {\n\t\t\t\t\t\t\t// For \"removeKeyMatches\" add item\n\t\t\t\t\t\t\treturnData.push(entry);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// For \"mergeByKey\" and \"keepKeyMatches\" skip item\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Match exists\n\t\t\t\t\tif (mode === 'removeKeyMatches') {\n\t\t\t\t\t\t// For \"removeKeyMatches\" we can skip the item as it has a match\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (mode === 'mergeByKey') {\n\t\t\t\t\t\t// Copy the entry as the data gets changed\n\t\t\t\t\t\tentry = deepCopy(entry);\n\n\t\t\t\t\t\tfor (key of Object.keys(copyData[referenceValue as string].json)) {\n\t\t\t\t\t\t\tif (key === propertyName2) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// TODO: Currently only copies json data and no binary one\n\t\t\t\t\t\t\tconst value = copyData[referenceValue as string].json[key];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\toverwrite === 'always' ||\n\t\t\t\t\t\t\t\t(overwrite === 'undefined' && !entry.json.hasOwnProperty(key)) ||\n\t\t\t\t\t\t\t\t(overwrite === 'blank' && [null, undefined, ''].includes(entry.json[key] as string))\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tentry.json[key] = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// For \"keepKeyMatches\" we add it as it is\n\t\t\t\t\t\treturnData.push(entry);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// No item for reference value got found\n\t\t\t\t\tif (mode === 'removeKeyMatches') {\n\t\t\t\t\t\t// For \"removeKeyMatches\" we can add it if not match got found\n\t\t\t\t\t\treturnData.push(entry);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (mode === 'mergeByKey') {\n\t\t\t\t\t// For \"mergeByKey\" we always add the entry anyway but then the unchanged one\n\t\t\t\t\treturnData.push(entry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn [returnData];\n\t\t} else if (mode === 'passThrough') {\n\t\t\tconst output = this.getNodeParameter('output', 0) as string;\n\n\t\t\tif (output === 'input1') {\n\t\t\t\treturnData.push.apply(returnData, this.getInputData(0));\n\t\t\t} else {\n\t\t\t\treturnData.push.apply(returnData, this.getInputData(1));\n\t\t\t}\n\t\t} else if (mode === 'wait') {\n\t\t\tconst pairedItem = generatePairedItemData(this.getInputData(0).length);\n\t\t\treturnData.push({ json: {}, pairedItem });\n\t\t}\n\n\t\treturn [returnData];\n\t}\n}\n"],"mappings":"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","names":["key","get"]}
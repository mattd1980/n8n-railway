{"version":3,"sources":["../../../../../../nodes/Merge/v3/actions/mode/combineByPosition.ts"],"sourcesContent":["import merge from 'lodash/merge';\nimport type {\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeProperties,\n\tIPairedItemData,\n} from 'n8n-workflow';\n\nimport { updateDisplayOptions } from '@utils/utilities';\n\nimport { clashHandlingProperties, numberInputsProperty } from '../../helpers/descriptions';\nimport type { ClashResolveOptions } from '../../helpers/interfaces';\nimport { addSuffixToEntriesKeys, selectMergeMethod } from '../../helpers/utils';\n\nexport const properties: INodeProperties[] = [\n\tnumberInputsProperty,\n\t{\n\t\tdisplayName: 'Options',\n\t\tname: 'options',\n\t\ttype: 'collection',\n\t\tplaceholder: 'Add option',\n\t\tdefault: {},\n\t\toptions: [\n\t\t\t{\n\t\t\t\t...clashHandlingProperties,\n\t\t\t\tdefault: { values: { resolveClash: 'addSuffix' } },\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Include Any Unpaired Items',\n\t\t\t\tname: 'includeUnpaired',\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdefault: false,\n\t\t\t\tdescription:\n\t\t\t\t\t'Whether unpaired items should be included in the result when there are differing numbers of items among the inputs',\n\t\t\t},\n\t\t],\n\t},\n];\n\nconst displayOptions = {\n\tshow: {\n\t\tmode: ['combine'],\n\t\tcombineBy: ['combineByPosition'],\n\t},\n};\n\nexport const description = updateDisplayOptions(displayOptions, properties);\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\tinputsData: INodeExecutionData[][],\n): Promise<INodeExecutionData[][]> {\n\tconst returnData: INodeExecutionData[] = [];\n\n\tconst clashHandling = this.getNodeParameter(\n\t\t'options.clashHandling.values',\n\t\t0,\n\t\t{},\n\t) as ClashResolveOptions;\n\tconst includeUnpaired = this.getNodeParameter('options.includeUnpaired', 0, false) as boolean;\n\n\tlet preferredInputIndex: number;\n\n\tif (clashHandling?.resolveClash?.includes('preferInput')) {\n\t\tpreferredInputIndex = Number(clashHandling.resolveClash.replace('preferInput', '')) - 1;\n\t} else {\n\t\tpreferredInputIndex = inputsData.length - 1;\n\t}\n\n\tconst preferred = inputsData[preferredInputIndex];\n\n\tif (clashHandling.resolveClash === 'addSuffix') {\n\t\tfor (const [inputIndex, input] of inputsData.entries()) {\n\t\t\tinputsData[inputIndex] = addSuffixToEntriesKeys(input, String(inputIndex + 1));\n\t\t}\n\t}\n\n\tlet numEntries: number;\n\tif (includeUnpaired) {\n\t\tnumEntries = Math.max(...inputsData.map((input) => input.length), preferred.length);\n\t} else {\n\t\tnumEntries = Math.min(...inputsData.map((input) => input.length), preferred.length);\n\t\tif (numEntries === 0) {\n\t\t\tthis.addExecutionHints({\n\t\t\t\tmessage: 'Consider enabling \"Include Any Unpaired Items\" in options or check your inputs',\n\t\t\t});\n\t\t\treturn [returnData];\n\t\t}\n\t}\n\n\tconst mergeIntoSingleObject = selectMergeMethod(clashHandling);\n\n\tfor (let i = 0; i < numEntries; i++) {\n\t\tconst preferredEntry = preferred[i] ?? {};\n\t\tconst restEntries = inputsData.map((input) => input[i] ?? {});\n\n\t\tconst json = {\n\t\t\t...mergeIntoSingleObject(\n\t\t\t\t{},\n\t\t\t\t...restEntries.map((entry) => entry.json ?? {}),\n\t\t\t\tpreferredEntry.json ?? {},\n\t\t\t),\n\t\t};\n\n\t\tconst binary = {\n\t\t\t...merge({}, ...restEntries.map((entry) => entry.binary ?? {}), preferredEntry.binary ?? {}),\n\t\t};\n\n\t\tconst pairedItem = [\n\t\t\t...restEntries.map((entry) => entry.pairedItem as IPairedItemData).flat(),\n\t\t\tpreferredEntry.pairedItem as IPairedItemData,\n\t\t].filter((item) => item !== undefined);\n\n\t\treturnData.push({ json, binary, pairedItem });\n\t}\n\n\treturn [returnData];\n}\n"],"mappings":"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","names":["merge"]}
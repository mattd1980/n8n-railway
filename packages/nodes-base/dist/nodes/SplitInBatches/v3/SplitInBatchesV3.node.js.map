{"version":3,"sources":["../../../../nodes/SplitInBatches/v3/SplitInBatchesV3.node.ts"],"sourcesContent":["import type {\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeDescription,\n\tIPairedItemData,\n} from 'n8n-workflow';\nimport { NodeConnectionTypes, deepCopy } from 'n8n-workflow';\n\nexport class SplitInBatchesV3 implements INodeType {\n\tdescription: INodeTypeDescription = {\n\t\tdisplayName: 'Loop Over Items (Split in Batches)',\n\t\tname: 'splitInBatches',\n\t\ticon: 'fa:sync',\n\t\ticonColor: 'dark-green',\n\t\tgroup: ['organization'],\n\t\tversion: 3,\n\t\tdescription: 'Split data into batches and iterate over each batch',\n\t\tdefaults: {\n\t\t\tname: 'Loop Over Items',\n\t\t\tcolor: '#007755',\n\t\t},\n\t\tinputs: [NodeConnectionTypes.Main],\n\n\t\toutputs: [NodeConnectionTypes.Main, NodeConnectionTypes.Main],\n\t\toutputNames: ['done', 'loop'],\n\t\tproperties: [\n\t\t\t{\n\t\t\t\tdisplayName:\n\t\t\t\t\t'You may not need this node â€” n8n nodes automatically run once for each input item. <a href=\"https://docs.n8n.io/getting-started/key-concepts/looping.html#using-loops-in-n8n\" target=\"_blank\">More info</a>',\n\t\t\t\tname: 'splitInBatchesNotice',\n\t\t\t\ttype: 'notice',\n\t\t\t\tdefault: '',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Batch Size',\n\t\t\t\tname: 'batchSize',\n\t\t\t\ttype: 'number',\n\t\t\t\ttypeOptions: {\n\t\t\t\t\tminValue: 1,\n\t\t\t\t},\n\t\t\t\tdefault: 1,\n\t\t\t\tdescription: 'The number of items to return with each call',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Options',\n\t\t\t\tname: 'options',\n\t\t\t\ttype: 'collection',\n\t\t\t\tplaceholder: 'Add option',\n\t\t\t\tdefault: {},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Reset',\n\t\t\t\t\t\tname: 'reset',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: false,\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'Whether the node starts again from the beginning of the input items. This will treat incoming data as a new set rather than continuing with the previous items.',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t};\n\n\tasync execute(this: IExecuteFunctions): Promise<INodeExecutionData[][] | null> {\n\t\t// Get the input data and create a new array so that we can remove\n\t\t// items without a problem\n\t\tconst items = this.getInputData().slice();\n\n\t\tconst nodeContext = this.getContext('node');\n\n\t\tconst batchSize = this.getNodeParameter('batchSize', 0) as number;\n\n\t\tconst returnItems: INodeExecutionData[] = [];\n\n\t\tconst options = this.getNodeParameter('options', 0, {});\n\n\t\tif (nodeContext.items === undefined || options.reset === true) {\n\t\t\t// Is the first time the node runs\n\n\t\t\tconst sourceData = this.getInputSourceData();\n\n\t\t\tnodeContext.currentRunIndex = 0;\n\t\t\tnodeContext.maxRunIndex = Math.ceil(items.length / batchSize);\n\t\t\tnodeContext.sourceData = deepCopy(sourceData);\n\n\t\t\t// Get the items which should be returned\n\t\t\treturnItems.push.apply(returnItems, items.splice(0, batchSize));\n\n\t\t\t// Save the incoming items to be able to return them for later runs\n\t\t\tnodeContext.items = [...items];\n\n\t\t\t// Reset processedItems as they get only added starting from the first iteration\n\t\t\tnodeContext.processedItems = [];\n\t\t} else {\n\t\t\t// The node has been called before. So return the next batch of items.\n\t\t\tnodeContext.currentRunIndex += 1;\n\t\t\treturnItems.push.apply(\n\t\t\t\treturnItems,\n\t\t\t\t(nodeContext.items as INodeExecutionData[]).splice(0, batchSize),\n\t\t\t);\n\n\t\t\tconst addSourceOverwrite = (pairedItem: IPairedItemData | number): IPairedItemData => {\n\t\t\t\tif (typeof pairedItem === 'number') {\n\t\t\t\t\treturn {\n\t\t\t\t\t\titem: pairedItem,\n\t\t\t\t\t\tsourceOverwrite: nodeContext.sourceData,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\t...pairedItem,\n\t\t\t\t\tsourceOverwrite: nodeContext.sourceData,\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tfunction getPairedItemInformation(\n\t\t\t\titem: INodeExecutionData,\n\t\t\t): IPairedItemData | IPairedItemData[] {\n\t\t\t\tif (item.pairedItem === undefined) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\titem: 0,\n\t\t\t\t\t\tsourceOverwrite: nodeContext.sourceData,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (Array.isArray(item.pairedItem)) {\n\t\t\t\t\treturn item.pairedItem.map(addSourceOverwrite);\n\t\t\t\t}\n\n\t\t\t\treturn addSourceOverwrite(item.pairedItem);\n\t\t\t}\n\n\t\t\tconst sourceOverwrite = this.getInputSourceData();\n\n\t\t\tconst newItems = items.map((item, index) => {\n\t\t\t\treturn {\n\t\t\t\t\t...item,\n\t\t\t\t\tpairedItem: {\n\t\t\t\t\t\tsourceOverwrite,\n\t\t\t\t\t\titem: index,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t});\n\n\t\t\tnodeContext.processedItems = [...nodeContext.processedItems, ...newItems];\n\n\t\t\treturnItems.map((item) => {\n\t\t\t\titem.pairedItem = getPairedItemInformation(item);\n\t\t\t});\n\t\t}\n\n\t\tnodeContext.noItemsLeft = nodeContext.items.length === 0;\n\n\t\tif (returnItems.length === 0) {\n\t\t\tnodeContext.done = true;\n\t\t\treturn [nodeContext.processedItems, []];\n\t\t}\n\n\t\tnodeContext.done = false;\n\n\t\treturn [[], returnItems];\n\t}\n}\n"],"mappings":"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","names":["getPairedItemInformation"]}
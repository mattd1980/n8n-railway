{"version":3,"sources":["../../../../../../nodes/Google/Sheet/v2/helpers/GoogleSheets.utils.ts"],"sourcesContent":["import type {\n\tIExecuteFunctions,\n\tIDataObject,\n\tINodeExecutionData,\n\tINodeListSearchItems,\n\tINodePropertyOptions,\n\tINode,\n\tResourceMapperField,\n} from 'n8n-workflow';\nimport { NodeOperationError } from 'n8n-workflow';\n\nimport type { GoogleSheet } from './GoogleSheet';\nimport type {\n\tRangeDetectionOptions,\n\tResourceLocator,\n\tSheetRangeData,\n\tValueInputOption,\n} from './GoogleSheets.types';\nimport { ResourceLocatorUiNames, ROW_NUMBER } from './GoogleSheets.types';\n\nexport const untilSheetSelected = { sheetName: [''] };\n\n// Used to extract the ID from the URL\nexport function getSpreadsheetId(\n\tnode: INode,\n\tdocumentIdType: ResourceLocator,\n\tvalue: string,\n): string {\n\tif (!value) {\n\t\tthrow new NodeOperationError(\n\t\t\tnode,\n\t\t\t`Can not get sheet '${ResourceLocatorUiNames[documentIdType]}' with a value of '${value}'`,\n\t\t\t{ level: 'warning' },\n\t\t);\n\t}\n\tif (documentIdType === 'url') {\n\t\tconst regex = /([-\\w]{25,})/;\n\t\tconst parts = value.match(regex);\n\n\t\tif (parts == null || parts.length < 2) {\n\t\t\treturn '';\n\t\t} else {\n\t\t\treturn parts[0];\n\t\t}\n\t}\n\t// If it is byID or byList we can just return\n\treturn value;\n}\n\nexport function getSheetId(value: string): number {\n\tif (value === 'gid=0') return 0;\n\treturn parseInt(value);\n}\n\n// Convert number to Sheets / Excel column name\nexport function getColumnName(colNumber: number): string {\n\tconst baseChar = 'A'.charCodeAt(0);\n\tlet letters = '';\n\tdo {\n\t\tcolNumber -= 1;\n\t\tletters = String.fromCharCode(baseChar + (colNumber % 26)) + letters;\n\t\tcolNumber = (colNumber / 26) >> 0;\n\t} while (colNumber > 0);\n\n\treturn letters;\n}\n\n// Convert Column Name to Number (A = 1, B = 2, AA = 27)\nexport function getColumnNumber(colPosition: string): number {\n\tlet colNum = 0;\n\tfor (let i = 0; i < colPosition.length; i++) {\n\t\tcolNum *= 26;\n\t\tcolNum += colPosition[i].charCodeAt(0) - 'A'.charCodeAt(0) + 1;\n\t}\n\treturn colNum;\n}\n\n// Hex to RGB\nexport function hexToRgb(hex: string) {\n\t// Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n\tconst shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n\thex = hex.replace(shorthandRegex, (_, r, g, b) => {\n\t\treturn r + r + g + g + b + b;\n\t});\n\n\tconst result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\n\tif (result) {\n\t\treturn {\n\t\t\tred: parseInt(result[1], 16),\n\t\t\tgreen: parseInt(result[2], 16),\n\t\t\tblue: parseInt(result[3], 16),\n\t\t};\n\t} else {\n\t\treturn null;\n\t}\n}\n\nexport function addRowNumber(data: SheetRangeData, headerRow: number) {\n\tif (data.length === 0) return data;\n\tconst sheetData = data.map((row, i) => [i + 1, ...row]);\n\tsheetData[headerRow][0] = ROW_NUMBER;\n\treturn sheetData;\n}\n\nexport function trimToFirstEmptyRow(data: SheetRangeData, includesRowNumber = true) {\n\tconst baseLength = includesRowNumber ? 1 : 0;\n\tconst emptyRowIndex = data.findIndex((row) => row.slice(baseLength).every((cell) => cell === ''));\n\tif (emptyRowIndex === -1) {\n\t\treturn data;\n\t}\n\treturn data.slice(0, emptyRowIndex);\n}\n\nexport function removeEmptyRows(data: SheetRangeData, includesRowNumber = true) {\n\tconst baseLength = includesRowNumber ? 1 : 0;\n\tconst notEmptyRows = data.filter((row) =>\n\t\trow\n\t\t\t.slice(baseLength)\n\t\t\t.some((cell) => cell || typeof cell === 'number' || typeof cell === 'boolean'),\n\t);\n\tif (includesRowNumber) {\n\t\tnotEmptyRows[0][0] = ROW_NUMBER;\n\t}\n\treturn notEmptyRows;\n}\n\nexport function trimLeadingEmptyRows(\n\tdata: SheetRangeData,\n\tincludesRowNumber = true,\n\trowNumbersColumnName = ROW_NUMBER,\n) {\n\tconst baseLength = includesRowNumber ? 1 : 0;\n\tconst firstNotEmptyRowIndex = data.findIndex((row) =>\n\t\trow.slice(baseLength).some((cell) => cell || typeof cell === 'number'),\n\t);\n\n\tconst returnData = data.slice(firstNotEmptyRowIndex);\n\tif (includesRowNumber) {\n\t\treturnData[0][0] = rowNumbersColumnName;\n\t}\n\n\treturn returnData;\n}\n\nexport function removeEmptyColumns(data: SheetRangeData) {\n\tif (!data || data.length === 0) return [];\n\tconst returnData: SheetRangeData = [];\n\tconst longestRow = data.reduce((a, b) => (a.length > b.length ? a : b), []).length;\n\tfor (let col = 0; col < longestRow; col++) {\n\t\tconst column = data.map((row) => row[col]);\n\t\tif (column[0] !== '') {\n\t\t\treturnData.push(column);\n\t\t\tcontinue;\n\t\t}\n\t\tconst hasData = column.slice(1).some((cell) => cell || typeof cell === 'number');\n\t\tif (hasData) {\n\t\t\treturnData.push(column);\n\t\t}\n\t}\n\treturn (returnData[0] || []).map((_, i) =>\n\t\treturnData.map((row) => (row[i] === undefined ? '' : row[i])),\n\t);\n}\n\nexport function prepareSheetData(\n\tdata: SheetRangeData,\n\toptions: RangeDetectionOptions,\n\taddRowNumbersToData = true,\n) {\n\tlet returnData: SheetRangeData = [...(data || [])];\n\n\tlet headerRow = 0;\n\tlet firstDataRow = 1;\n\n\tif (options.rangeDefinition === 'specifyRange') {\n\t\theaderRow = parseInt(options.headerRow as string, 10) - 1;\n\t\tfirstDataRow = parseInt(options.firstDataRow as string, 10) - 1;\n\t}\n\n\tif (addRowNumbersToData) {\n\t\treturnData = addRowNumber(returnData, headerRow);\n\t}\n\n\tif (options.rangeDefinition === 'detectAutomatically') {\n\t\treturnData = removeEmptyColumns(returnData);\n\t\treturnData = trimLeadingEmptyRows(returnData, addRowNumbersToData);\n\n\t\tif (options.readRowsUntil === 'firstEmptyRow') {\n\t\t\treturnData = trimToFirstEmptyRow(returnData, addRowNumbersToData);\n\t\t} else {\n\t\t\treturnData = removeEmptyRows(returnData, addRowNumbersToData);\n\t\t}\n\t}\n\n\treturn { data: returnData, headerRow, firstDataRow };\n}\n\nexport function getRangeString(sheetName: string, options: RangeDetectionOptions) {\n\tif (options.rangeDefinition === 'specifyRangeA1') {\n\t\treturn options.range ? `${sheetName}!${options.range}` : sheetName;\n\t}\n\treturn sheetName;\n}\n\nexport async function getExistingSheetNames(sheet: GoogleSheet) {\n\tconst { sheets } = await sheet.spreadsheetGetSheets();\n\treturn ((sheets as IDataObject[]) || []).map((entry) => (entry.properties as IDataObject)?.title);\n}\n\nexport function mapFields(this: IExecuteFunctions, inputSize: number) {\n\tconst returnData: IDataObject[] = [];\n\n\tfor (let i = 0; i < inputSize; i++) {\n\t\tconst nodeVersion = this.getNode().typeVersion;\n\t\tif (nodeVersion < 4) {\n\t\t\tconst fields = this.getNodeParameter('fieldsUi.fieldValues', i, []) as IDataObject[];\n\t\t\tlet dataToSend: IDataObject = {};\n\t\t\tfor (const field of fields) {\n\t\t\t\tdataToSend = { ...dataToSend, [field.fieldId as string]: field.fieldValue };\n\t\t\t}\n\t\t\treturnData.push(dataToSend);\n\t\t} else {\n\t\t\tconst mappingValues = this.getNodeParameter('columns.value', i) as IDataObject;\n\t\t\tif (Object.keys(mappingValues).length === 0) {\n\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\tthis.getNode(),\n\t\t\t\t\t\"At least one value has to be added under 'Values to Send'\",\n\t\t\t\t);\n\t\t\t}\n\t\t\treturnData.push(mappingValues);\n\t\t}\n\t}\n\n\treturn returnData;\n}\n\nexport async function autoMapInputData(\n\tthis: IExecuteFunctions,\n\tsheetNameWithRange: string,\n\tsheet: GoogleSheet,\n\titems: INodeExecutionData[],\n\toptions: IDataObject,\n) {\n\tconst returnData: IDataObject[] = [];\n\tconst [sheetName, _sheetRange] = sheetNameWithRange.split('!');\n\tconst locationDefine = (options.locationDefine as IDataObject)?.values as IDataObject;\n\tconst handlingExtraData = (options.handlingExtraData as string) || 'insertInNewColumn';\n\n\tlet headerRow = 1;\n\n\tif (locationDefine) {\n\t\theaderRow = parseInt(locationDefine.headerRow as string, 10);\n\t}\n\n\tlet columnNames: string[] = [];\n\tconst response = await sheet.getData(`${sheetName}!${headerRow}:${headerRow}`, 'FORMATTED_VALUE');\n\n\tcolumnNames = response ? response[0] : [];\n\n\tif (handlingExtraData === 'insertInNewColumn') {\n\t\tif (!columnNames.length) {\n\t\t\tawait sheet.updateRows(\n\t\t\t\tsheetName,\n\t\t\t\t[Object.keys(items[0].json).filter((key) => key !== ROW_NUMBER)],\n\t\t\t\t(options.cellFormat as ValueInputOption) || 'RAW',\n\t\t\t\theaderRow,\n\t\t\t);\n\t\t\tcolumnNames = Object.keys(items[0].json);\n\t\t}\n\n\t\tconst newColumns = new Set<string>();\n\n\t\titems.forEach((item) => {\n\t\t\tObject.keys(item.json).forEach((key) => {\n\t\t\t\tif (key !== ROW_NUMBER && !columnNames.includes(key)) {\n\t\t\t\t\tnewColumns.add(key);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (item.json[ROW_NUMBER]) {\n\t\t\t\tconst { [ROW_NUMBER]: _, ...json } = item.json;\n\t\t\t\treturnData.push(json);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturnData.push(item.json);\n\t\t});\n\t\tif (newColumns.size) {\n\t\t\tawait sheet.updateRows(\n\t\t\t\tsheetName,\n\t\t\t\t[columnNames.concat([...newColumns])],\n\t\t\t\t(options.cellFormat as ValueInputOption) || 'RAW',\n\t\t\t\theaderRow,\n\t\t\t);\n\t\t}\n\t}\n\tif (handlingExtraData === 'ignoreIt') {\n\t\titems.forEach((item) => {\n\t\t\treturnData.push(item.json);\n\t\t});\n\t}\n\tif (handlingExtraData === 'error') {\n\t\titems.forEach((item, itemIndex) => {\n\t\t\tObject.keys(item.json).forEach((key) => {\n\t\t\t\tif (!columnNames.includes(key)) {\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Unexpected fields in node input', {\n\t\t\t\t\t\titemIndex,\n\t\t\t\t\t\tdescription: `The input field '${key}' doesn't match any column in the Sheet. You can ignore this by changing the 'Handling extra data' field, which you can find under 'Options'.`,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\treturnData.push(item.json);\n\t\t});\n\t}\n\n\treturn returnData;\n}\n\nexport function sortLoadOptions(data: INodePropertyOptions[] | INodeListSearchItems[]) {\n\tconst returnData = [...data];\n\treturnData.sort((a, b) => {\n\t\tconst aName = a.name.toLowerCase();\n\t\tconst bName = b.name.toLowerCase();\n\t\tif (aName < bName) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (aName > bName) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t});\n\n\treturn returnData;\n}\n\nexport function cellFormatDefault(nodeVersion: number) {\n\tif (nodeVersion < 4.1) {\n\t\treturn 'RAW';\n\t}\n\treturn 'USER_ENTERED';\n}\n\nexport function checkForSchemaChanges(\n\tnode: INode,\n\tcolumnNames: string[],\n\tschema: ResourceMapperField[],\n) {\n\tconst updatedColumnNames: Array<{ oldName: string; newName: string }> = [];\n\t// RMC filters out empty columns so do the same here\n\tcolumnNames = columnNames.filter((col) => col !== '');\n\n\t// if sheet does not contain ROW_NUMBER ignore it as data come from read rows operation\n\tconst schemaColumns = columnNames.includes(ROW_NUMBER)\n\t\t? schema.map((s) => s.id)\n\t\t: schema.filter((s) => s.id !== ROW_NUMBER).map((s) => s.id);\n\n\tfor (const [columnIndex, columnName] of columnNames.entries()) {\n\t\tconst schemaEntry = schemaColumns[columnIndex];\n\t\tif (schemaEntry === undefined) break;\n\t\tif (columnName !== schemaEntry) {\n\t\t\tupdatedColumnNames.push({ oldName: schemaEntry, newName: columnName });\n\t\t}\n\t}\n\n\tif (updatedColumnNames.length) {\n\t\tthrow new NodeOperationError(node, \"Column names were updated after the node's setup\", {\n\t\t\tdescription: `Refresh the columns list in the 'Column to Match On' parameter. Updated columns: ${updatedColumnNames.map((c) => `${c.oldName} -> ${c.newName}`).join(', ')}`,\n\t\t});\n\t}\n}\n"],"mappings":"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","names":[]}
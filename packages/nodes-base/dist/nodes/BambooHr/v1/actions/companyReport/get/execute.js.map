{"version":3,"sources":["../../../../../../../nodes/BambooHr/v1/actions/companyReport/get/execute.ts"],"sourcesContent":["import type { IExecuteFunctions, IDataObject, INodeExecutionData } from 'n8n-workflow';\n\nimport { apiRequest } from '../../../transport';\n\nexport async function get(this: IExecuteFunctions, index: number) {\n\tconst body: IDataObject = {};\n\tconst requestMethod = 'GET';\n\tconst items = this.getInputData();\n\n\t//meta data\n\tconst reportId = this.getNodeParameter('reportId', index) as string;\n\tconst format = this.getNodeParameter('format', 0) as string;\n\tconst fd = this.getNodeParameter('options.fd', index, true) as boolean;\n\tconst onlyCurrent = this.getNodeParameter('options.onlyCurrent', index, true) as boolean;\n\n\t//endpoint\n\tconst endpoint = `reports/${reportId}/?format=${format}&fd=${fd}&onlyCurrent=${onlyCurrent}`;\n\n\tif (format === 'JSON') {\n\t\tconst responseData = await apiRequest.call(\n\t\t\tthis,\n\t\t\trequestMethod,\n\t\t\tendpoint,\n\t\t\tbody,\n\t\t\t{},\n\t\t\t{ resolveWithFullResponse: true },\n\t\t);\n\t\treturn this.helpers.returnJsonArray(responseData.body as IDataObject);\n\t}\n\n\tconst output: string = this.getNodeParameter('output', index) as string;\n\n\tconst response = await apiRequest.call(this, requestMethod, endpoint, body, {} as IDataObject, {\n\t\tencoding: null,\n\t\tjson: false,\n\t\tresolveWithFullResponse: true,\n\t});\n\tlet mimeType = response.headers['content-type'] as string | undefined;\n\tmimeType = mimeType ? mimeType.split(';').find((value) => value.includes('/')) : undefined;\n\tconst contentDisposition = response.headers['content-disposition'];\n\tconst fileNameRegex = /(?<=filename=\").*\\b/;\n\tconst match = fileNameRegex.exec(contentDisposition as string);\n\tlet fileName = '';\n\n\t// file name was found\n\tif (match !== null) {\n\t\tfileName = match[0];\n\t}\n\n\tconst newItem: INodeExecutionData = {\n\t\tjson: items[index].json,\n\t\tbinary: {},\n\t};\n\n\tif (items[index].binary !== undefined && newItem.binary) {\n\t\t// Create a shallow copy of the binary data so that the old\n\t\t// data references which do not get changed still stay behind\n\t\t// but the incoming data does not get changed.\n\t\tObject.assign(newItem.binary, items[index].binary);\n\t}\n\n\tnewItem.binary = {\n\t\t[output]: await this.helpers.prepareBinaryData(\n\t\t\tresponse.body as unknown as Buffer,\n\t\t\tfileName,\n\t\t\tmimeType,\n\t\t),\n\t};\n\n\treturn [newItem as unknown as INodeExecutionData[]];\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,uBAA2B;AAE3B,eAAsB,IAA6B,OAAe;AACjE,QAAM,OAAoB,CAAC;AAC3B,QAAM,gBAAgB;AACtB,QAAM,QAAQ,KAAK,aAAa;AAGhC,QAAM,WAAW,KAAK,iBAAiB,YAAY,KAAK;AACxD,QAAM,SAAS,KAAK,iBAAiB,UAAU,CAAC;AAChD,QAAM,KAAK,KAAK,iBAAiB,cAAc,OAAO,IAAI;AAC1D,QAAM,cAAc,KAAK,iBAAiB,uBAAuB,OAAO,IAAI;AAG5E,QAAM,WAAW,WAAW,QAAQ,YAAY,MAAM,OAAO,EAAE,gBAAgB,WAAW;AAE1F,MAAI,WAAW,QAAQ;AACtB,UAAM,eAAe,MAAM,4BAAW;AAAA,MACrC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,CAAC;AAAA,MACD,EAAE,yBAAyB,KAAK;AAAA,IACjC;AACA,WAAO,KAAK,QAAQ,gBAAgB,aAAa,IAAmB;AAAA,EACrE;AAEA,QAAM,SAAiB,KAAK,iBAAiB,UAAU,KAAK;AAE5D,QAAM,WAAW,MAAM,4BAAW,KAAK,MAAM,eAAe,UAAU,MAAM,CAAC,GAAkB;AAAA,IAC9F,UAAU;AAAA,IACV,MAAM;AAAA,IACN,yBAAyB;AAAA,EAC1B,CAAC;AACD,MAAI,WAAW,SAAS,QAAQ,cAAc;AAC9C,aAAW,WAAW,SAAS,MAAM,GAAG,EAAE,KAAK,CAAC,UAAU,MAAM,SAAS,GAAG,CAAC,IAAI;AACjF,QAAM,qBAAqB,SAAS,QAAQ,qBAAqB;AACjE,QAAM,gBAAgB;AACtB,QAAM,QAAQ,cAAc,KAAK,kBAA4B;AAC7D,MAAI,WAAW;AAGf,MAAI,UAAU,MAAM;AACnB,eAAW,MAAM,CAAC;AAAA,EACnB;AAEA,QAAM,UAA8B;AAAA,IACnC,MAAM,MAAM,KAAK,EAAE;AAAA,IACnB,QAAQ,CAAC;AAAA,EACV;AAEA,MAAI,MAAM,KAAK,EAAE,WAAW,UAAa,QAAQ,QAAQ;AAIxD,WAAO,OAAO,QAAQ,QAAQ,MAAM,KAAK,EAAE,MAAM;AAAA,EAClD;AAEA,UAAQ,SAAS;AAAA,IAChB,CAAC,MAAM,GAAG,MAAM,KAAK,QAAQ;AAAA,MAC5B,SAAS;AAAA,MACT;AAAA,MACA;AAAA,IACD;AAAA,EACD;AAEA,SAAO,CAAC,OAA0C;AACnD;","names":[]}
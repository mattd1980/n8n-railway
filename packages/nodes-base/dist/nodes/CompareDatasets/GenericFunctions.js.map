{"version":3,"sources":["../../../nodes/CompareDatasets/GenericFunctions.ts"],"sourcesContent":["import { cloneDeep } from 'lodash';\nimport difference from 'lodash/difference';\nimport get from 'lodash/get';\nimport intersection from 'lodash/intersection';\nimport isEmpty from 'lodash/isEmpty';\nimport omit from 'lodash/omit';\nimport set from 'lodash/set';\nimport union from 'lodash/union';\nimport unset from 'lodash/unset';\nimport { ApplicationError, type IDataObject, type INodeExecutionData } from 'n8n-workflow';\n\nimport { fuzzyCompare, preparePairedItemDataArray } from '@utils/utilities';\n\ntype PairToMatch = {\n\tfield1: string;\n\tfield2: string;\n};\n\ntype EntryMatches = {\n\tentry: INodeExecutionData;\n\tmatches: INodeExecutionData[];\n};\n\ntype CompareFunction = <T, U>(a: T, b: U) => boolean;\n\nconst processNullishValueFunction = (version: number) => {\n\tif (version >= 2) {\n\t\treturn <T>(value: T) => (value === undefined ? null : value);\n\t}\n\treturn <T>(value: T) => value || null;\n};\n\nfunction compareItems(\n\titem1: INodeExecutionData,\n\titem2: INodeExecutionData,\n\tfieldsToMatch: PairToMatch[],\n\toptions: IDataObject,\n\tskipFields: string[],\n\tisEntriesEqual: CompareFunction,\n) {\n\tconst keys = {} as IDataObject;\n\tfieldsToMatch.forEach((field) => {\n\t\tkeys[field.field1] = item1.json[field.field1];\n\t});\n\n\tconst keys1 = Object.keys(item1.json);\n\tconst keys2 = Object.keys(item2.json);\n\tconst allUniqueKeys = union(keys1, keys2);\n\n\tlet keysToCompare;\n\tif (options.fuzzyCompare && (options.nodeVersion as number) >= 2.1) {\n\t\tkeysToCompare = allUniqueKeys;\n\t} else {\n\t\tkeysToCompare = intersection(keys1, keys2);\n\t}\n\n\tconst same = keysToCompare.reduce((acc, key) => {\n\t\tif (isEntriesEqual(item1.json[key], item2.json[key])) {\n\t\t\tacc[key] = item1.json[key];\n\t\t}\n\t\treturn acc;\n\t}, {} as IDataObject);\n\n\tconst sameKeys = Object.keys(same);\n\tconst differentKeys = difference(allUniqueKeys, sameKeys);\n\n\tconst different: IDataObject = {};\n\tconst skipped: IDataObject = {};\n\n\tdifferentKeys.forEach((key, i) => {\n\t\tconst processNullishValue = processNullishValueFunction(options.nodeVersion as number);\n\n\t\tswitch (options.resolve) {\n\t\t\tcase 'preferInput1':\n\t\t\t\tdifferent[key] = processNullishValue(item1.json[key]);\n\t\t\t\tbreak;\n\t\t\tcase 'preferInput2':\n\t\t\t\tdifferent[key] = processNullishValue(item2.json[key]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlet input1 = processNullishValue(item1.json[key]);\n\t\t\t\tlet input2 = processNullishValue(item2.json[key]);\n\n\t\t\t\tlet [firstInputName, secondInputName] = ['input1', 'input2'];\n\t\t\t\tif ((options.nodeVersion as number) >= 2) {\n\t\t\t\t\t[firstInputName, secondInputName] = ['inputA', 'inputB'];\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(options.nodeVersion as number) >= 2.1 &&\n\t\t\t\t\t!options.disableDotNotation &&\n\t\t\t\t\t!skipFields.some((field) => field === key)\n\t\t\t\t) {\n\t\t\t\t\tconst skippedFieldsWithDotNotation = skipFields.filter(\n\t\t\t\t\t\t(field) => field.startsWith(key) && field.includes('.'),\n\t\t\t\t\t);\n\n\t\t\t\t\tinput1 = cloneDeep(input1);\n\t\t\t\t\tinput2 = cloneDeep(input2);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tskippedFieldsWithDotNotation.length &&\n\t\t\t\t\t\t(typeof input1 !== 'object' || typeof input2 !== 'object')\n\t\t\t\t\t) {\n\t\t\t\t\t\tthrow new ApplicationError(\n\t\t\t\t\t\t\t`The field \\'${key}\\' in item ${i} is not an object. It is not possible to use dot notation.`,\n\t\t\t\t\t\t\t{ level: 'warning' },\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (skipped[key] === undefined && skippedFieldsWithDotNotation.length) {\n\t\t\t\t\t\tskipped[key] = { [firstInputName]: {}, [secondInputName]: {} };\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const skippedField of skippedFieldsWithDotNotation) {\n\t\t\t\t\t\tconst nestedField = skippedField.replace(`${key}.`, '');\n\t\t\t\t\t\tset(\n\t\t\t\t\t\t\t(skipped[key] as IDataObject)[firstInputName] as IDataObject,\n\t\t\t\t\t\t\tnestedField,\n\t\t\t\t\t\t\tget(input1, nestedField),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tset(\n\t\t\t\t\t\t\t(skipped[key] as IDataObject)[secondInputName] as IDataObject,\n\t\t\t\t\t\t\tnestedField,\n\t\t\t\t\t\t\tget(input2, nestedField),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tunset(input1, nestedField);\n\t\t\t\t\t\tunset(input2, nestedField);\n\t\t\t\t\t}\n\n\t\t\t\t\tdifferent[key] = { [firstInputName]: input1, [secondInputName]: input2 };\n\t\t\t\t} else {\n\t\t\t\t\tif (skipFields.includes(key)) {\n\t\t\t\t\t\tskipped[key] = { [firstInputName]: input1, [secondInputName]: input2 };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdifferent[key] = { [firstInputName]: input1, [secondInputName]: input2 };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t});\n\n\treturn {\n\t\tjson: { keys, same, different, ...(!isEmpty(skipped) && { skipped }) },\n\t\tpairedItem: [\n\t\t\t...preparePairedItemDataArray(item1.pairedItem),\n\t\t\t...preparePairedItemDataArray(item2.pairedItem),\n\t\t],\n\t} as INodeExecutionData;\n}\n\nfunction combineItems(\n\titem1: INodeExecutionData,\n\titem2: INodeExecutionData,\n\tprefer: string,\n\texcept: string,\n\tdisableDotNotation: boolean,\n) {\n\tlet exceptFields: string[];\n\tconst [entry, match] = prefer === 'input1' ? [item1, item2] : [item2, item1];\n\n\tif (except && Array.isArray(except) && except.length) {\n\t\texceptFields = except;\n\t} else {\n\t\texceptFields = except ? except.split(',').map((field) => field.trim()) : [];\n\t}\n\n\texceptFields.forEach((field) => {\n\t\tentry.json[field] = match.json[field];\n\t\tif (disableDotNotation) {\n\t\t\tentry.json[field] = match.json[field];\n\t\t} else {\n\t\t\tconst value = get(match.json, field) || null;\n\t\t\tset(entry, ['json', field], value);\n\t\t}\n\t});\n\n\treturn entry;\n}\n\nfunction findAllMatches(\n\tdata: INodeExecutionData[],\n\tlookup: IDataObject,\n\tdisableDotNotation: boolean,\n\tisEntriesEqual: CompareFunction,\n) {\n\treturn data.reduce((acc, entry2, i) => {\n\t\tif (entry2 === undefined) return acc;\n\n\t\tfor (const key of Object.keys(lookup)) {\n\t\t\tconst excpectedValue = lookup[key];\n\t\t\tlet entry2FieldValue;\n\n\t\t\tif (disableDotNotation) {\n\t\t\t\tentry2FieldValue = entry2.json[key];\n\t\t\t} else {\n\t\t\t\tentry2FieldValue = get(entry2.json, key);\n\t\t\t}\n\n\t\t\tif (!isEntriesEqual(excpectedValue, entry2FieldValue)) {\n\t\t\t\treturn acc;\n\t\t\t}\n\t\t}\n\n\t\treturn acc.concat({\n\t\t\tentry: entry2,\n\t\t\tindex: i,\n\t\t});\n\t}, [] as IDataObject[]);\n}\n\nfunction findFirstMatch(\n\tdata: INodeExecutionData[],\n\tlookup: IDataObject,\n\tdisableDotNotation: boolean,\n\tisEntriesEqual: CompareFunction,\n) {\n\tconst index = data.findIndex((entry2) => {\n\t\tif (entry2 === undefined) return false;\n\n\t\tfor (const key of Object.keys(lookup)) {\n\t\t\tconst excpectedValue = lookup[key];\n\t\t\tlet entry2FieldValue;\n\n\t\t\tif (disableDotNotation) {\n\t\t\t\tentry2FieldValue = entry2.json[key];\n\t\t\t} else {\n\t\t\t\tentry2FieldValue = get(entry2.json, key);\n\t\t\t}\n\n\t\t\tif (!isEntriesEqual(excpectedValue, entry2FieldValue)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t});\n\tif (index === -1) return [];\n\n\treturn [{ entry: data[index], index }];\n}\n\nexport function findMatches(\n\tinput1: INodeExecutionData[],\n\tinput2: INodeExecutionData[],\n\tfieldsToMatch: PairToMatch[],\n\toptions: IDataObject,\n) {\n\tconst data1 = [...input1];\n\tconst data2 = [...input2];\n\n\tconst isEntriesEqual = fuzzyCompare(\n\t\toptions.fuzzyCompare as boolean,\n\t\toptions.nodeVersion as number,\n\t);\n\tconst disableDotNotation = (options.disableDotNotation as boolean) || false;\n\tconst multipleMatches = (options.multipleMatches as string) || 'first';\n\tconst skipFields = ((options.skipFields as string) || '').split(',').map((field) => field.trim());\n\n\tif (disableDotNotation && skipFields.some((field) => field.includes('.'))) {\n\t\tconst fieldToSkip = skipFields.find((field) => field.includes('.'));\n\t\tconst msg = `Dot notation is disabled, but field to skip comparing '${fieldToSkip}' contains dot`;\n\t\tthrow new ApplicationError(msg, { level: 'warning' });\n\t}\n\n\tconst filteredData = {\n\t\tmatched: [] as EntryMatches[],\n\t\tunmatched1: [] as INodeExecutionData[],\n\t\tunmatched2: [] as INodeExecutionData[],\n\t};\n\n\tconst matchedInInput2 = new Set<number>();\n\n\tmatchesLoop: for (const entry of data1) {\n\t\tconst lookup: IDataObject = {};\n\n\t\tfieldsToMatch.forEach((matchCase) => {\n\t\t\tlet valueToCompare;\n\t\t\tif (disableDotNotation) {\n\t\t\t\tvalueToCompare = entry.json[matchCase.field1];\n\t\t\t} else {\n\t\t\t\tvalueToCompare = get(entry.json, matchCase.field1);\n\t\t\t}\n\t\t\tlookup[matchCase.field2] = valueToCompare;\n\t\t});\n\n\t\tfor (const fieldValue of Object.values(lookup)) {\n\t\t\tif (fieldValue === undefined) {\n\t\t\t\tfilteredData.unmatched1.push(entry);\n\t\t\t\tcontinue matchesLoop;\n\t\t\t}\n\t\t}\n\n\t\tconst foundedMatches =\n\t\t\tmultipleMatches === 'all'\n\t\t\t\t? findAllMatches(data2, lookup, disableDotNotation, isEntriesEqual)\n\t\t\t\t: findFirstMatch(data2, lookup, disableDotNotation, isEntriesEqual);\n\n\t\tconst matches = foundedMatches.map((match) => match.entry) as INodeExecutionData[];\n\t\tfoundedMatches.map((match) => matchedInInput2.add(match.index as number));\n\n\t\tif (matches.length) {\n\t\t\tfilteredData.matched.push({ entry, matches });\n\t\t} else {\n\t\t\tfilteredData.unmatched1.push(entry);\n\t\t}\n\t}\n\n\tdata2.forEach((entry, i) => {\n\t\tif (!matchedInInput2.has(i)) {\n\t\t\tfilteredData.unmatched2.push(entry);\n\t\t}\n\t});\n\n\tconst same: INodeExecutionData[] = [];\n\tconst different: INodeExecutionData[] = [];\n\n\tfilteredData.matched.forEach((entryMatches) => {\n\t\tlet entryCopy: INodeExecutionData | undefined;\n\n\t\tentryMatches.matches.forEach((match) => {\n\t\t\tlet entryFromInput1 = entryMatches.entry.json;\n\t\t\tlet entryFromInput2 = match.json;\n\n\t\t\tif (skipFields.length) {\n\t\t\t\tif (disableDotNotation || !skipFields.some((field) => field.includes('.'))) {\n\t\t\t\t\tentryFromInput1 = omit(entryFromInput1, skipFields);\n\t\t\t\t\tentryFromInput2 = omit(entryFromInput2, skipFields);\n\t\t\t\t} else {\n\t\t\t\t\tentryFromInput1 = cloneDeep(entryFromInput1);\n\t\t\t\t\tentryFromInput2 = cloneDeep(entryFromInput2);\n\n\t\t\t\t\tskipFields.forEach((field) => {\n\t\t\t\t\t\tunset(entryFromInput1, field);\n\t\t\t\t\t\tunset(entryFromInput2, field);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet isItemsEqual = true;\n\t\t\tif (options.fuzzyCompare) {\n\t\t\t\tfor (const key of Object.keys(entryFromInput1)) {\n\t\t\t\t\tif (!isEntriesEqual(entryFromInput1[key], entryFromInput2[key])) {\n\t\t\t\t\t\tisItemsEqual = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisItemsEqual = isEntriesEqual(entryFromInput1, entryFromInput2);\n\t\t\t}\n\n\t\t\tif (isItemsEqual) {\n\t\t\t\tif (!entryCopy) {\n\t\t\t\t\tif (options.fuzzyCompare && options.resolve === 'preferInput2') {\n\t\t\t\t\t\tentryCopy = match;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tentryCopy = entryMatches.entry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (options.resolve) {\n\t\t\t\t\tcase 'preferInput1':\n\t\t\t\t\t\tdifferent.push(entryMatches.entry);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'preferInput2':\n\t\t\t\t\t\tdifferent.push(match);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mix':\n\t\t\t\t\t\tdifferent.push(\n\t\t\t\t\t\t\tcombineItems(\n\t\t\t\t\t\t\t\tentryMatches.entry,\n\t\t\t\t\t\t\t\tmatch,\n\t\t\t\t\t\t\t\toptions.preferWhenMix as string,\n\t\t\t\t\t\t\t\toptions.exceptWhenMix as string,\n\t\t\t\t\t\t\t\tdisableDotNotation,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tdifferent.push(\n\t\t\t\t\t\t\tcompareItems(\n\t\t\t\t\t\t\t\tentryMatches.entry,\n\t\t\t\t\t\t\t\tmatch,\n\t\t\t\t\t\t\t\tfieldsToMatch,\n\t\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\t\tskipFields,\n\t\t\t\t\t\t\t\tisEntriesEqual,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tif (!isEmpty(entryCopy)) {\n\t\t\tsame.push(entryCopy);\n\t\t}\n\t});\n\n\treturn [filteredData.unmatched1, same, different, filteredData.unmatched2];\n}\n\nexport function checkMatchFieldsInput(data: IDataObject[]) {\n\tif (data.length === 1 && data[0].field1 === '' && data[0].field2 === '') {\n\t\tthrow new ApplicationError(\n\t\t\t'You need to define at least one pair of fields in \"Fields to Match\" to match on',\n\t\t\t{ level: 'warning' },\n\t\t);\n\t}\n\tfor (const [index, pair] of data.entries()) {\n\t\tif (pair.field1 === '' || pair.field2 === '') {\n\t\t\tthrow new ApplicationError(\n\t\t\t\t`You need to define both fields in \"Fields to Match\" for pair ${index + 1},\n\t\t\t\t field 1 = '${pair.field1}'\n\t\t\t\t field 2 = '${pair.field2}'`,\n\t\t\t\t{ level: 'warning' },\n\t\t\t);\n\t\t}\n\t}\n\treturn data as PairToMatch[];\n}\n\nexport function checkInput(input: INodeExecutionData[]) {\n\tif (!input) return [];\n\tif (input.some((item) => isEmpty(item.json))) {\n\t\tinput = input.filter((item) => !isEmpty(item.json));\n\t}\n\treturn input;\n}\n\nexport function checkInputAndThrowError(\n\tinput: INodeExecutionData[],\n\tfields: string[],\n\tdisableDotNotation: boolean,\n\tinputLabel: string,\n) {\n\tif (input.some((item) => isEmpty(item.json))) {\n\t\tinput = input.filter((item) => !isEmpty(item.json));\n\t}\n\tif (input.length === 0) {\n\t\treturn input;\n\t}\n\tfor (const field of fields) {\n\t\tconst isPresent = (input || []).some((entry) => {\n\t\t\tif (disableDotNotation) {\n\t\t\t\treturn entry.json.hasOwnProperty(field);\n\t\t\t}\n\t\t\treturn get(entry.json, field, undefined) !== undefined;\n\t\t});\n\t\tif (!isPresent) {\n\t\t\tthrow new ApplicationError(\n\t\t\t\t`Field '${field}' is not present in any of items in '${inputLabel}'`,\n\t\t\t\t{ level: 'warning' },\n\t\t\t);\n\t\t}\n\t}\n\treturn input;\n}\n"],"mappings":"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","names":["union","intersection","difference","set","get","unset","isEmpty","omit"]}
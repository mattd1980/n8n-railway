{"version":3,"sources":["../../../nodes/RabbitMQ/GenericFunctions.ts"],"sourcesContent":["import * as amqplib from 'amqplib';\nimport type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tITriggerFunctions,\n} from 'n8n-workflow';\nimport { jsonParse, sleep } from 'n8n-workflow';\n\nimport { formatPrivateKey } from '@utils/utilities';\n\nimport type { ExchangeType, Options, RabbitMQCredentials, TriggerOptions } from './types';\n\nconst credentialKeys = ['hostname', 'port', 'username', 'password', 'vhost'] as const;\n\nexport async function rabbitmqConnect(\n\tcredentials: RabbitMQCredentials,\n): Promise<amqplib.Connection> {\n\tconst credentialData = credentialKeys.reduce((acc, key) => {\n\t\tacc[key] = credentials[key] === '' ? undefined : credentials[key];\n\t\treturn acc;\n\t}, {} as IDataObject) as amqplib.Options.Connect;\n\n\tconst optsData: IDataObject = {};\n\tif (credentials.ssl) {\n\t\tcredentialData.protocol = 'amqps';\n\n\t\toptsData.ca =\n\t\t\tcredentials.ca === '' ? undefined : [Buffer.from(formatPrivateKey(credentials.ca))];\n\t\tif (credentials.passwordless) {\n\t\t\toptsData.cert =\n\t\t\t\tcredentials.cert === '' ? undefined : Buffer.from(formatPrivateKey(credentials.cert));\n\t\t\toptsData.key =\n\t\t\t\tcredentials.key === '' ? undefined : Buffer.from(formatPrivateKey(credentials.key));\n\t\t\toptsData.passphrase = credentials.passphrase === '' ? undefined : credentials.passphrase;\n\t\t\toptsData.credentials = amqplib.credentials.external();\n\t\t}\n\t}\n\n\treturn await amqplib.connect(credentialData, optsData);\n}\n\nexport async function rabbitmqCreateChannel(\n\tthis: IExecuteFunctions | ITriggerFunctions,\n): Promise<amqplib.Channel> {\n\tconst credentials = await this.getCredentials<RabbitMQCredentials>('rabbitmq');\n\n\treturn await new Promise(async (resolve, reject) => {\n\t\ttry {\n\t\t\tconst connection = await rabbitmqConnect(credentials);\n\t\t\t// TODO: why is this error handler being added here?\n\t\t\tconnection.on('error', reject);\n\n\t\t\tconst channel = await connection.createChannel();\n\t\t\tresolve(channel);\n\t\t} catch (error) {\n\t\t\treject(error);\n\t\t}\n\t});\n}\n\nexport async function rabbitmqConnectQueue(\n\tthis: IExecuteFunctions | ITriggerFunctions,\n\tqueue: string,\n\toptions: Options | TriggerOptions,\n): Promise<amqplib.Channel> {\n\tconst channel = await rabbitmqCreateChannel.call(this);\n\n\treturn await new Promise(async (resolve, reject) => {\n\t\ttry {\n\t\t\tif (options.assertQueue) {\n\t\t\t\tawait channel.assertQueue(queue, options);\n\t\t\t} else {\n\t\t\t\tawait channel.checkQueue(queue);\n\t\t\t}\n\n\t\t\tif ('binding' in options && options.binding?.bindings.length) {\n\t\t\t\toptions.binding.bindings.forEach(async (binding) => {\n\t\t\t\t\tawait channel.bindQueue(queue, binding.exchange, binding.routingKey);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tresolve(channel);\n\t\t} catch (error) {\n\t\t\treject(error);\n\t\t}\n\t});\n}\n\nexport async function rabbitmqConnectExchange(\n\tthis: IExecuteFunctions | ITriggerFunctions,\n\texchange: string,\n\toptions: Options | TriggerOptions,\n): Promise<amqplib.Channel> {\n\tconst exchangeType = this.getNodeParameter('exchangeType', 0) as ExchangeType;\n\tconst channel = await rabbitmqCreateChannel.call(this);\n\n\treturn await new Promise(async (resolve, reject) => {\n\t\ttry {\n\t\t\tif (options.assertExchange) {\n\t\t\t\tawait channel.assertExchange(exchange, exchangeType, options);\n\t\t\t} else {\n\t\t\t\tawait channel.checkExchange(exchange);\n\t\t\t}\n\t\t\tresolve(channel);\n\t\t} catch (error) {\n\t\t\treject(error);\n\t\t}\n\t});\n}\n\nexport class MessageTracker {\n\tmessages: number[] = [];\n\n\tisClosing = false;\n\n\treceived(message: amqplib.ConsumeMessage) {\n\t\tthis.messages.push(message.fields.deliveryTag);\n\t}\n\n\tanswered(message: amqplib.ConsumeMessage) {\n\t\tif (this.messages.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst index = this.messages.findIndex((value) => value !== message.fields.deliveryTag);\n\t\tthis.messages.splice(index);\n\t}\n\n\tunansweredMessages() {\n\t\treturn this.messages.length;\n\t}\n\n\tasync closeChannel(channel: amqplib.Channel, consumerTag: string) {\n\t\tif (this.isClosing) {\n\t\t\treturn;\n\t\t}\n\t\tthis.isClosing = true;\n\n\t\t// Do not accept any new messages\n\t\tawait channel.cancel(consumerTag);\n\n\t\tlet count = 0;\n\t\tlet unansweredMessages = this.unansweredMessages();\n\n\t\t// Give currently executing messages max. 5 minutes to finish before\n\t\t// the channel gets closed. If we would not do that, it would not be possible\n\t\t// to acknowledge messages anymore for which the executions were already running\n\t\t// when for example a new version of the workflow got saved. That would lead to\n\t\t// them getting delivered and processed again.\n\t\twhile (unansweredMessages !== 0 && count++ <= 300) {\n\t\t\tawait sleep(1000);\n\t\t\tunansweredMessages = this.unansweredMessages();\n\t\t}\n\n\t\tawait channel.close();\n\t\tawait channel.connection.close();\n\t}\n}\n\nexport const parsePublishArguments = (options: Options) => {\n\tconst additionalArguments: IDataObject = {};\n\tif (options.arguments?.argument.length) {\n\t\toptions.arguments.argument.forEach((argument) => {\n\t\t\tadditionalArguments[argument.key] = argument.value;\n\t\t});\n\t}\n\treturn additionalArguments as amqplib.Options.Publish;\n};\n\nexport const parseMessage = async (\n\tmessage: amqplib.Message,\n\toptions: TriggerOptions,\n\thelpers: ITriggerFunctions['helpers'],\n): Promise<INodeExecutionData> => {\n\tif (options.contentIsBinary) {\n\t\tconst { content } = message;\n\t\tmessage.content = undefined as unknown as Buffer;\n\t\treturn {\n\t\t\tbinary: {\n\t\t\t\tdata: await helpers.prepareBinaryData(content),\n\t\t\t},\n\t\t\tjson: message as unknown as IDataObject,\n\t\t};\n\t} else {\n\t\tlet content: IDataObject | string = message.content.toString();\n\t\tif (options.jsonParseBody) {\n\t\t\tcontent = jsonParse(content);\n\t\t}\n\t\tif (options.onlyContent) {\n\t\t\treturn { json: content as IDataObject };\n\t\t} else {\n\t\t\tmessage.content = content as unknown as Buffer;\n\t\t\treturn { json: message as unknown as IDataObject };\n\t\t}\n\t}\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAAyB;AAOzB,0BAAiC;AAEjC,uBAAiC;AAIjC,MAAM,iBAAiB,CAAC,YAAY,QAAQ,YAAY,YAAY,OAAO;AAE3E,eAAsB,gBACrB,aAC8B;AAC9B,QAAM,iBAAiB,eAAe,OAAO,CAAC,KAAK,QAAQ;AAC1D,QAAI,GAAG,IAAI,YAAY,GAAG,MAAM,KAAK,SAAY,YAAY,GAAG;AAChE,WAAO;AAAA,EACR,GAAG,CAAC,CAAgB;AAEpB,QAAM,WAAwB,CAAC;AAC/B,MAAI,YAAY,KAAK;AACpB,mBAAe,WAAW;AAE1B,aAAS,KACR,YAAY,OAAO,KAAK,SAAY,CAAC,OAAO,SAAK,mCAAiB,YAAY,EAAE,CAAC,CAAC;AACnF,QAAI,YAAY,cAAc;AAC7B,eAAS,OACR,YAAY,SAAS,KAAK,SAAY,OAAO,SAAK,mCAAiB,YAAY,IAAI,CAAC;AACrF,eAAS,MACR,YAAY,QAAQ,KAAK,SAAY,OAAO,SAAK,mCAAiB,YAAY,GAAG,CAAC;AACnF,eAAS,aAAa,YAAY,eAAe,KAAK,SAAY,YAAY;AAC9E,eAAS,cAAc,QAAQ,YAAY,SAAS;AAAA,IACrD;AAAA,EACD;AAEA,SAAO,MAAM,QAAQ,QAAQ,gBAAgB,QAAQ;AACtD;AAEA,eAAsB,wBAEM;AAC3B,QAAM,cAAc,MAAM,KAAK,eAAoC,UAAU;AAE7E,SAAO,MAAM,IAAI,QAAQ,OAAO,SAAS,WAAW;AACnD,QAAI;AACH,YAAM,aAAa,MAAM,gBAAgB,WAAW;AAEpD,iBAAW,GAAG,SAAS,MAAM;AAE7B,YAAM,UAAU,MAAM,WAAW,cAAc;AAC/C,cAAQ,OAAO;AAAA,IAChB,SAAS,OAAO;AACf,aAAO,KAAK;AAAA,IACb;AAAA,EACD,CAAC;AACF;AAEA,eAAsB,qBAErB,OACA,SAC2B;AAC3B,QAAM,UAAU,MAAM,sBAAsB,KAAK,IAAI;AAErD,SAAO,MAAM,IAAI,QAAQ,OAAO,SAAS,WAAW;AACnD,QAAI;AACH,UAAI,QAAQ,aAAa;AACxB,cAAM,QAAQ,YAAY,OAAO,OAAO;AAAA,MACzC,OAAO;AACN,cAAM,QAAQ,WAAW,KAAK;AAAA,MAC/B;AAEA,UAAI,aAAa,WAAW,QAAQ,SAAS,SAAS,QAAQ;AAC7D,gBAAQ,QAAQ,SAAS,QAAQ,OAAO,YAAY;AACnD,gBAAM,QAAQ,UAAU,OAAO,QAAQ,UAAU,QAAQ,UAAU;AAAA,QACpE,CAAC;AAAA,MACF;AAEA,cAAQ,OAAO;AAAA,IAChB,SAAS,OAAO;AACf,aAAO,KAAK;AAAA,IACb;AAAA,EACD,CAAC;AACF;AAEA,eAAsB,wBAErB,UACA,SAC2B;AAC3B,QAAM,eAAe,KAAK,iBAAiB,gBAAgB,CAAC;AAC5D,QAAM,UAAU,MAAM,sBAAsB,KAAK,IAAI;AAErD,SAAO,MAAM,IAAI,QAAQ,OAAO,SAAS,WAAW;AACnD,QAAI;AACH,UAAI,QAAQ,gBAAgB;AAC3B,cAAM,QAAQ,eAAe,UAAU,cAAc,OAAO;AAAA,MAC7D,OAAO;AACN,cAAM,QAAQ,cAAc,QAAQ;AAAA,MACrC;AACA,cAAQ,OAAO;AAAA,IAChB,SAAS,OAAO;AACf,aAAO,KAAK;AAAA,IACb;AAAA,EACD,CAAC;AACF;AAEO,MAAM,eAAe;AAAA,EAArB;AACN,oBAAqB,CAAC;AAEtB,qBAAY;AAAA;AAAA,EAEZ,SAAS,SAAiC;AACzC,SAAK,SAAS,KAAK,QAAQ,OAAO,WAAW;AAAA,EAC9C;AAAA,EAEA,SAAS,SAAiC;AACzC,QAAI,KAAK,SAAS,WAAW,GAAG;AAC/B;AAAA,IACD;AAEA,UAAM,QAAQ,KAAK,SAAS,UAAU,CAAC,UAAU,UAAU,QAAQ,OAAO,WAAW;AACrF,SAAK,SAAS,OAAO,KAAK;AAAA,EAC3B;AAAA,EAEA,qBAAqB;AACpB,WAAO,KAAK,SAAS;AAAA,EACtB;AAAA,EAEA,MAAM,aAAa,SAA0B,aAAqB;AACjE,QAAI,KAAK,WAAW;AACnB;AAAA,IACD;AACA,SAAK,YAAY;AAGjB,UAAM,QAAQ,OAAO,WAAW;AAEhC,QAAI,QAAQ;AACZ,QAAI,qBAAqB,KAAK,mBAAmB;AAOjD,WAAO,uBAAuB,KAAK,WAAW,KAAK;AAClD,gBAAM,2BAAM,GAAI;AAChB,2BAAqB,KAAK,mBAAmB;AAAA,IAC9C;AAEA,UAAM,QAAQ,MAAM;AACpB,UAAM,QAAQ,WAAW,MAAM;AAAA,EAChC;AACD;AAEO,MAAM,wBAAwB,CAAC,YAAqB;AAC1D,QAAM,sBAAmC,CAAC;AAC1C,MAAI,QAAQ,WAAW,SAAS,QAAQ;AACvC,YAAQ,UAAU,SAAS,QAAQ,CAAC,aAAa;AAChD,0BAAoB,SAAS,GAAG,IAAI,SAAS;AAAA,IAC9C,CAAC;AAAA,EACF;AACA,SAAO;AACR;AAEO,MAAM,eAAe,OAC3B,SACA,SACA,YACiC;AACjC,MAAI,QAAQ,iBAAiB;AAC5B,UAAM,EAAE,QAAQ,IAAI;AACpB,YAAQ,UAAU;AAClB,WAAO;AAAA,MACN,QAAQ;AAAA,QACP,MAAM,MAAM,QAAQ,kBAAkB,OAAO;AAAA,MAC9C;AAAA,MACA,MAAM;AAAA,IACP;AAAA,EACD,OAAO;AACN,QAAI,UAAgC,QAAQ,QAAQ,SAAS;AAC7D,QAAI,QAAQ,eAAe;AAC1B,oBAAU,+BAAU,OAAO;AAAA,IAC5B;AACA,QAAI,QAAQ,aAAa;AACxB,aAAO,EAAE,MAAM,QAAuB;AAAA,IACvC,OAAO;AACN,cAAQ,UAAU;AAClB,aAAO,EAAE,MAAM,QAAkC;AAAA,IAClD;AAAA,EACD;AACD;","names":[]}
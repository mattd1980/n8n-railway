{"version":3,"sources":["../../../../nodes/SeaTable/v1/GenericFunctions.ts"],"sourcesContent":["import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tILoadOptionsFunctions,\n\tIPollFunctions,\n\tIRequestOptions,\n\tIHttpRequestMethods,\n\tJsonObject,\n} from 'n8n-workflow';\nimport { NodeApiError } from 'n8n-workflow';\n\nimport type {\n\tICredential,\n\tICtx,\n\tIDtableMetadataColumn,\n\tIEndpointVariables,\n\tIName,\n\tIRow,\n\tIRowObject,\n} from './Interfaces';\nimport { schema } from './Schema';\nimport type { TDtableMetadataColumns, TDtableViewColumns, TEndpointVariableName } from './types';\n\nconst userBaseUri = (uri?: string) => {\n\tif (uri === undefined) {\n\t\treturn uri;\n\t}\n\n\tif (uri.endsWith('/')) {\n\t\treturn uri.slice(0, -1);\n\t}\n\n\treturn uri;\n};\n\nexport function resolveBaseUri(ctx: ICtx) {\n\treturn ctx?.credentials?.environment === 'cloudHosted'\n\t\t? 'https://cloud.seatable.io'\n\t\t: userBaseUri(ctx?.credentials?.domain);\n}\n\nexport async function getBaseAccessToken(\n\tthis: IExecuteFunctions | ILoadOptionsFunctions | IPollFunctions,\n\tctx: ICtx,\n) {\n\tif (ctx?.base?.access_token !== undefined) {\n\t\treturn;\n\t}\n\n\tconst options: IRequestOptions = {\n\t\theaders: {\n\t\t\tAuthorization: `Token ${ctx?.credentials?.token}`,\n\t\t},\n\t\turi: `${resolveBaseUri(ctx)}/api/v2.1/dtable/app-access-token/`,\n\t\tjson: true,\n\t};\n\n\tctx.base = await this.helpers.request(options);\n}\n\nfunction endpointCtxExpr(ctx: ICtx, endpoint: string): string {\n\tconst endpointVariables: IEndpointVariables = {};\n\tendpointVariables.access_token = ctx?.base?.access_token;\n\tendpointVariables.dtable_uuid = ctx?.base?.dtable_uuid;\n\n\treturn endpoint.replace(\n\t\t/{{ *(access_token|dtable_uuid|server) *}}/g,\n\t\t(match: string, name: TEndpointVariableName) => {\n\t\t\treturn endpointVariables[name] || match;\n\t\t},\n\t);\n}\n\nexport async function seaTableApiRequest(\n\tthis: IExecuteFunctions | ILoadOptionsFunctions | IPollFunctions,\n\tctx: ICtx,\n\tmethod: IHttpRequestMethods,\n\tendpoint: string,\n\tbody: any = {},\n\tqs: IDataObject = {},\n\turl: string | undefined = undefined,\n\toption: IDataObject = {},\n): Promise<any> {\n\tconst credentials = await this.getCredentials('seaTableApi');\n\n\tctx.credentials = credentials as unknown as ICredential;\n\n\tawait getBaseAccessToken.call(this, ctx);\n\n\tconst options: IRequestOptions = {\n\t\theaders: {\n\t\t\tAuthorization: `Token ${ctx?.base?.access_token}`,\n\t\t},\n\t\tmethod,\n\t\tqs,\n\t\tbody,\n\t\turi: url || `${resolveBaseUri(ctx)}${endpointCtxExpr(ctx, endpoint)}`,\n\t\tjson: true,\n\t};\n\n\tif (Object.keys(body as IDataObject).length === 0) {\n\t\tdelete options.body;\n\t}\n\n\tif (Object.keys(option).length !== 0) {\n\t\tObject.assign(options, option);\n\t}\n\n\ttry {\n\t\treturn await this.helpers.request(options);\n\t} catch (error) {\n\t\tthrow new NodeApiError(this.getNode(), error as JsonObject);\n\t}\n}\n\nexport async function setableApiRequestAllItems(\n\tthis: IExecuteFunctions | IPollFunctions,\n\tctx: ICtx,\n\tpropertyName: string,\n\tmethod: IHttpRequestMethods,\n\tendpoint: string,\n\tbody: IDataObject,\n\tquery?: IDataObject,\n): Promise<any> {\n\tif (query === undefined) {\n\t\tquery = {};\n\t}\n\tconst segment = schema.rowFetchSegmentLimit;\n\tquery.start = 0;\n\tquery.limit = segment;\n\n\tconst returnData: IDataObject[] = [];\n\n\tlet responseData;\n\n\tdo {\n\t\tresponseData = (await seaTableApiRequest.call(\n\t\t\tthis,\n\t\t\tctx,\n\t\t\tmethod,\n\t\t\tendpoint,\n\t\t\tbody,\n\t\t\tquery,\n\t\t)) as unknown as IRow[];\n\t\t//@ts-ignore\n\t\treturnData.push.apply(returnData, responseData[propertyName] as IDataObject[]);\n\t\tquery.start = +query.start + segment;\n\t} while (responseData && responseData.length > segment - 1);\n\n\treturn returnData;\n}\n\nexport async function getTableColumns(\n\tthis: ILoadOptionsFunctions | IExecuteFunctions | IPollFunctions,\n\ttableName: string,\n\tctx: ICtx = {},\n): Promise<TDtableMetadataColumns> {\n\tconst {\n\t\tmetadata: { tables },\n\t} = await seaTableApiRequest.call(\n\t\tthis,\n\t\tctx,\n\t\t'GET',\n\t\t'/dtable-server/api/v1/dtables/{{dtable_uuid}}/metadata',\n\t);\n\tfor (const table of tables) {\n\t\tif (table.name === tableName) {\n\t\t\treturn table.columns;\n\t\t}\n\t}\n\treturn [];\n}\n\nexport async function getTableViews(\n\tthis: ILoadOptionsFunctions | IExecuteFunctions,\n\ttableName: string,\n\tctx: ICtx = {},\n): Promise<TDtableViewColumns> {\n\tconst { views } = await seaTableApiRequest.call(\n\t\tthis,\n\t\tctx,\n\t\t'GET',\n\t\t'/dtable-server/api/v1/dtables/{{dtable_uuid}}/views',\n\t\t{},\n\t\t{ table_name: tableName },\n\t);\n\treturn views;\n}\n\nexport function simplify(data: { results: IRow[] }, metadata: IDataObject) {\n\treturn data.results.map((row: IDataObject) => {\n\t\tfor (const key of Object.keys(row)) {\n\t\t\tif (!key.startsWith('_')) {\n\t\t\t\trow[metadata[key] as string] = row[key];\n\t\t\t\tdelete row[key];\n\t\t\t}\n\t\t}\n\t\treturn row;\n\t});\n}\n\nexport function getColumns(data: { metadata: [{ key: string; name: string }] }) {\n\treturn data.metadata.reduce(\n\t\t(obj, value) => Object.assign(obj, { [`${value.key}`]: value.name }),\n\t\t{},\n\t);\n}\n\nexport function getDownloadableColumns(data: {\n\tmetadata: [{ key: string; name: string; type: string }];\n}) {\n\treturn data.metadata.filter((row) => ['image', 'file'].includes(row.type)).map((row) => row.name);\n}\n\nconst uniquePredicate = (current: string, index: number, all: string[]) =>\n\tall.indexOf(current) === index;\nconst nonInternalPredicate = (name: string) => !Object.keys(schema.internalNames).includes(name);\nconst namePredicate = (name: string) => (named: IName) => named.name === name;\nexport const nameOfPredicate = (names: readonly IName[]) => (name: string) =>\n\tnames.find(namePredicate(name));\n\nconst normalize = (subject: string): string => (subject ? subject.normalize() : '');\n\nexport const split = (subject: string): string[] =>\n\tnormalize(subject)\n\t\t.split(/\\s*((?:[^\\\\,]*?(?:\\\\[\\s\\S])*)*?)\\s*(?:,|$)/)\n\t\t.filter((s) => s.length)\n\t\t.map((s) => s.replace(/\\\\([\\s\\S])/gm, (_, $1) => $1));\n\nexport function columnNamesToArray(columnNames: string): string[] {\n\treturn columnNames ? split(columnNames).filter(nonInternalPredicate).filter(uniquePredicate) : [];\n}\n\nexport function columnNamesGlob(\n\tcolumnNames: string[],\n\tdtableColumns: TDtableMetadataColumns,\n): string[] {\n\tconst buffer: string[] = [];\n\tconst names: string[] = dtableColumns.map((c) => c.name).filter(nonInternalPredicate);\n\tcolumnNames.forEach((columnName) => {\n\t\tif (columnName !== '*') {\n\t\t\tbuffer.push(columnName);\n\t\t\treturn;\n\t\t}\n\t\tbuffer.push(...names);\n\t});\n\treturn buffer.filter(uniquePredicate);\n}\n\n/**\n * sequence rows on _seq\n */\nexport function rowsSequence(rows: IRow[]) {\n\tconst l = rows.length;\n\tif (l) {\n\t\tconst [first] = rows;\n\t\tif (first?._seq !== undefined) {\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (let i = 0; i < l; ) {\n\t\trows[i]._seq = ++i;\n\t}\n}\n\nexport function rowDeleteInternalColumns(row: IRow): IRow {\n\tObject.keys(schema.internalNames).forEach((columnName) => delete row[columnName]);\n\treturn row;\n}\n\nfunction rowFormatColumn(input: unknown): boolean | number | string | string[] | null {\n\tif (null === input || undefined === input) {\n\t\treturn null;\n\t}\n\n\tif (typeof input === 'boolean' || typeof input === 'number' || typeof input === 'string') {\n\t\treturn input;\n\t}\n\n\tif (Array.isArray(input) && input.every((i) => typeof i === 'string')) {\n\t\treturn input;\n\t} else if (Array.isArray(input) && input.every((i) => typeof i === 'object')) {\n\t\tconst returnItems = [] as string[];\n\t\tinput.every((i) => returnItems.push(i.display_value as string));\n\t\treturn returnItems;\n\t}\n\n\treturn null;\n}\n\nexport function rowFormatColumns(row: IRow, columnNames: string[]): IRow {\n\tconst outRow = {} as IRow;\n\tcolumnNames.forEach((c) => (outRow[c] = rowFormatColumn(row[c])));\n\treturn outRow;\n}\n\nexport function rowsFormatColumns(rows: IRow[], columnNames: string[]) {\n\trows = rows.map((row) => rowFormatColumns(row, columnNames));\n}\n\nexport function rowMapKeyToName(row: IRow, columns: TDtableMetadataColumns): IRow {\n\tconst mappedRow = {} as IRow;\n\n\t// move internal columns first\n\tObject.keys(schema.internalNames).forEach((key) => {\n\t\tif (row[key]) {\n\t\t\tmappedRow[key] = row[key];\n\t\t\tdelete row[key];\n\t\t}\n\t});\n\n\t// pick each by its key for name\n\tObject.keys(row).forEach((key) => {\n\t\tconst column = columns.find((c) => c.key === key);\n\t\tif (column) {\n\t\t\tmappedRow[column.name] = row[key];\n\t\t}\n\t});\n\n\treturn mappedRow;\n}\n\nexport function rowExport(row: IRowObject, columns: TDtableMetadataColumns): IRowObject {\n\tfor (const columnName of Object.keys(columns)) {\n\t\tif (!columns.find(namePredicate(columnName))) {\n\t\t\tdelete row[columnName];\n\t\t}\n\t}\n\treturn row;\n}\n\nexport const dtableSchemaIsColumn = (column: IDtableMetadataColumn): boolean =>\n\t!!schema.columnTypes[column.type];\n\nconst dtableSchemaIsUpdateAbleColumn = (column: IDtableMetadataColumn): boolean =>\n\t!!schema.columnTypes[column.type] && !schema.nonUpdateAbleColumnTypes[column.type];\n\nexport const dtableSchemaColumns = (columns: TDtableMetadataColumns): TDtableMetadataColumns =>\n\tcolumns.filter(dtableSchemaIsColumn);\n\nexport const updateAble = (columns: TDtableMetadataColumns): TDtableMetadataColumns =>\n\tcolumns.filter(dtableSchemaIsUpdateAbleColumn);\n"],"mappings":"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","names":[]}
{"version":3,"sources":["../../../../nodes/Aws/Textract/GenericFunctions.ts"],"sourcesContent":["import type { Request } from 'aws4';\nimport { sign } from 'aws4';\nimport type {\n\tICredentialDataDecryptedObject,\n\tICredentialTestFunctions,\n\tIExecuteFunctions,\n\tIHookFunctions,\n\tILoadOptionsFunctions,\n\tIWebhookFunctions,\n\tIHttpRequestOptions,\n\tJsonObject,\n\tIHttpRequestMethods,\n\tIRequestOptions,\n} from 'n8n-workflow';\nimport { NodeApiError } from 'n8n-workflow';\nimport { URL } from 'url';\nimport { parseString } from 'xml2js';\n\nfunction getEndpointForService(\n\tservice: string,\n\tcredentials: ICredentialDataDecryptedObject,\n): string {\n\tlet endpoint;\n\tif (service === 'lambda' && credentials.lambdaEndpoint) {\n\t\tendpoint = credentials.lambdaEndpoint;\n\t} else if (service === 'sns' && credentials.snsEndpoint) {\n\t\tendpoint = credentials.snsEndpoint;\n\t} else {\n\t\tendpoint = `https://${service}.${credentials.region}.amazonaws.com`;\n\t}\n\treturn (endpoint as string).replace('{region}', credentials.region as string);\n}\n\nexport async function awsApiRequest(\n\tthis: IHookFunctions | IExecuteFunctions | ILoadOptionsFunctions | IWebhookFunctions,\n\tservice: string,\n\tmethod: IHttpRequestMethods,\n\tpath: string,\n\tbody?: string,\n\theaders?: object,\n): Promise<any> {\n\tconst credentials = await this.getCredentials('aws');\n\n\tconst requestOptions = {\n\t\tqs: {\n\t\t\tservice,\n\t\t\tpath,\n\t\t},\n\t\tmethod,\n\t\tbody,\n\t\turl: '',\n\t\theaders,\n\t\tregion: credentials?.region as string,\n\t} as IHttpRequestOptions;\n\n\ttry {\n\t\treturn await this.helpers.requestWithAuthentication.call(this, 'aws', requestOptions);\n\t} catch (error) {\n\t\tif (error?.response?.data || error?.response?.body) {\n\t\t\tconst errorMessage = error?.response?.data || error?.response?.body;\n\t\t\tif (errorMessage.includes('AccessDeniedException')) {\n\t\t\t\tconst user = JSON.parse(errorMessage as string).Message.split(' ')[1];\n\t\t\t\tthrow new NodeApiError(this.getNode(), error as JsonObject, {\n\t\t\t\t\tmessage: 'Unauthorized â€” please check your AWS policy configuration',\n\t\t\t\t\tdescription: `Make sure an identity-based policy allows user ${user} to perform textract:AnalyzeExpense`,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tthrow new NodeApiError(this.getNode(), error as JsonObject); // no XML parsing needed\n\t}\n}\n\nexport async function awsApiRequestREST(\n\tthis: IHookFunctions | IExecuteFunctions | ILoadOptionsFunctions,\n\tservice: string,\n\tmethod: IHttpRequestMethods,\n\tpath: string,\n\tbody?: string,\n\theaders?: object,\n): Promise<any> {\n\tconst response = await awsApiRequest.call(this, service, method, path, body, headers);\n\ttry {\n\t\treturn JSON.parse(response as string);\n\t} catch (error) {\n\t\treturn response;\n\t}\n}\n\nexport async function awsApiRequestSOAP(\n\tthis: IHookFunctions | IExecuteFunctions | ILoadOptionsFunctions | IWebhookFunctions,\n\tservice: string,\n\tmethod: IHttpRequestMethods,\n\tpath: string,\n\tbody?: string,\n\theaders?: object,\n): Promise<any> {\n\tconst response = await awsApiRequest.call(this, service, method, path, body, headers);\n\ttry {\n\t\treturn await new Promise((resolve, reject) => {\n\t\t\tparseString(response as string, { explicitArray: false }, (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn reject(err);\n\t\t\t\t}\n\t\t\t\tresolve(data);\n\t\t\t});\n\t\t});\n\t} catch (error) {\n\t\treturn response;\n\t}\n}\n\nexport function simplify(data: IExpenseDocument) {\n\tconst result: { [key: string]: string } = {};\n\tfor (const document of data.ExpenseDocuments) {\n\t\tfor (const field of document.SummaryFields) {\n\t\t\tresult[field?.Type?.Text || field?.LabelDetection?.Text] = field.ValueDetection.Text;\n\t\t}\n\t}\n\treturn result;\n}\n\nexport interface IExpenseDocument {\n\tExpenseDocuments: [\n\t\t{\n\t\t\tSummaryFields: [\n\t\t\t\t{\n\t\t\t\t\tLabelDetection: { Text: string };\n\t\t\t\t\tValueDetection: { Text: string };\n\t\t\t\t\tType: { Text: string };\n\t\t\t\t},\n\t\t\t];\n\t\t},\n\t];\n}\n\nexport async function validateCredentials(\n\tthis: ICredentialTestFunctions,\n\tdecryptedCredentials: ICredentialDataDecryptedObject,\n\tservice: string,\n): Promise<any> {\n\tconst credentials = decryptedCredentials;\n\n\t// Concatenate path and instantiate URL object so it parses correctly query strings\n\tconst endpoint = new URL(\n\t\tgetEndpointForService(service, credentials) + '?Action=GetCallerIdentity&Version=2011-06-15',\n\t);\n\n\t// Sign AWS API request with the user credentials\n\tconst signOpts = {\n\t\thost: endpoint.host,\n\t\tmethod: 'POST',\n\t\tpath: '?Action=GetCallerIdentity&Version=2011-06-15',\n\t} as Request;\n\tconst securityHeaders = {\n\t\taccessKeyId: `${credentials.accessKeyId}`.trim(),\n\t\tsecretAccessKey: `${credentials.secretAccessKey}`.trim(),\n\t\tsessionToken: credentials.temporaryCredentials\n\t\t\t? `${credentials.sessionToken}`.trim()\n\t\t\t: undefined,\n\t};\n\n\tsign(signOpts, securityHeaders);\n\n\tconst options: IRequestOptions = {\n\t\theaders: signOpts.headers,\n\t\tmethod: 'POST',\n\t\turi: endpoint.href,\n\t\tbody: signOpts.body,\n\t};\n\n\tconst response = await this.helpers.request(options);\n\n\treturn await new Promise((resolve, reject) => {\n\t\tparseString(response as string, { explicitArray: false }, (err, data) => {\n\t\t\tif (err) {\n\t\t\t\treturn reject(err);\n\t\t\t}\n\t\t\tresolve(data);\n\t\t});\n\t});\n}\n"],"mappings":"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","names":[]}
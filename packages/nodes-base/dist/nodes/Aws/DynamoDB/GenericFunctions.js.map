{"version":3,"sources":["../../../../nodes/Aws/DynamoDB/GenericFunctions.ts"],"sourcesContent":["import type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tIHookFunctions,\n\tILoadOptionsFunctions,\n\tIWebhookFunctions,\n\tIHttpRequestOptions,\n\tINodeExecutionData,\n\tIHttpRequestMethods,\n} from 'n8n-workflow';\nimport { ApplicationError, deepCopy } from 'n8n-workflow';\n\nimport type { IRequestBody } from './types';\n\nexport async function awsApiRequest(\n\tthis: IHookFunctions | IExecuteFunctions | ILoadOptionsFunctions | IWebhookFunctions,\n\tservice: string,\n\tmethod: IHttpRequestMethods,\n\tpath: string,\n\tbody?: object | IRequestBody,\n\theaders?: object,\n): Promise<any> {\n\tconst credentials = await this.getCredentials('aws');\n\tconst requestOptions = {\n\t\tqs: {\n\t\t\tservice,\n\t\t\tpath,\n\t\t},\n\t\tmethod,\n\t\tbody: JSON.stringify(body),\n\t\turl: '',\n\t\theaders,\n\t\tregion: credentials?.region as string,\n\t} as IHttpRequestOptions;\n\n\ttry {\n\t\treturn JSON.parse(\n\t\t\t(await this.helpers.requestWithAuthentication.call(this, 'aws', requestOptions)) as string,\n\t\t);\n\t} catch (error) {\n\t\tconst statusCode = (error.statusCode || error.cause?.statusCode) as number;\n\t\tlet errorMessage =\n\t\t\terror.response?.body?.message || error.response?.body?.Message || error.message;\n\n\t\tif (statusCode === 403) {\n\t\t\tif (errorMessage === 'The security token included in the request is invalid.') {\n\t\t\t\tthrow new ApplicationError('The AWS credentials are not valid!', { level: 'warning' });\n\t\t\t} else if (\n\t\t\t\terrorMessage.startsWith(\n\t\t\t\t\t'The request signature we calculated does not match the signature you provided',\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tthrow new ApplicationError('The AWS credentials are not valid!', { level: 'warning' });\n\t\t\t}\n\t\t}\n\n\t\tif (error.cause?.error) {\n\t\t\ttry {\n\t\t\t\terrorMessage = JSON.parse(error.cause?.error).message;\n\t\t\t} catch (ex) {}\n\t\t}\n\n\t\tthrow new ApplicationError(`AWS error response [${statusCode}]: ${errorMessage}`, {\n\t\t\tlevel: 'warning',\n\t\t});\n\t}\n}\n\nexport async function awsApiRequestAllItems(\n\tthis: IHookFunctions | IExecuteFunctions | ILoadOptionsFunctions | IWebhookFunctions,\n\tservice: string,\n\tmethod: IHttpRequestMethods,\n\tpath: string,\n\tbody?: IRequestBody,\n\theaders?: object,\n): Promise<any> {\n\tconst returnData: IDataObject[] = [];\n\n\tlet responseData;\n\n\tdo {\n\t\tconst originalHeaders = Object.assign({}, headers); //The awsapirequest function adds the hmac signature to the headers, if we pass the modified headers back in on the next call it will fail with invalid signature\n\t\tresponseData = await awsApiRequest.call(this, service, method, path, body, originalHeaders);\n\t\tif (responseData.LastEvaluatedKey) {\n\t\t\tbody!.ExclusiveStartKey = responseData.LastEvaluatedKey;\n\t\t}\n\t\treturnData.push(...(responseData.Items as IDataObject[]));\n\t} while (responseData.LastEvaluatedKey !== undefined);\n\n\treturn returnData;\n}\n\nexport function copyInputItem(item: INodeExecutionData, properties: string[]): IDataObject {\n\t// Prepare the data to insert and copy it to be returned\n\tconst newItem: IDataObject = {};\n\tfor (const property of properties) {\n\t\tif (item.json[property] === undefined) {\n\t\t\tnewItem[property] = null;\n\t\t} else {\n\t\t\tnewItem[property] = deepCopy(item.json[property]);\n\t\t}\n\t}\n\treturn newItem;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA,0BAA2C;AAI3C,eAAsB,cAErB,SACA,QACA,MACA,MACA,SACe;AACf,QAAM,cAAc,MAAM,KAAK,eAAe,KAAK;AACnD,QAAM,iBAAiB;AAAA,IACtB,IAAI;AAAA,MACH;AAAA,MACA;AAAA,IACD;AAAA,IACA;AAAA,IACA,MAAM,KAAK,UAAU,IAAI;AAAA,IACzB,KAAK;AAAA,IACL;AAAA,IACA,QAAQ,aAAa;AAAA,EACtB;AAEA,MAAI;AACH,WAAO,KAAK;AAAA,MACV,MAAM,KAAK,QAAQ,0BAA0B,KAAK,MAAM,OAAO,cAAc;AAAA,IAC/E;AAAA,EACD,SAAS,OAAO;AACf,UAAM,aAAc,MAAM,cAAc,MAAM,OAAO;AACrD,QAAI,eACH,MAAM,UAAU,MAAM,WAAW,MAAM,UAAU,MAAM,WAAW,MAAM;AAEzE,QAAI,eAAe,KAAK;AACvB,UAAI,iBAAiB,0DAA0D;AAC9E,cAAM,IAAI,qCAAiB,sCAAsC,EAAE,OAAO,UAAU,CAAC;AAAA,MACtF,WACC,aAAa;AAAA,QACZ;AAAA,MACD,GACC;AACD,cAAM,IAAI,qCAAiB,sCAAsC,EAAE,OAAO,UAAU,CAAC;AAAA,MACtF;AAAA,IACD;AAEA,QAAI,MAAM,OAAO,OAAO;AACvB,UAAI;AACH,uBAAe,KAAK,MAAM,MAAM,OAAO,KAAK,EAAE;AAAA,MAC/C,SAAS,IAAI;AAAA,MAAC;AAAA,IACf;AAEA,UAAM,IAAI,qCAAiB,uBAAuB,UAAU,MAAM,YAAY,IAAI;AAAA,MACjF,OAAO;AAAA,IACR,CAAC;AAAA,EACF;AACD;AAEA,eAAsB,sBAErB,SACA,QACA,MACA,MACA,SACe;AACf,QAAM,aAA4B,CAAC;AAEnC,MAAI;AAEJ,KAAG;AACF,UAAM,kBAAkB,OAAO,OAAO,CAAC,GAAG,OAAO;AACjD,mBAAe,MAAM,cAAc,KAAK,MAAM,SAAS,QAAQ,MAAM,MAAM,eAAe;AAC1F,QAAI,aAAa,kBAAkB;AAClC,WAAM,oBAAoB,aAAa;AAAA,IACxC;AACA,eAAW,KAAK,GAAI,aAAa,KAAuB;AAAA,EACzD,SAAS,aAAa,qBAAqB;AAE3C,SAAO;AACR;AAEO,SAAS,cAAc,MAA0B,YAAmC;AAE1F,QAAM,UAAuB,CAAC;AAC9B,aAAW,YAAY,YAAY;AAClC,QAAI,KAAK,KAAK,QAAQ,MAAM,QAAW;AACtC,cAAQ,QAAQ,IAAI;AAAA,IACrB,OAAO;AACN,cAAQ,QAAQ,QAAI,8BAAS,KAAK,KAAK,QAAQ,CAAC;AAAA,IACjD;AAAA,EACD;AACA,SAAO;AACR;","names":[]}
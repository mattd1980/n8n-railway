{"version":3,"sources":["../../../../nodes/SpreadsheetFile/v2/fromFile.operation.ts"],"sourcesContent":["import { parse as createCSVParser } from 'csv-parse';\nimport type { IExecuteFunctions, INodeExecutionData, INodeProperties } from 'n8n-workflow';\nimport { BINARY_ENCODING, NodeOperationError } from 'n8n-workflow';\nimport type { Sheet2JSONOpts, WorkBook, ParsingOptions } from 'xlsx';\nimport { read as xlsxRead, readFile as xlsxReadFile, utils as xlsxUtils } from 'xlsx';\n\nimport { binaryProperty, fromFileOptions } from '../description';\n\nexport const description: INodeProperties[] = [\n\tbinaryProperty,\n\t{\n\t\tdisplayName: 'File Format',\n\t\tname: 'fileFormat',\n\t\ttype: 'options',\n\t\toptions: [\n\t\t\t{\n\t\t\t\tname: 'Autodetect',\n\t\t\t\tvalue: 'autodetect',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'CSV',\n\t\t\t\tvalue: 'csv',\n\t\t\t\tdescription: 'Comma-separated values',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'HTML',\n\t\t\t\tvalue: 'html',\n\t\t\t\tdescription: 'HTML Table',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'ODS',\n\t\t\t\tvalue: 'ods',\n\t\t\t\tdescription: 'OpenDocument Spreadsheet',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'RTF',\n\t\t\t\tvalue: 'rtf',\n\t\t\t\tdescription: 'Rich Text Format',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'XLS',\n\t\t\t\tvalue: 'xls',\n\t\t\t\tdescription: 'Excel',\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'XLSX',\n\t\t\t\tvalue: 'xlsx',\n\t\t\t\tdescription: 'Excel',\n\t\t\t},\n\t\t],\n\t\tdefault: 'autodetect',\n\t\tdescription: 'The format of the binary data to read from',\n\t\tdisplayOptions: {\n\t\t\tshow: {\n\t\t\t\toperation: ['fromFile'],\n\t\t\t},\n\t\t},\n\t},\n\tfromFileOptions,\n];\n\nexport async function execute(\n\tthis: IExecuteFunctions,\n\titems: INodeExecutionData[],\n\tfileFormatProperty = 'fileFormat',\n) {\n\tconst returnData: INodeExecutionData[] = [];\n\tlet fileExtension;\n\tlet fileFormat;\n\n\tfor (let i = 0; i < items.length; i++) {\n\t\ttry {\n\t\t\tconst options = this.getNodeParameter('options', i, {});\n\t\t\tfileFormat = this.getNodeParameter(fileFormatProperty, i, '');\n\t\t\tconst binaryPropertyName = this.getNodeParameter('binaryPropertyName', i);\n\t\t\tconst binaryData = this.helpers.assertBinaryData(i, binaryPropertyName);\n\t\t\tfileExtension = binaryData.fileExtension;\n\n\t\t\tlet rows: unknown[] = [];\n\n\t\t\tif (\n\t\t\t\tfileFormat === 'autodetect' &&\n\t\t\t\t(binaryData.mimeType === 'text/csv' ||\n\t\t\t\t\t(binaryData.mimeType === 'text/plain' && binaryData.fileExtension === 'csv'))\n\t\t\t) {\n\t\t\t\tfileFormat = 'csv';\n\t\t\t}\n\n\t\t\tif (fileFormat === 'csv') {\n\t\t\t\tconst maxRowCount = options.maxRowCount as number;\n\t\t\t\tconst parser = createCSVParser({\n\t\t\t\t\tdelimiter: options.delimiter as string,\n\t\t\t\t\tfromLine: options.fromLine as number,\n\t\t\t\t\tencoding: options.encoding as BufferEncoding,\n\t\t\t\t\tbom: options.enableBOM as boolean,\n\t\t\t\t\tto: maxRowCount > -1 ? maxRowCount : undefined,\n\t\t\t\t\tcolumns: options.headerRow !== false,\n\t\t\t\t\trelax_quotes: options.relaxQuotes as boolean,\n\t\t\t\t\tonRecord: (record) => {\n\t\t\t\t\t\tif (!options.includeEmptyCells) {\n\t\t\t\t\t\t\trecord = Object.fromEntries(\n\t\t\t\t\t\t\t\tObject.entries(record).filter(([_key, value]) => value !== ''),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trows.push(record);\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t\tif (binaryData.id) {\n\t\t\t\t\tconst stream = await this.helpers.getBinaryStream(binaryData.id);\n\t\t\t\t\tawait new Promise<void>(async (resolve, reject) => {\n\t\t\t\t\t\tparser.on('error', reject);\n\t\t\t\t\t\tparser.on('readable', () => {\n\t\t\t\t\t\t\tstream.unpipe(parser);\n\t\t\t\t\t\t\tstream.destroy();\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tstream.pipe(parser);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tparser.write(binaryData.data, BINARY_ENCODING);\n\t\t\t\t\tparser.end();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet workbook: WorkBook;\n\t\t\t\tconst xlsxOptions: ParsingOptions = { raw: options.rawData as boolean };\n\t\t\t\tif (options.readAsString) xlsxOptions.type = 'string';\n\n\t\t\t\tif (binaryData.id) {\n\t\t\t\t\tconst binaryPath = this.helpers.getBinaryPath(binaryData.id);\n\t\t\t\t\tworkbook = xlsxReadFile(binaryPath, xlsxOptions);\n\t\t\t\t} else {\n\t\t\t\t\tconst binaryDataBuffer = Buffer.from(binaryData.data, BINARY_ENCODING);\n\t\t\t\t\tworkbook = xlsxRead(\n\t\t\t\t\t\toptions.readAsString ? binaryDataBuffer.toString() : binaryDataBuffer,\n\t\t\t\t\t\txlsxOptions,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (workbook.SheetNames.length === 0) {\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Spreadsheet does not have any sheets!', {\n\t\t\t\t\t\titemIndex: i,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tlet sheetName = workbook.SheetNames[0];\n\t\t\t\tif (options.sheetName) {\n\t\t\t\t\tif (!workbook.SheetNames.includes(options.sheetName as string)) {\n\t\t\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\t\t\tthis.getNode(),\n\t\t\t\t\t\t\t`Spreadsheet does not contain sheet called \"${options.sheetName}\"!`,\n\t\t\t\t\t\t\t{ itemIndex: i },\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tsheetName = options.sheetName as string;\n\t\t\t\t}\n\n\t\t\t\t// Convert it to json\n\t\t\t\tconst sheetToJsonOptions: Sheet2JSONOpts = {};\n\t\t\t\tif (options.range) {\n\t\t\t\t\tif (isNaN(options.range as number)) {\n\t\t\t\t\t\tsheetToJsonOptions.range = options.range;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsheetToJsonOptions.range = parseInt(options.range as string, 10);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (options.includeEmptyCells) {\n\t\t\t\t\tsheetToJsonOptions.defval = '';\n\t\t\t\t}\n\n\t\t\t\tif (options.headerRow === false) {\n\t\t\t\t\tsheetToJsonOptions.header = 1; // Consider the first row as a data row\n\t\t\t\t}\n\n\t\t\t\trows = xlsxUtils.sheet_to_json(workbook.Sheets[sheetName], sheetToJsonOptions);\n\n\t\t\t\t// Check if data could be found in file\n\t\t\t\tif (rows.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add all the found data columns to the workflow data\n\t\t\tif (options.headerRow === false) {\n\t\t\t\t// Data was returned as an array - https://github.com/SheetJS/sheetjs#json\n\t\t\t\tfor (const rowData of rows) {\n\t\t\t\t\treturnData.push({\n\t\t\t\t\t\tjson: {\n\t\t\t\t\t\t\trow: rowData,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tpairedItem: {\n\t\t\t\t\t\t\titem: i,\n\t\t\t\t\t\t},\n\t\t\t\t\t} as INodeExecutionData);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const rowData of rows) {\n\t\t\t\t\treturnData.push({\n\t\t\t\t\t\tjson: rowData,\n\t\t\t\t\t\tpairedItem: {\n\t\t\t\t\t\t\titem: i,\n\t\t\t\t\t\t},\n\t\t\t\t\t} as INodeExecutionData);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tlet errorDescription = error.description;\n\t\t\tif (fileExtension && fileExtension !== fileFormat) {\n\t\t\t\terror.message = `The file selected in 'Input Binary Field' is not in ${fileFormat} format`;\n\t\t\t\terrorDescription = `Try to change the operation or select a ${fileFormat} file in 'Input Binary Field'`;\n\t\t\t}\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturnData.push({\n\t\t\t\t\tjson: {\n\t\t\t\t\t\terror: error.message,\n\t\t\t\t\t},\n\t\t\t\t\tpairedItem: {\n\t\t\t\t\t\titem: i,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthrow new NodeOperationError(this.getNode(), error, {\n\t\t\t\titemIndex: i,\n\t\t\t\tdescription: errorDescription,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn returnData;\n}\n"],"mappings":"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","names":["createCSVParser","xlsxReadFile","xlsxRead","xlsxUtils"]}
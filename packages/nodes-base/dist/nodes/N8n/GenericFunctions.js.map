{"version":3,"sources":["../../../nodes/N8n/GenericFunctions.ts"],"sourcesContent":["import type {\n\tDeclarativeRestApiSettings,\n\tIDataObject,\n\tIExecuteFunctions,\n\tIExecutePaginationFunctions,\n\tIExecuteSingleFunctions,\n\tIHookFunctions,\n\tIHttpRequestMethods,\n\tIHttpRequestOptions,\n\tILoadOptionsFunctions,\n\tINodeExecutionData,\n\tIRequestOptions,\n\tJsonObject,\n\tPreSendAction,\n} from 'n8n-workflow';\nimport { NodeApiError, NodeOperationError } from 'n8n-workflow';\n\n/**\n * A custom API request function to be used with the resourceLocator lookup queries.\n */\nexport async function apiRequest(\n\tthis: IHookFunctions | IExecuteFunctions | ILoadOptionsFunctions,\n\tmethod: IHttpRequestMethods,\n\tendpoint: string,\n\tbody: object,\n\tquery?: IDataObject,\n): Promise<any> {\n\tquery = query || {};\n\n\ttype N8nApiCredentials = {\n\t\tapiKey: string;\n\t\tbaseUrl: string;\n\t};\n\n\tconst credentials = await this.getCredentials<N8nApiCredentials>('n8nApi');\n\tconst baseUrl = credentials.baseUrl;\n\n\tconst options: IRequestOptions = {\n\t\tmethod,\n\t\tbody,\n\t\tqs: query,\n\t\turi: `${baseUrl.replace(new RegExp('/$'), '')}/${endpoint}`,\n\t\tjson: true,\n\t};\n\n\ttry {\n\t\treturn await this.helpers.requestWithAuthentication.call(this, 'n8nApi', options);\n\t} catch (error) {\n\t\tif (error instanceof NodeApiError) {\n\t\t\tthrow error;\n\t\t}\n\t\tthrow new NodeApiError(this.getNode(), error as JsonObject);\n\t}\n}\n\nexport async function apiRequestAllItems(\n\tthis: IHookFunctions | IExecuteFunctions | ILoadOptionsFunctions,\n\tmethod: IHttpRequestMethods,\n\tendpoint: string,\n\tbody: object,\n\tquery?: IDataObject,\n): Promise<any> {\n\tquery = query || {};\n\tconst returnData: IDataObject[] = [];\n\n\tlet nextCursor: string | undefined = undefined;\n\tlet responseData;\n\n\tdo {\n\t\tquery.cursor = nextCursor;\n\t\tquery.limit = 100;\n\t\tresponseData = await apiRequest.call(this, method, endpoint, body, query);\n\t\treturnData.push.apply(returnData, responseData.data as IDataObject[]);\n\t\tnextCursor = responseData.nextCursor as string | undefined;\n\t} while (nextCursor);\n\treturn returnData;\n}\n\n/**\n * Get a cursor-based paginator to use with n8n 'getAll' type endpoints.\n *\n * It will look up a 'nextCursor' in the response and if the node has\n * 'returnAll' set to true, will consecutively include it as the 'cursor' query\n * parameter for the next request, effectively getting everything in slices.\n *\n * Prequisites:\n * - routing.send.paginate must be set to true, for all requests to go through here\n * - node is expected to have a boolean parameter 'returnAll'\n * - no postReceive action setting the rootProperty, to get the items mapped\n *\n * @returns A ready-to-use cursor-based paginator function.\n */\nexport const getCursorPaginator = () => {\n\treturn async function cursorPagination(\n\t\tthis: IExecutePaginationFunctions,\n\t\trequestOptions: DeclarativeRestApiSettings.ResultOptions,\n\t): Promise<INodeExecutionData[]> {\n\t\tif (!requestOptions.options.qs) {\n\t\t\trequestOptions.options.qs = {};\n\t\t}\n\n\t\tlet executions: INodeExecutionData[] = [];\n\t\tlet responseData: INodeExecutionData[];\n\t\tlet nextCursor: string | undefined = undefined;\n\t\tconst returnAll = this.getNodeParameter('returnAll', true) as boolean;\n\n\t\tconst extractItems = (page: INodeExecutionData) => {\n\t\t\tconst items = page.json.data as IDataObject[];\n\t\t\tif (items) {\n\t\t\t\t// Extract the items themselves\n\t\t\t\texecutions = executions.concat(items.map((item) => ({ json: item })));\n\t\t\t}\n\t\t};\n\n\t\tdo {\n\t\t\trequestOptions.options.qs.cursor = nextCursor;\n\t\t\tresponseData = await this.makeRoutingRequest(requestOptions);\n\n\t\t\t// Check for another page of items\n\t\t\tconst lastItem = responseData[responseData.length - 1].json;\n\t\t\tnextCursor = lastItem.nextCursor as string | undefined;\n\n\t\t\tresponseData.forEach(extractItems);\n\n\t\t\t// If we don't return all, just return the first page\n\t\t} while (returnAll && nextCursor);\n\n\t\treturn executions;\n\t};\n};\n\n/**\n * A helper function to parse a node parameter as JSON and set it in the request body.\n * Throws a NodeOperationError is the content is not valid JSON or it cannot be set.\n *\n * Currently, parameters with type 'json' are not validated automatically.\n * Also mapping the value for 'body.data' declaratively has it treated as a string,\n * but some operations (e.g. POST /credentials) don't work unless it is set as an object.\n * To get the JSON-body operations to work consistently, we need to parse and set the body\n * manually.\n *\n * @param parameterName The name of the node parameter to parse\n * @param setAsBodyProperty An optional property name to set the parsed data into\n * @returns The requestOptions with its body replaced with the contents of the parameter\n */\nexport const parseAndSetBodyJson = (\n\tparameterName: string,\n\tsetAsBodyProperty?: string,\n): PreSendAction => {\n\treturn async function (\n\t\tthis: IExecuteSingleFunctions,\n\t\trequestOptions: IHttpRequestOptions,\n\t): Promise<IHttpRequestOptions> {\n\t\ttry {\n\t\t\tconst rawData = this.getNodeParameter(parameterName, '{}') as string;\n\t\t\tconst parsedObject = JSON.parse(rawData);\n\n\t\t\t// Set the parsed object to either as the request body directly, or as its sub-property\n\t\t\tif (setAsBodyProperty === undefined) {\n\t\t\t\trequestOptions.body = parsedObject;\n\t\t\t} else {\n\t\t\t\trequestOptions.body = Object.assign({}, requestOptions.body, {\n\t\t\t\t\t[setAsBodyProperty]: parsedObject,\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.getNode(),\n\t\t\t\tnew Error(`The '${parameterName}' property must be valid JSON, but cannot be parsed`, {\n\t\t\t\t\tcause: err,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t\treturn requestOptions;\n\t};\n};\n\n/**\n * A helper function to prepare the workflow object data for creation. It only sets\n * known workflow properties, for pre-emptively avoiding a HTTP 400 Bad Request\n * response until we have a better client-side schema validation mechanism.\n *\n * NOTE! This expects the requestOptions.body to already be set as an object,\n * so take care to first call parseAndSetBodyJson().\n */\nexport const prepareWorkflowCreateBody: PreSendAction = async function (\n\tthis: IExecuteSingleFunctions,\n\trequestOptions: IHttpRequestOptions,\n): Promise<IHttpRequestOptions> {\n\tconst body = requestOptions.body as IDataObject;\n\tconst newBody: IDataObject = {};\n\n\tnewBody.name = body.name || 'My workflow';\n\tnewBody.nodes = body.nodes || [];\n\tnewBody.settings = body.settings || {};\n\tnewBody.connections = body.connections || {};\n\tnewBody.staticData = body.staticData || null;\n\n\trequestOptions.body = newBody;\n\n\treturn requestOptions;\n};\n\n/**\n * A helper function to prepare the workflow object data for update.\n *\n * NOTE! This expects the requestOptions.body to already be set as an object,\n * so take care to first call parseAndSetBodyJson().\n */\nexport const prepareWorkflowUpdateBody: PreSendAction = async function (\n\tthis: IExecuteSingleFunctions,\n\trequestOptions: IHttpRequestOptions,\n): Promise<IHttpRequestOptions> {\n\tconst body = requestOptions.body as IDataObject;\n\tconst newBody: IDataObject = {};\n\n\tif (body.name) {\n\t\tnewBody.name = body.name;\n\t}\n\tif (body.nodes) {\n\t\tnewBody.nodes = body.nodes;\n\t}\n\tif (body.settings) {\n\t\tnewBody.settings = body.settings;\n\t}\n\tif (body.connections) {\n\t\tnewBody.connections = body.connections;\n\t}\n\tif (body.staticData) {\n\t\tnewBody.staticData = body.staticData;\n\t}\n\n\trequestOptions.body = newBody;\n\n\treturn requestOptions;\n};\n"],"mappings":"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","names":[]}
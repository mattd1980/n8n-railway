{"version":3,"sources":["../../../../nodes/Microsoft/Sql/GenericFunctions.ts"],"sourcesContent":["import type { IResult } from 'mssql';\nimport mssql from 'mssql';\nimport type { IDataObject, INodeExecutionData } from 'n8n-workflow';\nimport { deepCopy } from 'n8n-workflow';\n\nimport { chunk, flatten } from '@utils/utilities';\n\nimport type { ITables, OperationInputData } from './interfaces';\n\n/**\n * Returns a copy of the item which only contains the json data and\n * of that only the defined properties\n *\n * @param {INodeExecutionData} item The item to copy\n * @param {string[]} properties The properties it should include\n */\nexport function copyInputItem(item: INodeExecutionData, properties: string[]): IDataObject {\n\t// Prepare the data to insert and copy it to be returned\n\tconst newItem: IDataObject = {};\n\tfor (const property of properties) {\n\t\tif (item.json[property] === undefined) {\n\t\t\tnewItem[property] = null;\n\t\t} else {\n\t\t\tnewItem[property] = deepCopy(item.json[property]);\n\t\t}\n\t}\n\treturn newItem;\n}\n\n/**\n * Creates an ITables with the columns for the operations\n *\n * @param {INodeExecutionData[]} items The items to extract the tables/columns for\n * @param {function} getNodeParam getter for the Node's Parameters\n */\nexport function createTableStruct(\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tgetNodeParam: Function,\n\titems: INodeExecutionData[],\n\tadditionalProperties: string[] = [],\n\tkeyName?: string,\n): ITables {\n\treturn items.reduce((tables, item, index) => {\n\t\tconst table = getNodeParam('table', index) as string;\n\t\tconst columnString = getNodeParam('columns', index) as string;\n\t\tconst columns = columnString.split(',').map((column) => column.trim());\n\t\tconst itemCopy = copyInputItem(item, columns.concat(additionalProperties));\n\t\tconst keyParam = keyName ? (getNodeParam(keyName, index) as string) : undefined;\n\t\tif (tables[table] === undefined) {\n\t\t\ttables[table] = {};\n\t\t}\n\t\tif (tables[table][columnString] === undefined) {\n\t\t\ttables[table][columnString] = [];\n\t\t}\n\t\tif (keyName) {\n\t\t\titemCopy[keyName] = keyParam;\n\t\t}\n\t\ttables[table][columnString].push(itemCopy);\n\t\treturn tables;\n\t}, {} as ITables);\n}\n\n/**\n * Executes a queue of queries on given ITables.\n *\n * @param {ITables} tables The ITables to be processed.\n * @param {function} buildQueryQueue function that builds the queue of promises\n */\nexport async function executeQueryQueue(\n\ttables: ITables,\n\tbuildQueryQueue: (data: OperationInputData) => Array<Promise<object>>,\n): Promise<any[]> {\n\treturn await Promise.all(\n\t\tObject.keys(tables).map(async (table) => {\n\t\t\tconst columnsResults = Object.keys(tables[table]).map(async (columnString) => {\n\t\t\t\treturn await Promise.all(\n\t\t\t\t\tbuildQueryQueue({\n\t\t\t\t\t\ttable,\n\t\t\t\t\t\tcolumnString,\n\t\t\t\t\t\titems: tables[table][columnString],\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t});\n\t\t\treturn await Promise.all(columnsResults);\n\t\t}),\n\t);\n}\n\nexport function formatColumns(columns: string) {\n\treturn columns\n\t\t.split(',')\n\t\t.map((column) => `[${column.trim()}]`)\n\t\t.join(', ');\n}\n\nexport function configurePool(credentials: IDataObject) {\n\tconst config = {\n\t\tserver: credentials.server as string,\n\t\tport: credentials.port as number,\n\t\tdatabase: credentials.database as string,\n\t\tuser: credentials.user as string,\n\t\tpassword: credentials.password as string,\n\t\tdomain: credentials.domain ? (credentials.domain as string) : undefined,\n\t\tconnectionTimeout: credentials.connectTimeout as number,\n\t\trequestTimeout: credentials.requestTimeout as number,\n\t\toptions: {\n\t\t\tencrypt: credentials.tls as boolean,\n\t\t\tenableArithAbort: false,\n\t\t\ttdsVersion: credentials.tdsVersion as string,\n\t\t\ttrustServerCertificate: credentials.allowUnauthorizedCerts as boolean,\n\t\t},\n\t};\n\n\treturn new mssql.ConnectionPool(config);\n}\n\nconst escapeTableName = (table: string) => {\n\ttable = table.trim();\n\tif (table.startsWith('[') && table.endsWith(']')) {\n\t\treturn table;\n\t} else {\n\t\treturn `[${table}]`;\n\t}\n};\n\nconst MSSQL_PARAMETER_LIMIT = 2100;\n\nexport function mssqlChunk(rows: IDataObject[]): IDataObject[][] {\n\tconst chunked: IDataObject[][] = [[]];\n\tlet currentParamCount = 0;\n\n\tfor (const row of rows) {\n\t\tconst rowValues = Object.values(row);\n\t\tconst valueCount = rowValues.length;\n\n\t\tif (currentParamCount + valueCount >= MSSQL_PARAMETER_LIMIT) {\n\t\t\tchunked.push([]);\n\t\t\tcurrentParamCount = 0;\n\t\t}\n\n\t\tchunked[chunked.length - 1].push(row);\n\n\t\tcurrentParamCount += valueCount;\n\t}\n\n\treturn chunked;\n}\n\nexport async function insertOperation(tables: ITables, pool: mssql.ConnectionPool) {\n\treturn await executeQueryQueue(\n\t\ttables,\n\t\t({ table, columnString, items }: OperationInputData): Array<Promise<object>> => {\n\t\t\treturn mssqlChunk(items).map(async (insertValues) => {\n\t\t\t\tconst request = pool.request();\n\n\t\t\t\tconst valuesPlaceholder = [];\n\n\t\t\t\tfor (const [rIndex, entry] of insertValues.entries()) {\n\t\t\t\t\tconst row = Object.values(entry);\n\t\t\t\t\tvaluesPlaceholder.push(`(${row.map((_, vIndex) => `@r${rIndex}v${vIndex}`).join(', ')})`);\n\t\t\t\t\tfor (const [vIndex, value] of row.entries()) {\n\t\t\t\t\t\trequest.input(`r${rIndex}v${vIndex}`, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst query = `INSERT INTO ${escapeTableName(table)} (${formatColumns(\n\t\t\t\t\tcolumnString,\n\t\t\t\t)}) VALUES ${valuesPlaceholder.join(', ')};`;\n\n\t\t\t\treturn await request.query(query);\n\t\t\t});\n\t\t},\n\t);\n}\n\nexport async function updateOperation(tables: ITables, pool: mssql.ConnectionPool) {\n\treturn await executeQueryQueue(\n\t\ttables,\n\t\t({ table, columnString, items }: OperationInputData): Array<Promise<object>> => {\n\t\t\treturn items.map(async (item) => {\n\t\t\t\tconst request = pool.request();\n\t\t\t\tconst columns = columnString.split(',').map((column) => column.trim());\n\n\t\t\t\tconst setValues: string[] = [];\n\t\t\t\tconst condition = `${item.updateKey} = @condition`;\n\t\t\t\trequest.input('condition', item[item.updateKey as string]);\n\n\t\t\t\tfor (const [index, col] of columns.entries()) {\n\t\t\t\t\tsetValues.push(`[${col}] = @v${index}`);\n\t\t\t\t\trequest.input(`v${index}`, item[col]);\n\t\t\t\t}\n\n\t\t\t\tconst query = `UPDATE ${escapeTableName(table)} SET ${setValues.join(\n\t\t\t\t\t', ',\n\t\t\t\t)} WHERE ${condition};`;\n\n\t\t\t\treturn await request.query(query);\n\t\t\t});\n\t\t},\n\t);\n}\n\nexport async function deleteOperation(tables: ITables, pool: mssql.ConnectionPool) {\n\tconst queriesResults = await Promise.all(\n\t\tObject.keys(tables).map(async (table) => {\n\t\t\tconst deleteKeyResults = Object.keys(tables[table]).map(async (deleteKey) => {\n\t\t\t\tconst deleteItemsList = chunk(\n\t\t\t\t\ttables[table][deleteKey].map((item) =>\n\t\t\t\t\t\tcopyInputItem(item as INodeExecutionData, [deleteKey]),\n\t\t\t\t\t),\n\t\t\t\t\t1000,\n\t\t\t\t);\n\t\t\t\tconst queryQueue = deleteItemsList.map(async (deleteValues) => {\n\t\t\t\t\tconst request = pool.request();\n\t\t\t\t\tconst valuesPlaceholder: string[] = [];\n\n\t\t\t\t\tfor (const [index, entry] of deleteValues.entries()) {\n\t\t\t\t\t\tvaluesPlaceholder.push(`@v${index}`);\n\t\t\t\t\t\trequest.input(`v${index}`, entry[deleteKey]);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst query = `DELETE FROM ${escapeTableName(\n\t\t\t\t\t\ttable,\n\t\t\t\t\t)} WHERE [${deleteKey}] IN (${valuesPlaceholder.join(', ')});`;\n\n\t\t\t\t\treturn await request.query(query);\n\t\t\t\t});\n\t\t\t\treturn await Promise.all(queryQueue);\n\t\t\t});\n\t\t\treturn await Promise.all(deleteKeyResults);\n\t\t}),\n\t);\n\n\treturn flatten(queriesResults).reduce(\n\t\t(acc: number, resp: mssql.IResult<object>): number =>\n\t\t\t(acc += resp.rowsAffected.reduce((sum, val) => (sum += val))),\n\t\t0,\n\t);\n}\n\nexport async function executeSqlQueryAndPrepareResults(\n\tpool: mssql.ConnectionPool,\n\trawQuery: string,\n\titemIndex: number,\n): Promise<INodeExecutionData[]> {\n\tconst rawResult: IResult<any> = await pool.request().query(rawQuery);\n\tconst { recordsets, rowsAffected } = rawResult;\n\tif (Array.isArray(recordsets) && recordsets.length > 0) {\n\t\tconst result: IDataObject[] = recordsets.length > 1 ? flatten(recordsets) : recordsets[0];\n\n\t\treturn result.map((entry) => ({\n\t\t\tjson: entry,\n\t\t\tpairedItem: [{ item: itemIndex }],\n\t\t}));\n\t} else if (rowsAffected && rowsAffected.length > 0) {\n\t\t// Handle non-SELECT queries (e.g., INSERT, UPDATE, DELETE)\n\t\treturn rowsAffected.map((affectedRows, idx) => ({\n\t\t\tjson: {\n\t\t\t\tmessage: `Query ${idx + 1} executed successfully`,\n\t\t\t\trowsAffected: affectedRows,\n\t\t\t},\n\t\t\tpairedItem: [{ item: itemIndex }],\n\t\t}));\n\t} else {\n\t\treturn [\n\t\t\t{\n\t\t\t\tjson: { message: 'Query executed successfully, but no rows were affected' },\n\t\t\t\tpairedItem: [{ item: itemIndex }],\n\t\t\t},\n\t\t];\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,mBAAkB;AAElB,0BAAyB;AAEzB,uBAA+B;AAWxB,SAAS,cAAc,MAA0B,YAAmC;AAE1F,QAAM,UAAuB,CAAC;AAC9B,aAAW,YAAY,YAAY;AAClC,QAAI,KAAK,KAAK,QAAQ,MAAM,QAAW;AACtC,cAAQ,QAAQ,IAAI;AAAA,IACrB,OAAO;AACN,cAAQ,QAAQ,QAAI,8BAAS,KAAK,KAAK,QAAQ,CAAC;AAAA,IACjD;AAAA,EACD;AACA,SAAO;AACR;AAQO,SAAS,kBAEf,cACA,OACA,uBAAiC,CAAC,GAClC,SACU;AACV,SAAO,MAAM,OAAO,CAAC,QAAQ,MAAM,UAAU;AAC5C,UAAM,QAAQ,aAAa,SAAS,KAAK;AACzC,UAAM,eAAe,aAAa,WAAW,KAAK;AAClD,UAAM,UAAU,aAAa,MAAM,GAAG,EAAE,IAAI,CAAC,WAAW,OAAO,KAAK,CAAC;AACrE,UAAM,WAAW,cAAc,MAAM,QAAQ,OAAO,oBAAoB,CAAC;AACzE,UAAM,WAAW,UAAW,aAAa,SAAS,KAAK,IAAe;AACtE,QAAI,OAAO,KAAK,MAAM,QAAW;AAChC,aAAO,KAAK,IAAI,CAAC;AAAA,IAClB;AACA,QAAI,OAAO,KAAK,EAAE,YAAY,MAAM,QAAW;AAC9C,aAAO,KAAK,EAAE,YAAY,IAAI,CAAC;AAAA,IAChC;AACA,QAAI,SAAS;AACZ,eAAS,OAAO,IAAI;AAAA,IACrB;AACA,WAAO,KAAK,EAAE,YAAY,EAAE,KAAK,QAAQ;AACzC,WAAO;AAAA,EACR,GAAG,CAAC,CAAY;AACjB;AAQA,eAAsB,kBACrB,QACA,iBACiB;AACjB,SAAO,MAAM,QAAQ;AAAA,IACpB,OAAO,KAAK,MAAM,EAAE,IAAI,OAAO,UAAU;AACxC,YAAM,iBAAiB,OAAO,KAAK,OAAO,KAAK,CAAC,EAAE,IAAI,OAAO,iBAAiB;AAC7E,eAAO,MAAM,QAAQ;AAAA,UACpB,gBAAgB;AAAA,YACf;AAAA,YACA;AAAA,YACA,OAAO,OAAO,KAAK,EAAE,YAAY;AAAA,UAClC,CAAC;AAAA,QACF;AAAA,MACD,CAAC;AACD,aAAO,MAAM,QAAQ,IAAI,cAAc;AAAA,IACxC,CAAC;AAAA,EACF;AACD;AAEO,SAAS,cAAc,SAAiB;AAC9C,SAAO,QACL,MAAM,GAAG,EACT,IAAI,CAAC,WAAW,IAAI,OAAO,KAAK,CAAC,GAAG,EACpC,KAAK,IAAI;AACZ;AAEO,SAAS,cAAc,aAA0B;AACvD,QAAM,SAAS;AAAA,IACd,QAAQ,YAAY;AAAA,IACpB,MAAM,YAAY;AAAA,IAClB,UAAU,YAAY;AAAA,IACtB,MAAM,YAAY;AAAA,IAClB,UAAU,YAAY;AAAA,IACtB,QAAQ,YAAY,SAAU,YAAY,SAAoB;AAAA,IAC9D,mBAAmB,YAAY;AAAA,IAC/B,gBAAgB,YAAY;AAAA,IAC5B,SAAS;AAAA,MACR,SAAS,YAAY;AAAA,MACrB,kBAAkB;AAAA,MAClB,YAAY,YAAY;AAAA,MACxB,wBAAwB,YAAY;AAAA,IACrC;AAAA,EACD;AAEA,SAAO,IAAI,aAAAA,QAAM,eAAe,MAAM;AACvC;AAEA,MAAM,kBAAkB,CAAC,UAAkB;AAC1C,UAAQ,MAAM,KAAK;AACnB,MAAI,MAAM,WAAW,GAAG,KAAK,MAAM,SAAS,GAAG,GAAG;AACjD,WAAO;AAAA,EACR,OAAO;AACN,WAAO,IAAI,KAAK;AAAA,EACjB;AACD;AAEA,MAAM,wBAAwB;AAEvB,SAAS,WAAW,MAAsC;AAChE,QAAM,UAA2B,CAAC,CAAC,CAAC;AACpC,MAAI,oBAAoB;AAExB,aAAW,OAAO,MAAM;AACvB,UAAM,YAAY,OAAO,OAAO,GAAG;AACnC,UAAM,aAAa,UAAU;AAE7B,QAAI,oBAAoB,cAAc,uBAAuB;AAC5D,cAAQ,KAAK,CAAC,CAAC;AACf,0BAAoB;AAAA,IACrB;AAEA,YAAQ,QAAQ,SAAS,CAAC,EAAE,KAAK,GAAG;AAEpC,yBAAqB;AAAA,EACtB;AAEA,SAAO;AACR;AAEA,eAAsB,gBAAgB,QAAiB,MAA4B;AAClF,SAAO,MAAM;AAAA,IACZ;AAAA,IACA,CAAC,EAAE,OAAO,cAAc,MAAM,MAAkD;AAC/E,aAAO,WAAW,KAAK,EAAE,IAAI,OAAO,iBAAiB;AACpD,cAAM,UAAU,KAAK,QAAQ;AAE7B,cAAM,oBAAoB,CAAC;AAE3B,mBAAW,CAAC,QAAQ,KAAK,KAAK,aAAa,QAAQ,GAAG;AACrD,gBAAM,MAAM,OAAO,OAAO,KAAK;AAC/B,4BAAkB,KAAK,IAAI,IAAI,IAAI,CAAC,GAAG,WAAW,KAAK,MAAM,IAAI,MAAM,EAAE,EAAE,KAAK,IAAI,CAAC,GAAG;AACxF,qBAAW,CAAC,QAAQ,KAAK,KAAK,IAAI,QAAQ,GAAG;AAC5C,oBAAQ,MAAM,IAAI,MAAM,IAAI,MAAM,IAAI,KAAK;AAAA,UAC5C;AAAA,QACD;AAEA,cAAM,QAAQ,eAAe,gBAAgB,KAAK,CAAC,KAAK;AAAA,UACvD;AAAA,QACD,CAAC,YAAY,kBAAkB,KAAK,IAAI,CAAC;AAEzC,eAAO,MAAM,QAAQ,MAAM,KAAK;AAAA,MACjC,CAAC;AAAA,IACF;AAAA,EACD;AACD;AAEA,eAAsB,gBAAgB,QAAiB,MAA4B;AAClF,SAAO,MAAM;AAAA,IACZ;AAAA,IACA,CAAC,EAAE,OAAO,cAAc,MAAM,MAAkD;AAC/E,aAAO,MAAM,IAAI,OAAO,SAAS;AAChC,cAAM,UAAU,KAAK,QAAQ;AAC7B,cAAM,UAAU,aAAa,MAAM,GAAG,EAAE,IAAI,CAAC,WAAW,OAAO,KAAK,CAAC;AAErE,cAAM,YAAsB,CAAC;AAC7B,cAAM,YAAY,GAAG,KAAK,SAAS;AACnC,gBAAQ,MAAM,aAAa,KAAK,KAAK,SAAmB,CAAC;AAEzD,mBAAW,CAAC,OAAO,GAAG,KAAK,QAAQ,QAAQ,GAAG;AAC7C,oBAAU,KAAK,IAAI,GAAG,SAAS,KAAK,EAAE;AACtC,kBAAQ,MAAM,IAAI,KAAK,IAAI,KAAK,GAAG,CAAC;AAAA,QACrC;AAEA,cAAM,QAAQ,UAAU,gBAAgB,KAAK,CAAC,QAAQ,UAAU;AAAA,UAC/D;AAAA,QACD,CAAC,UAAU,SAAS;AAEpB,eAAO,MAAM,QAAQ,MAAM,KAAK;AAAA,MACjC,CAAC;AAAA,IACF;AAAA,EACD;AACD;AAEA,eAAsB,gBAAgB,QAAiB,MAA4B;AAClF,QAAM,iBAAiB,MAAM,QAAQ;AAAA,IACpC,OAAO,KAAK,MAAM,EAAE,IAAI,OAAO,UAAU;AACxC,YAAM,mBAAmB,OAAO,KAAK,OAAO,KAAK,CAAC,EAAE,IAAI,OAAO,cAAc;AAC5E,cAAM,sBAAkB;AAAA,UACvB,OAAO,KAAK,EAAE,SAAS,EAAE;AAAA,YAAI,CAAC,SAC7B,cAAc,MAA4B,CAAC,SAAS,CAAC;AAAA,UACtD;AAAA,UACA;AAAA,QACD;AACA,cAAM,aAAa,gBAAgB,IAAI,OAAO,iBAAiB;AAC9D,gBAAM,UAAU,KAAK,QAAQ;AAC7B,gBAAM,oBAA8B,CAAC;AAErC,qBAAW,CAAC,OAAO,KAAK,KAAK,aAAa,QAAQ,GAAG;AACpD,8BAAkB,KAAK,KAAK,KAAK,EAAE;AACnC,oBAAQ,MAAM,IAAI,KAAK,IAAI,MAAM,SAAS,CAAC;AAAA,UAC5C;AAEA,gBAAM,QAAQ,eAAe;AAAA,YAC5B;AAAA,UACD,CAAC,WAAW,SAAS,SAAS,kBAAkB,KAAK,IAAI,CAAC;AAE1D,iBAAO,MAAM,QAAQ,MAAM,KAAK;AAAA,QACjC,CAAC;AACD,eAAO,MAAM,QAAQ,IAAI,UAAU;AAAA,MACpC,CAAC;AACD,aAAO,MAAM,QAAQ,IAAI,gBAAgB;AAAA,IAC1C,CAAC;AAAA,EACF;AAEA,aAAO,0BAAQ,cAAc,EAAE;AAAA,IAC9B,CAAC,KAAa,SACZ,OAAO,KAAK,aAAa,OAAO,CAAC,KAAK,QAAS,OAAO,GAAI;AAAA,IAC5D;AAAA,EACD;AACD;AAEA,eAAsB,iCACrB,MACA,UACA,WACgC;AAChC,QAAM,YAA0B,MAAM,KAAK,QAAQ,EAAE,MAAM,QAAQ;AACnE,QAAM,EAAE,YAAY,aAAa,IAAI;AACrC,MAAI,MAAM,QAAQ,UAAU,KAAK,WAAW,SAAS,GAAG;AACvD,UAAM,SAAwB,WAAW,SAAS,QAAI,0BAAQ,UAAU,IAAI,WAAW,CAAC;AAExF,WAAO,OAAO,IAAI,CAAC,WAAW;AAAA,MAC7B,MAAM;AAAA,MACN,YAAY,CAAC,EAAE,MAAM,UAAU,CAAC;AAAA,IACjC,EAAE;AAAA,EACH,WAAW,gBAAgB,aAAa,SAAS,GAAG;AAEnD,WAAO,aAAa,IAAI,CAAC,cAAc,SAAS;AAAA,MAC/C,MAAM;AAAA,QACL,SAAS,SAAS,MAAM,CAAC;AAAA,QACzB,cAAc;AAAA,MACf;AAAA,MACA,YAAY,CAAC,EAAE,MAAM,UAAU,CAAC;AAAA,IACjC,EAAE;AAAA,EACH,OAAO;AACN,WAAO;AAAA,MACN;AAAA,QACC,MAAM,EAAE,SAAS,yDAAyD;AAAA,QAC1E,YAAY,CAAC,EAAE,MAAM,UAAU,CAAC;AAAA,MACjC;AAAA,IACD;AAAA,EACD;AACD;","names":["mssql"]}
{"version":3,"sources":["../../../../nodes/Postgres/v1/genericFunctions.ts"],"sourcesContent":["import { ApplicationError } from 'n8n-workflow';\nimport type { IExecuteFunctions, IDataObject, INodeExecutionData, JsonObject } from 'n8n-workflow';\nimport type pgPromise from 'pg-promise';\nimport type pg from 'pg-promise/typescript/pg-subset';\n\nimport { getResolvables } from '@utils/utilities';\n\nimport type { PgpDatabase } from '../v2/helpers/interfaces';\n\n/**\n * Returns of a shallow copy of the items which only contains the json data and\n * of that only the define properties\n *\n * @param {INodeExecutionData[]} items The items to copy\n * @param {string[]} properties The properties it should include\n */\nexport function getItemsCopy(\n\titems: INodeExecutionData[],\n\tproperties: string[],\n\tguardedColumns?: { [key: string]: string },\n): IDataObject[] {\n\tlet newItem: IDataObject;\n\treturn items.map((item) => {\n\t\tnewItem = {};\n\t\tif (guardedColumns) {\n\t\t\tObject.keys(guardedColumns).forEach((column) => {\n\t\t\t\tnewItem[column] = item.json[guardedColumns[column]];\n\t\t\t});\n\t\t} else {\n\t\t\tfor (const property of properties) {\n\t\t\t\tnewItem[property] = item.json[property];\n\t\t\t}\n\t\t}\n\t\treturn newItem;\n\t});\n}\n\n/**\n * Returns of a shallow copy of the item which only contains the json data and\n * of that only the define properties\n *\n * @param {INodeExecutionData} item The item to copy\n * @param {string[]} properties The properties it should include\n */\nexport function getItemCopy(\n\titem: INodeExecutionData,\n\tproperties: string[],\n\tguardedColumns?: { [key: string]: string },\n): IDataObject {\n\tconst newItem: IDataObject = {};\n\tif (guardedColumns) {\n\t\tObject.keys(guardedColumns).forEach((column) => {\n\t\t\tnewItem[column] = item.json[guardedColumns[column]];\n\t\t});\n\t} else {\n\t\tfor (const property of properties) {\n\t\t\tnewItem[property] = item.json[property];\n\t\t}\n\t}\n\treturn newItem;\n}\n\n/**\n * Returns a returning clause from a comma separated string\n * @param {pgPromise.IMain<{}, pg.IClient>} pgp The pgPromise instance\n * @param string returning The comma separated string\n */\nexport function generateReturning(pgp: pgPromise.IMain<{}, pg.IClient>, returning: string): string {\n\treturn (\n\t\t' RETURNING ' +\n\t\treturning\n\t\t\t.split(',')\n\t\t\t.map((returnedField) => pgp.as.name(returnedField.trim()))\n\t\t\t.join(', ')\n\t);\n}\n\nexport function wrapData(data: IDataObject[]): INodeExecutionData[] {\n\tif (!Array.isArray(data)) {\n\t\treturn [{ json: data }];\n\t}\n\treturn data.map((item) => ({\n\t\tjson: item,\n\t}));\n}\n\n/**\n * Executes the given SQL query on the database.\n *\n * @param {Function} getNodeParam The getter for the Node's parameters\n * @param {pgPromise.IMain<{}, pg.IClient>} pgp The pgPromise instance\n * @param {PgpDatabase} db The pgPromise database connection\n * @param {input[]} input The Node's input data\n */\nexport async function pgQuery(\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tgetNodeParam: Function,\n\tpgp: pgPromise.IMain<{}, pg.IClient>,\n\tdb: PgpDatabase,\n\titems: INodeExecutionData[],\n\tcontinueOnFail: boolean,\n\toverrideMode?: string,\n): Promise<IDataObject[]> {\n\tconst additionalFields = getNodeParam('additionalFields', 0) as IDataObject;\n\n\tlet valuesArray = [] as string[][];\n\tif (additionalFields.queryParams) {\n\t\tconst propertiesString = additionalFields.queryParams as string;\n\t\tconst properties = propertiesString.split(',').map((column) => column.trim());\n\t\tconst paramsItems = getItemsCopy(items, properties);\n\t\tvaluesArray = paramsItems.map((row) => properties.map((col) => row[col])) as string[][];\n\t}\n\n\tconst allQueries = [] as Array<{ query: string; values?: string[] }>;\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst query = getNodeParam('query', i) as string;\n\t\tconst values = valuesArray[i];\n\t\tconst queryFormat = { query, values };\n\t\tallQueries.push(queryFormat);\n\t}\n\n\tconst mode = overrideMode ? overrideMode : ((additionalFields.mode ?? 'multiple') as string);\n\tif (mode === 'multiple') {\n\t\treturn (await db.multi(pgp.helpers.concat(allQueries))).flat(1);\n\t} else if (mode === 'transaction') {\n\t\treturn await db.tx(async (t) => {\n\t\t\tconst result: IDataObject[] = [];\n\t\t\tfor (let i = 0; i < allQueries.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tArray.prototype.push.apply(\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\tawait t.any(allQueries[i].query, allQueries[i].values),\n\t\t\t\t\t);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!continueOnFail) throw err;\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\t...items[i].json,\n\t\t\t\t\t\tcode: (err as JsonObject).code,\n\t\t\t\t\t\tmessage: (err as JsonObject).message,\n\t\t\t\t\t});\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t} else if (mode === 'independently') {\n\t\treturn await db.task(async (t) => {\n\t\t\tconst result: IDataObject[] = [];\n\t\t\tfor (let i = 0; i < allQueries.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tArray.prototype.push.apply(\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\tawait t.any(allQueries[i].query, allQueries[i].values),\n\t\t\t\t\t);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!continueOnFail) throw err;\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\t...items[i].json,\n\t\t\t\t\t\tcode: (err as JsonObject).code,\n\t\t\t\t\t\tmessage: (err as JsonObject).message,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\tthrow new ApplicationError('multiple, independently or transaction are valid options', {\n\t\tlevel: 'warning',\n\t});\n}\n\nexport async function pgQueryV2(\n\tthis: IExecuteFunctions,\n\tpgp: pgPromise.IMain<{}, pg.IClient>,\n\tdb: PgpDatabase,\n\titems: INodeExecutionData[],\n\tcontinueOnFail: boolean,\n\toptions?: {\n\t\toverrideMode?: string;\n\t\tresolveExpression?: boolean;\n\t},\n): Promise<IDataObject[]> {\n\tconst additionalFields = this.getNodeParameter('additionalFields', 0);\n\n\tlet valuesArray = [] as string[][];\n\tif (additionalFields.queryParams) {\n\t\tconst propertiesString = additionalFields.queryParams as string;\n\t\tconst properties = propertiesString.split(',').map((column) => column.trim());\n\t\tconst paramsItems = getItemsCopy(items, properties);\n\t\tvaluesArray = paramsItems.map((row) => properties.map((col) => row[col])) as string[][];\n\t}\n\n\ttype QueryWithValues = { query: string; values?: string[] };\n\tconst allQueries = new Array<QueryWithValues>();\n\tfor (let i = 0; i < items.length; i++) {\n\t\tlet query = this.getNodeParameter('query', i) as string;\n\n\t\tif (options?.resolveExpression) {\n\t\t\tfor (const resolvable of getResolvables(query)) {\n\t\t\t\tquery = query.replace(resolvable, this.evaluateExpression(resolvable, i) as string);\n\t\t\t}\n\t\t}\n\n\t\tconst values = valuesArray[i];\n\t\tconst queryFormat = { query, values };\n\t\tallQueries.push(queryFormat);\n\t}\n\n\tconst mode = options?.overrideMode\n\t\t? options.overrideMode\n\t\t: ((additionalFields.mode ?? 'multiple') as string);\n\tif (mode === 'multiple') {\n\t\treturn (await db.multi(pgp.helpers.concat(allQueries)))\n\t\t\t.map((result, i) => {\n\t\t\t\treturn this.helpers.constructExecutionMetaData(wrapData(result as IDataObject[]), {\n\t\t\t\t\titemData: { item: i },\n\t\t\t\t});\n\t\t\t})\n\t\t\t.flat();\n\t} else if (mode === 'transaction') {\n\t\treturn await db.tx(async (t) => {\n\t\t\tconst result: INodeExecutionData[] = [];\n\t\t\tfor (let i = 0; i < allQueries.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tconst transactionResult = await t.any(allQueries[i].query, allQueries[i].values);\n\t\t\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\t\t\twrapData(transactionResult as IDataObject[]),\n\t\t\t\t\t\t{ itemData: { item: i } },\n\t\t\t\t\t);\n\t\t\t\t\tresult.push(...executionData);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!continueOnFail) throw err;\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tjson: { ...items[i].json },\n\t\t\t\t\t\tcode: (err as JsonObject).code,\n\t\t\t\t\t\tmessage: (err as JsonObject).message,\n\t\t\t\t\t\tpairedItem: { item: i },\n\t\t\t\t\t} as INodeExecutionData);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t} else if (mode === 'independently') {\n\t\treturn await db.task(async (t) => {\n\t\t\tconst result: INodeExecutionData[] = [];\n\t\t\tfor (let i = 0; i < allQueries.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tconst transactionResult = await t.any(allQueries[i].query, allQueries[i].values);\n\t\t\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\t\t\twrapData(transactionResult as IDataObject[]),\n\t\t\t\t\t\t{ itemData: { item: i } },\n\t\t\t\t\t);\n\t\t\t\t\tresult.push(...executionData);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!continueOnFail) throw err;\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tjson: { ...items[i].json },\n\t\t\t\t\t\tcode: (err as JsonObject).code,\n\t\t\t\t\t\tmessage: (err as JsonObject).message,\n\t\t\t\t\t\tpairedItem: { item: i },\n\t\t\t\t\t} as INodeExecutionData);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\tthrow new ApplicationError('multiple, independently or transaction are valid options', {\n\t\tlevel: 'warning',\n\t});\n}\n\n/**\n * Inserts the given items into the database.\n *\n * @param {Function} getNodeParam The getter for the Node's parameters\n * @param {pgPromise.IMain<{}, pg.IClient>} pgp The pgPromise instance\n * @param {PgpDatabase} db The pgPromise database connection\n * @param {INodeExecutionData[]} items The items to be inserted\n */\nexport async function pgInsert(\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tgetNodeParam: Function,\n\tpgp: pgPromise.IMain<{}, pg.IClient>,\n\tdb: PgpDatabase,\n\titems: INodeExecutionData[],\n\tcontinueOnFail: boolean,\n\toverrideMode?: string,\n): Promise<IDataObject[]> {\n\tconst table = getNodeParam('table', 0) as string;\n\tconst schema = getNodeParam('schema', 0) as string;\n\tconst columnString = getNodeParam('columns', 0) as string;\n\tconst guardedColumns: { [key: string]: string } = {};\n\n\tconst columns = columnString\n\t\t.split(',')\n\t\t.map((column) => column.trim().split(':'))\n\t\t.map(([name, cast], i) => {\n\t\t\tguardedColumns[`column${i}`] = name;\n\t\t\treturn { name, cast, prop: `column${i}` };\n\t\t});\n\n\tconst columnNames = columns.map((column) => column.name);\n\n\tconst cs = new pgp.helpers.ColumnSet(columns, { table: { table, schema } });\n\n\tconst additionalFields = getNodeParam('additionalFields', 0) as IDataObject;\n\tconst mode = overrideMode ? overrideMode : ((additionalFields.mode ?? 'multiple') as string);\n\n\tconst returning = generateReturning(pgp, getNodeParam('returnFields', 0) as string);\n\tif (mode === 'multiple') {\n\t\tconst query =\n\t\t\tpgp.helpers.insert(getItemsCopy(items, columnNames, guardedColumns), cs) + returning;\n\t\treturn await db.any(query);\n\t} else if (mode === 'transaction') {\n\t\treturn await db.tx(async (t) => {\n\t\t\tconst result: IDataObject[] = [];\n\t\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\t\tconst itemCopy = getItemCopy(items[i], columnNames, guardedColumns);\n\t\t\t\ttry {\n\t\t\t\t\tresult.push(await t.one(pgp.helpers.insert(itemCopy, cs) + returning));\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!continueOnFail) throw err;\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\t...itemCopy,\n\t\t\t\t\t\tcode: (err as JsonObject).code,\n\t\t\t\t\t\tmessage: (err as JsonObject).message,\n\t\t\t\t\t});\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t} else if (mode === 'independently') {\n\t\treturn await db.task(async (t) => {\n\t\t\tconst result: IDataObject[] = [];\n\t\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\t\tconst itemCopy = getItemCopy(items[i], columnNames, guardedColumns);\n\t\t\t\ttry {\n\t\t\t\t\tconst insertResult = await t.oneOrNone(pgp.helpers.insert(itemCopy, cs) + returning);\n\t\t\t\t\tif (insertResult !== null) {\n\t\t\t\t\t\tresult.push(insertResult as IDataObject);\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!continueOnFail) {\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\t...itemCopy,\n\t\t\t\t\t\tcode: (err as JsonObject).code,\n\t\t\t\t\t\tmessage: (err as JsonObject).message,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tthrow new ApplicationError('multiple, independently or transaction are valid options', {\n\t\tlevel: 'warning',\n\t});\n}\n\n/**\n * Inserts the given items into the database.\n *\n * @param {Function} getNodeParam The getter for the Node's parameters\n * @param {pgPromise.IMain<{}, pg.IClient>} pgp The pgPromise instance\n * @param {PgpDatabase} db`` The pgPromise database connection\n * @param {INodeExecutionData[]} items The items to be inserted\n */\nexport async function pgInsertV2(\n\tthis: IExecuteFunctions,\n\tpgp: pgPromise.IMain<{}, pg.IClient>,\n\tdb: PgpDatabase,\n\titems: INodeExecutionData[],\n\tcontinueOnFail: boolean,\n\toverrideMode?: string,\n): Promise<IDataObject[]> {\n\tconst table = this.getNodeParameter('table', 0) as string;\n\tconst schema = this.getNodeParameter('schema', 0) as string;\n\tconst columnString = this.getNodeParameter('columns', 0) as string;\n\tconst guardedColumns: { [key: string]: string } = {};\n\n\tconst columns = columnString\n\t\t.split(',')\n\t\t.map((column) => column.trim().split(':'))\n\t\t.map(([name, cast], i) => {\n\t\t\tguardedColumns[`column${i}`] = name;\n\t\t\treturn { name, cast, prop: `column${i}` };\n\t\t});\n\n\tconst columnNames = columns.map((column) => column.name);\n\n\tconst cs = new pgp.helpers.ColumnSet(columns, { table: { table, schema } });\n\n\tconst additionalFields = this.getNodeParameter('additionalFields', 0);\n\tconst mode = overrideMode ? overrideMode : ((additionalFields.mode ?? 'multiple') as string);\n\n\tconst returning = generateReturning(pgp, this.getNodeParameter('returnFields', 0) as string);\n\tif (mode === 'multiple') {\n\t\tconst query =\n\t\t\tpgp.helpers.insert(getItemsCopy(items, columnNames, guardedColumns), cs) + returning;\n\t\tconst queryResult = await db.any(query);\n\t\treturn queryResult\n\t\t\t.map((result, i) => {\n\t\t\t\treturn this.helpers.constructExecutionMetaData(wrapData(result as IDataObject[]), {\n\t\t\t\t\titemData: { item: i },\n\t\t\t\t});\n\t\t\t})\n\t\t\t.flat();\n\t} else if (mode === 'transaction') {\n\t\treturn await db.tx(async (t) => {\n\t\t\tconst result: IDataObject[] = [];\n\t\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\t\tconst itemCopy = getItemCopy(items[i], columnNames, guardedColumns);\n\t\t\t\ttry {\n\t\t\t\t\tconst insertResult = await t.one(pgp.helpers.insert(itemCopy, cs) + returning);\n\t\t\t\t\tresult.push(\n\t\t\t\t\t\t...this.helpers.constructExecutionMetaData(wrapData(insertResult as IDataObject[]), {\n\t\t\t\t\t\t\titemData: { item: i },\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!continueOnFail) throw err;\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tjson: { ...itemCopy },\n\t\t\t\t\t\tcode: (err as JsonObject).code,\n\t\t\t\t\t\tmessage: (err as JsonObject).message,\n\t\t\t\t\t\tpairedItem: { item: i },\n\t\t\t\t\t} as INodeExecutionData);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t} else if (mode === 'independently') {\n\t\treturn await db.task(async (t) => {\n\t\t\tconst result: IDataObject[] = [];\n\t\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\t\tconst itemCopy = getItemCopy(items[i], columnNames, guardedColumns);\n\t\t\t\ttry {\n\t\t\t\t\tconst insertResult = await t.oneOrNone(pgp.helpers.insert(itemCopy, cs) + returning);\n\t\t\t\t\tif (insertResult !== null) {\n\t\t\t\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\t\t\t\twrapData(insertResult as IDataObject[]),\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\titemData: { item: i },\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresult.push(...executionData);\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!continueOnFail) {\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tjson: { ...itemCopy },\n\t\t\t\t\t\tcode: (err as JsonObject).code,\n\t\t\t\t\t\tmessage: (err as JsonObject).message,\n\t\t\t\t\t\tpairedItem: { item: i },\n\t\t\t\t\t} as INodeExecutionData);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tthrow new ApplicationError('multiple, independently or transaction are valid options', {\n\t\tlevel: 'warning',\n\t});\n}\n\n/**\n * Updates the given items in the database.\n *\n * @param {Function} getNodeParam The getter for the Node's parameters\n * @param {pgPromise.IMain<{}, pg.IClient>} pgp The pgPromise instance\n * @param {PgpDatabase} db The pgPromise database connection\n * @param {INodeExecutionData[]} items The items to be updated\n */\nexport async function pgUpdate(\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tgetNodeParam: Function,\n\tpgp: pgPromise.IMain<{}, pg.IClient>,\n\tdb: PgpDatabase,\n\titems: INodeExecutionData[],\n\tcontinueOnFail = false,\n): Promise<IDataObject[]> {\n\tconst table = getNodeParam('table', 0) as string;\n\tconst schema = getNodeParam('schema', 0) as string;\n\tconst updateKey = getNodeParam('updateKey', 0) as string;\n\tconst columnString = getNodeParam('columns', 0) as string;\n\tconst guardedColumns: { [key: string]: string } = {};\n\n\tconst columns: Array<{ name: string; cast: string; prop: string }> = columnString\n\t\t.split(',')\n\t\t.map((column) => column.trim().split(':'))\n\t\t.map(([name, cast], i) => {\n\t\t\tguardedColumns[`column${i}`] = name;\n\t\t\treturn { name, cast, prop: `column${i}` };\n\t\t});\n\n\tconst updateKeys = updateKey.split(',').map((key, i) => {\n\t\tconst [name, cast] = key.trim().split(':');\n\t\tconst targetCol = columns.find((column) => column.name === name);\n\t\tconst updateColumn = { name, cast, prop: targetCol ? targetCol.prop : `updateColumn${i}` };\n\t\tif (!targetCol) {\n\t\t\tguardedColumns[updateColumn.prop] = name;\n\t\t\tcolumns.unshift(updateColumn);\n\t\t} else if (!targetCol.cast) {\n\t\t\ttargetCol.cast = updateColumn.cast || targetCol.cast;\n\t\t}\n\t\treturn updateColumn;\n\t});\n\n\tconst additionalFields = getNodeParam('additionalFields', 0) as IDataObject;\n\tconst mode = additionalFields.mode ?? ('multiple' as string);\n\n\tconst cs = new pgp.helpers.ColumnSet(columns, { table: { table, schema } });\n\n\t// Prepare the data to update and copy it to be returned\n\tconst columnNames = columns.map((column) => column.name);\n\tconst updateItems = getItemsCopy(items, columnNames, guardedColumns);\n\n\tconst returning = generateReturning(pgp, getNodeParam('returnFields', 0) as string);\n\tif (mode === 'multiple') {\n\t\tconst query =\n\t\t\t(pgp.helpers.update(updateItems, cs) as string) +\n\t\t\t' WHERE ' +\n\t\t\tupdateKeys\n\t\t\t\t.map((entry) => {\n\t\t\t\t\tconst key = pgp.as.name(entry.name);\n\t\t\t\t\treturn 'v.' + key + ' = t.' + key;\n\t\t\t\t})\n\t\t\t\t.join(' AND ') +\n\t\t\treturning;\n\t\treturn await db.any(query);\n\t} else {\n\t\tconst where =\n\t\t\t' WHERE ' +\n\t\t\tupdateKeys\n\t\t\t\t// eslint-disable-next-line n8n-local-rules/no-interpolation-in-regular-string\n\t\t\t\t.map((entry) => pgp.as.name(entry.name) + ' = ${' + entry.prop + '}')\n\t\t\t\t.join(' AND ');\n\t\tif (mode === 'transaction') {\n\t\t\treturn await db.tx(async (t) => {\n\t\t\t\tconst result: IDataObject[] = [];\n\t\t\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\t\t\tconst itemCopy = getItemCopy(items[i], columnNames, guardedColumns);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tArray.prototype.push.apply(\n\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\tawait t.any(\n\t\t\t\t\t\t\t\t(pgp.helpers.update(itemCopy, cs) as string) +\n\t\t\t\t\t\t\t\t\tpgp.as.format(where, itemCopy) +\n\t\t\t\t\t\t\t\t\treturning,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tif (!continueOnFail) throw err;\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\t...itemCopy,\n\t\t\t\t\t\t\tcode: (err as JsonObject).code,\n\t\t\t\t\t\t\tmessage: (err as JsonObject).message,\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t});\n\t\t} else if (mode === 'independently') {\n\t\t\treturn await db.task(async (t) => {\n\t\t\t\tconst result: IDataObject[] = [];\n\t\t\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\t\t\tconst itemCopy = getItemCopy(items[i], columnNames, guardedColumns);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tArray.prototype.push.apply(\n\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\tawait t.any(\n\t\t\t\t\t\t\t\t(pgp.helpers.update(itemCopy, cs) as string) +\n\t\t\t\t\t\t\t\t\tpgp.as.format(where, itemCopy) +\n\t\t\t\t\t\t\t\t\treturning,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tif (!continueOnFail) throw err;\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\t...itemCopy,\n\t\t\t\t\t\t\tcode: (err as JsonObject).code,\n\t\t\t\t\t\t\tmessage: (err as JsonObject).message,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t});\n\t\t}\n\t}\n\tthrow new ApplicationError('multiple, independently or transaction are valid options', {\n\t\tlevel: 'warning',\n\t});\n}\n\n/**\n * Updates the given items in the database.\n *\n * @param {Function} getNodeParam The getter for the Node's parameters\n * @param {pgPromise.IMain<{}, pg.IClient>} pgp The pgPromise instance\n * @param {PgpDatabase} db The pgPromise database connection\n * @param {INodeExecutionData[]} items The items to be updated\n */\nexport async function pgUpdateV2(\n\tthis: IExecuteFunctions,\n\tpgp: pgPromise.IMain<{}, pg.IClient>,\n\tdb: PgpDatabase,\n\titems: INodeExecutionData[],\n\tcontinueOnFail = false,\n): Promise<IDataObject[]> {\n\tconst table = this.getNodeParameter('table', 0) as string;\n\tconst schema = this.getNodeParameter('schema', 0) as string;\n\tconst updateKey = this.getNodeParameter('updateKey', 0) as string;\n\tconst columnString = this.getNodeParameter('columns', 0) as string;\n\tconst guardedColumns: { [key: string]: string } = {};\n\n\tconst columns: Array<{ name: string; cast: string; prop: string }> = columnString\n\t\t.split(',')\n\t\t.map((column) => column.trim().split(':'))\n\t\t.map(([name, cast], i) => {\n\t\t\tguardedColumns[`column${i}`] = name;\n\t\t\treturn { name, cast, prop: `column${i}` };\n\t\t});\n\n\tconst updateKeys = updateKey.split(',').map((key, i) => {\n\t\tconst [name, cast] = key.trim().split(':');\n\t\tconst targetCol = columns.find((column) => column.name === name);\n\t\tconst updateColumn = { name, cast, prop: targetCol ? targetCol.prop : `updateColumn${i}` };\n\t\tif (!targetCol) {\n\t\t\tguardedColumns[updateColumn.prop] = name;\n\t\t\tcolumns.unshift(updateColumn);\n\t\t} else if (!targetCol.cast) {\n\t\t\ttargetCol.cast = updateColumn.cast || targetCol.cast;\n\t\t}\n\t\treturn updateColumn;\n\t});\n\n\tconst additionalFields = this.getNodeParameter('additionalFields', 0);\n\tconst mode = additionalFields.mode ?? ('multiple' as string);\n\n\tconst cs = new pgp.helpers.ColumnSet(columns, { table: { table, schema } });\n\n\t// Prepare the data to update and copy it to be returned\n\tconst columnNames = columns.map((column) => column.name);\n\tconst updateItems = getItemsCopy(items, columnNames, guardedColumns);\n\n\tconst returning = generateReturning(pgp, this.getNodeParameter('returnFields', 0) as string);\n\tif (mode === 'multiple') {\n\t\tconst query =\n\t\t\t(pgp.helpers.update(updateItems, cs) as string) +\n\t\t\t' WHERE ' +\n\t\t\tupdateKeys\n\t\t\t\t.map((entry) => {\n\t\t\t\t\tconst key = pgp.as.name(entry.name);\n\t\t\t\t\treturn 'v.' + key + ' = t.' + key;\n\t\t\t\t})\n\t\t\t\t.join(' AND ') +\n\t\t\treturning;\n\t\tconst updateResult = await db.any(query);\n\t\treturn updateResult;\n\t} else {\n\t\tconst where =\n\t\t\t' WHERE ' +\n\t\t\tupdateKeys\n\t\t\t\t// eslint-disable-next-line n8n-local-rules/no-interpolation-in-regular-string\n\t\t\t\t.map((entry) => pgp.as.name(entry.name) + ' = ${' + entry.prop + '}')\n\t\t\t\t.join(' AND ');\n\t\tif (mode === 'transaction') {\n\t\t\treturn await db.tx(async (t) => {\n\t\t\t\tconst result: IDataObject[] = [];\n\t\t\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\t\t\tconst itemCopy = getItemCopy(items[i], columnNames, guardedColumns);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst transactionResult = await t.any(\n\t\t\t\t\t\t\t(pgp.helpers.update(itemCopy, cs) as string) +\n\t\t\t\t\t\t\t\tpgp.as.format(where, itemCopy) +\n\t\t\t\t\t\t\t\treturning,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\t\t\t\twrapData(transactionResult as IDataObject[]),\n\t\t\t\t\t\t\t{ itemData: { item: i } },\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresult.push(...executionData);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tif (!continueOnFail) throw err;\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\t...itemCopy,\n\t\t\t\t\t\t\tcode: (err as JsonObject).code,\n\t\t\t\t\t\t\tmessage: (err as JsonObject).message,\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t});\n\t\t} else if (mode === 'independently') {\n\t\t\treturn await db.task(async (t) => {\n\t\t\t\tconst result: IDataObject[] = [];\n\t\t\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\t\t\tconst itemCopy = getItemCopy(items[i], columnNames, guardedColumns);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst independentResult = await t.any(\n\t\t\t\t\t\t\t(pgp.helpers.update(itemCopy, cs) as string) +\n\t\t\t\t\t\t\t\tpgp.as.format(where, itemCopy) +\n\t\t\t\t\t\t\t\treturning,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst executionData = this.helpers.constructExecutionMetaData(\n\t\t\t\t\t\t\twrapData(independentResult as IDataObject[]),\n\t\t\t\t\t\t\t{ itemData: { item: i } },\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresult.push(...executionData);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tif (!continueOnFail) throw err;\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\tjson: { ...items[i].json },\n\t\t\t\t\t\t\tcode: (err as JsonObject).code,\n\t\t\t\t\t\t\tmessage: (err as JsonObject).message,\n\t\t\t\t\t\t\tpairedItem: { item: i },\n\t\t\t\t\t\t} as INodeExecutionData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t});\n\t\t}\n\t}\n\tthrow new ApplicationError('multiple, independently or transaction are valid options', {\n\t\tlevel: 'warning',\n\t});\n}\n"],"mappings":"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","names":[]}
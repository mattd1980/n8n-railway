{"version":3,"sources":["../../utils/connection-pool-manager.ts"],"sourcesContent":["import { createHash } from 'crypto';\n\nlet instance: ConnectionPoolManager;\n\n// 5 minutes\nconst ttl = 5 * 60 * 1000;\n\n// 1 minute\nconst cleanUpInterval = 60 * 1000;\n\ntype RegistrationOptions = {\n\tcredentials: unknown;\n\tnodeType: string;\n\tnodeVersion?: string;\n};\n\ntype GetConnectionOption<Pool> = RegistrationOptions & {\n\t/** When a node requests for a connection pool, but none is available, this handler is called to create new instance of the pool, which then cached and re-used until it goes stale.  */\n\tfallBackHandler: () => Promise<Pool>;\n\n\t/** When a pool hasn't been used in a while, or when the server is shutting down, this handler is invoked to close the pool */\n\tcleanUpHandler: (pool: Pool) => Promise<void>;\n};\n\ntype Registration<Pool> = {\n\t/** This is an instance of a Connection Pool class, that gets reused across multiple executions */\n\tpool: Pool;\n\n\t/** @see GetConnectionOption['closeHandler'] */\n\tcleanUpHandler: (pool: Pool) => Promise<void>;\n\n\t/** We keep this timestamp to check if a pool hasn't been used in a while, and if it needs to be closed */\n\tlastUsed: number;\n};\n\nexport class ConnectionPoolManager {\n\t/**\n\t * Gets the singleton instance of the ConnectionPoolManager.\n\t * Creates a new instance if one doesn't exist.\n\t */\n\tstatic getInstance(): ConnectionPoolManager {\n\t\tif (!instance) {\n\t\t\tinstance = new ConnectionPoolManager();\n\t\t}\n\t\treturn instance;\n\t}\n\n\tprivate map = new Map<string, Registration<unknown>>();\n\n\t/**\n\t * Private constructor that initializes the connection pool manager.\n\t * Sets up cleanup handlers for process exit and stale connections.\n\t */\n\tprivate constructor() {\n\t\t// Close all open pools when the process exits\n\t\tprocess.on('exit', () => this.onShutdown());\n\n\t\t// Regularly close stale pools\n\t\tsetInterval(() => this.cleanupStaleConnections(), cleanUpInterval);\n\t}\n\n\t/**\n\t * Generates a unique key for connection pool identification.\n\t * Hashes the credentials and node information for security.\n\t */\n\tprivate makeKey({ credentials, nodeType, nodeVersion }: RegistrationOptions): string {\n\t\t// The credential contains decrypted secrets, that's why we hash it.\n\t\treturn createHash('sha1')\n\t\t\t.update(\n\t\t\t\tJSON.stringify({\n\t\t\t\t\tcredentials,\n\t\t\t\t\tnodeType,\n\t\t\t\t\tnodeVersion,\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.digest('base64');\n\t}\n\n\t/**\n\t * Gets or creates a connection pool for the given options.\n\t * Updates the last used timestamp for existing connections.\n\t */\n\tasync getConnection<T>(options: GetConnectionOption<T>): Promise<T> {\n\t\tconst key = this.makeKey(options);\n\n\t\tlet value = this.map.get(key);\n\t\tif (!value) {\n\t\t\tvalue = {\n\t\t\t\tpool: await options.fallBackHandler(),\n\t\t\t\tcleanUpHandler: options.cleanUpHandler,\n\t\t\t} as Registration<unknown>;\n\t\t}\n\n\t\tthis.map.set(key, { ...value, lastUsed: Date.now() });\n\t\treturn value.pool as T;\n\t}\n\n\t/**\n\t * Removes and cleans up connection pools that haven't been used within the\n\t * TTL.\n\t */\n\tprivate cleanupStaleConnections() {\n\t\tconst now = Date.now();\n\t\tfor (const [key, { cleanUpHandler, lastUsed, pool }] of this.map.entries()) {\n\t\t\tif (now - lastUsed > ttl) {\n\t\t\t\tvoid cleanUpHandler(pool);\n\t\t\t\tthis.map.delete(key);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes and cleans up all existing connection pools.\n\t */\n\tasync purgeConnections(): Promise<void> {\n\t\tawait Promise.all(\n\t\t\t[...this.map.entries()].map(async ([key, value]) => {\n\t\t\t\tthis.map.delete(key);\n\n\t\t\t\treturn await value.cleanUpHandler(value.pool);\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * Cleans up all connection pools when the process is shutting down.\n\t * Does not wait for cleanup promises to resolve also does not remove the\n\t * references from the pool.\n\t *\n\t * Only call this on process shutdown.\n\t */\n\tonShutdown() {\n\t\tfor (const { cleanUpHandler, pool } of this.map.values()) {\n\t\t\tvoid cleanUpHandler(pool);\n\t\t}\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAA2B;AAE3B,IAAI;AAGJ,MAAM,MAAM,IAAI,KAAK;AAGrB,MAAM,kBAAkB,KAAK;AA2BtB,MAAM,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA,EAkB1B,cAAc;AANtB,SAAQ,MAAM,oBAAI,IAAmC;AAQpD,YAAQ,GAAG,QAAQ,MAAM,KAAK,WAAW,CAAC;AAG1C,gBAAY,MAAM,KAAK,wBAAwB,GAAG,eAAe;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA;AAAA,EAnBA,OAAO,cAAqC;AAC3C,QAAI,CAAC,UAAU;AACd,iBAAW,IAAI,sBAAsB;AAAA,IACtC;AACA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA,EAoBQ,QAAQ,EAAE,aAAa,UAAU,YAAY,GAAgC;AAEpF,eAAO,0BAAW,MAAM,EACtB;AAAA,MACA,KAAK,UAAU;AAAA,QACd;AAAA,QACA;AAAA,QACA;AAAA,MACD,CAAC;AAAA,IACF,EACC,OAAO,QAAQ;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,cAAiB,SAA6C;AACnE,UAAM,MAAM,KAAK,QAAQ,OAAO;AAEhC,QAAI,QAAQ,KAAK,IAAI,IAAI,GAAG;AAC5B,QAAI,CAAC,OAAO;AACX,cAAQ;AAAA,QACP,MAAM,MAAM,QAAQ,gBAAgB;AAAA,QACpC,gBAAgB,QAAQ;AAAA,MACzB;AAAA,IACD;AAEA,SAAK,IAAI,IAAI,KAAK,EAAE,GAAG,OAAO,UAAU,KAAK,IAAI,EAAE,CAAC;AACpD,WAAO,MAAM;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,0BAA0B;AACjC,UAAM,MAAM,KAAK,IAAI;AACrB,eAAW,CAAC,KAAK,EAAE,gBAAgB,UAAU,KAAK,CAAC,KAAK,KAAK,IAAI,QAAQ,GAAG;AAC3E,UAAI,MAAM,WAAW,KAAK;AACzB,aAAK,eAAe,IAAI;AACxB,aAAK,IAAI,OAAO,GAAG;AAAA,MACpB;AAAA,IACD;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBAAkC;AACvC,UAAM,QAAQ;AAAA,MACb,CAAC,GAAG,KAAK,IAAI,QAAQ,CAAC,EAAE,IAAI,OAAO,CAAC,KAAK,KAAK,MAAM;AACnD,aAAK,IAAI,OAAO,GAAG;AAEnB,eAAO,MAAM,MAAM,eAAe,MAAM,IAAI;AAAA,MAC7C,CAAC;AAAA,IACF;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,aAAa;AACZ,eAAW,EAAE,gBAAgB,KAAK,KAAK,KAAK,IAAI,OAAO,GAAG;AACzD,WAAK,eAAe,IAAI;AAAA,IACzB;AAAA,EACD;AACD;","names":[]}
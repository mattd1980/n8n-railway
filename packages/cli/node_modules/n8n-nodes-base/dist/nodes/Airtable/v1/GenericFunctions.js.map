{"version":3,"sources":["../../../../nodes/Airtable/v1/GenericFunctions.ts"],"sourcesContent":["import type {\n\tIBinaryKeyData,\n\tIDataObject,\n\tIExecuteFunctions,\n\tIPollFunctions,\n\tILoadOptionsFunctions,\n\tINodeExecutionData,\n\tIPairedItemData,\n\tIRequestOptions,\n\tIHttpRequestMethods,\n} from 'n8n-workflow';\n\ninterface IAttachment {\n\turl: string;\n\tfilename: string;\n\ttype: string;\n}\n\nexport interface IRecord {\n\tfields: {\n\t\t[key: string]: string | IAttachment[];\n\t};\n}\n\n/**\n * Make an API request to Airtable\n *\n */\nexport async function apiRequest(\n\tthis: IExecuteFunctions | ILoadOptionsFunctions | IPollFunctions,\n\tmethod: IHttpRequestMethods,\n\tendpoint: string,\n\tbody: object,\n\tquery?: IDataObject,\n\turi?: string,\n\toption: IDataObject = {},\n): Promise<any> {\n\tquery = query || {};\n\n\t// For some reason for some endpoints the bearer auth does not work\n\t// and it returns 404 like for the /meta request. So we always send\n\t// it as query string.\n\t// query.api_key = credentials.apiKey;\n\n\tconst options: IRequestOptions = {\n\t\theaders: {},\n\t\tmethod,\n\t\tbody,\n\t\tqs: query,\n\t\turi: uri || `https://api.airtable.com/v0/${endpoint}`,\n\t\tuseQuerystring: false,\n\t\tjson: true,\n\t};\n\n\tif (Object.keys(option).length !== 0) {\n\t\tObject.assign(options, option);\n\t}\n\n\tif (Object.keys(body).length === 0) {\n\t\tdelete options.body;\n\t}\n\tconst authenticationMethod = this.getNodeParameter('authentication', 0) as string;\n\treturn await this.helpers.requestWithAuthentication.call(this, authenticationMethod, options);\n}\n\n/**\n * Make an API request to paginated Airtable endpoint\n * and return all results\n *\n * @param {(IExecuteFunctions | IExecuteFunctions)} this\n */\nexport async function apiRequestAllItems(\n\tthis: IExecuteFunctions | ILoadOptionsFunctions | IPollFunctions,\n\tmethod: IHttpRequestMethods,\n\tendpoint: string,\n\tbody: IDataObject,\n\tquery?: IDataObject,\n): Promise<any> {\n\tif (query === undefined) {\n\t\tquery = {};\n\t}\n\tquery.pageSize = 100;\n\n\tconst returnData: IDataObject[] = [];\n\n\tlet responseData;\n\n\tdo {\n\t\tresponseData = await apiRequest.call(this, method, endpoint, body, query);\n\t\treturnData.push.apply(returnData, responseData.records as IDataObject[]);\n\n\t\tquery.offset = responseData.offset;\n\t} while (responseData.offset !== undefined);\n\n\treturn {\n\t\trecords: returnData,\n\t};\n}\n\nexport async function downloadRecordAttachments(\n\tthis: IExecuteFunctions | IPollFunctions,\n\trecords: IRecord[],\n\tfieldNames: string[],\n\tpairedItem?: IPairedItemData[],\n): Promise<INodeExecutionData[]> {\n\tconst elements: INodeExecutionData[] = [];\n\tfor (const record of records) {\n\t\tconst element: INodeExecutionData = { json: {}, binary: {} };\n\t\tif (pairedItem) {\n\t\t\telement.pairedItem = pairedItem;\n\t\t}\n\t\telement.json = record as unknown as IDataObject;\n\t\tfor (const fieldName of fieldNames) {\n\t\t\tif (record.fields[fieldName] !== undefined) {\n\t\t\t\tfor (const [index, attachment] of (record.fields[fieldName] as IAttachment[]).entries()) {\n\t\t\t\t\tconst file = await apiRequest.call(this, 'GET', '', {}, {}, attachment.url, {\n\t\t\t\t\t\tjson: false,\n\t\t\t\t\t\tencoding: null,\n\t\t\t\t\t});\n\t\t\t\t\telement.binary![`${fieldName}_${index}`] = await this.helpers.prepareBinaryData(\n\t\t\t\t\t\tBuffer.from(file as string),\n\t\t\t\t\t\tattachment.filename,\n\t\t\t\t\t\tattachment.type,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (Object.keys(element.binary as IBinaryKeyData).length === 0) {\n\t\t\tdelete element.binary;\n\t\t}\n\t\telements.push(element);\n\t}\n\treturn elements;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4BA,eAAsB,WAErB,QACA,UACA,MACA,OACA,KACA,SAAsB,CAAC,GACR;AACf,UAAQ,SAAS,CAAC;AAOlB,QAAM,UAA2B;AAAA,IAChC,SAAS,CAAC;AAAA,IACV;AAAA,IACA;AAAA,IACA,IAAI;AAAA,IACJ,KAAK,OAAO,+BAA+B,QAAQ;AAAA,IACnD,gBAAgB;AAAA,IAChB,MAAM;AAAA,EACP;AAEA,MAAI,OAAO,KAAK,MAAM,EAAE,WAAW,GAAG;AACrC,WAAO,OAAO,SAAS,MAAM;AAAA,EAC9B;AAEA,MAAI,OAAO,KAAK,IAAI,EAAE,WAAW,GAAG;AACnC,WAAO,QAAQ;AAAA,EAChB;AACA,QAAM,uBAAuB,KAAK,iBAAiB,kBAAkB,CAAC;AACtE,SAAO,MAAM,KAAK,QAAQ,0BAA0B,KAAK,MAAM,sBAAsB,OAAO;AAC7F;AAQA,eAAsB,mBAErB,QACA,UACA,MACA,OACe;AACf,MAAI,UAAU,QAAW;AACxB,YAAQ,CAAC;AAAA,EACV;AACA,QAAM,WAAW;AAEjB,QAAM,aAA4B,CAAC;AAEnC,MAAI;AAEJ,KAAG;AACF,mBAAe,MAAM,WAAW,KAAK,MAAM,QAAQ,UAAU,MAAM,KAAK;AACxE,eAAW,KAAK,MAAM,YAAY,aAAa,OAAwB;AAEvE,UAAM,SAAS,aAAa;AAAA,EAC7B,SAAS,aAAa,WAAW;AAEjC,SAAO;AAAA,IACN,SAAS;AAAA,EACV;AACD;AAEA,eAAsB,0BAErB,SACA,YACA,YACgC;AAChC,QAAM,WAAiC,CAAC;AACxC,aAAW,UAAU,SAAS;AAC7B,UAAM,UAA8B,EAAE,MAAM,CAAC,GAAG,QAAQ,CAAC,EAAE;AAC3D,QAAI,YAAY;AACf,cAAQ,aAAa;AAAA,IACtB;AACA,YAAQ,OAAO;AACf,eAAW,aAAa,YAAY;AACnC,UAAI,OAAO,OAAO,SAAS,MAAM,QAAW;AAC3C,mBAAW,CAAC,OAAO,UAAU,KAAM,OAAO,OAAO,SAAS,EAAoB,QAAQ,GAAG;AACxF,gBAAM,OAAO,MAAM,WAAW,KAAK,MAAM,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,WAAW,KAAK;AAAA,YAC3E,MAAM;AAAA,YACN,UAAU;AAAA,UACX,CAAC;AACD,kBAAQ,OAAQ,GAAG,SAAS,IAAI,KAAK,EAAE,IAAI,MAAM,KAAK,QAAQ;AAAA,YAC7D,OAAO,KAAK,IAAc;AAAA,YAC1B,WAAW;AAAA,YACX,WAAW;AAAA,UACZ;AAAA,QACD;AAAA,MACD;AAAA,IACD;AACA,QAAI,OAAO,KAAK,QAAQ,MAAwB,EAAE,WAAW,GAAG;AAC/D,aAAO,QAAQ;AAAA,IAChB;AACA,aAAS,KAAK,OAAO;AAAA,EACtB;AACA,SAAO;AACR;","names":[]}
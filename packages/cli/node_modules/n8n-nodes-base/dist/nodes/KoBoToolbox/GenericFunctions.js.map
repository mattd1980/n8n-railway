{"version":3,"sources":["../../../nodes/KoBoToolbox/GenericFunctions.ts"],"sourcesContent":["import clone from 'lodash/clone';\nimport compact from 'lodash/compact';\nimport concat from 'lodash/concat';\nimport escapeRegExp from 'lodash/escapeRegExp';\nimport every from 'lodash/every';\nimport first from 'lodash/first';\nimport isArray from 'lodash/isArray';\nimport isString from 'lodash/isString';\nimport last from 'lodash/last';\nimport set from 'lodash/set';\nimport some from 'lodash/some';\nimport split from 'lodash/split';\nimport toNumber from 'lodash/toNumber';\nimport toString from 'lodash/toString';\nimport trim from 'lodash/trim';\nimport type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tILoadOptionsFunctions,\n\tIHookFunctions,\n\tIHttpRequestOptions,\n\tINodeExecutionData,\n\tINodePropertyOptions,\n\tIWebhookFunctions,\n} from 'n8n-workflow';\n\nexport async function koBoToolboxApiRequest(\n\tthis: IExecuteFunctions | IWebhookFunctions | IHookFunctions | ILoadOptionsFunctions,\n\toption: IDataObject = {},\n): Promise<any> {\n\tconst credentials = await this.getCredentials('koBoToolboxApi');\n\n\t// Set up pagination / scrolling\n\tconst returnAll = !!option.returnAll;\n\tif (returnAll) {\n\t\t// Override manual pagination options\n\t\tset(option, 'qs.limit', 3000);\n\t\t// Don't pass this custom param to helpers.httpRequest\n\t\tdelete option.returnAll;\n\t}\n\n\tconst options: IHttpRequestOptions = {\n\t\turl: '',\n\t\theaders: {\n\t\t\tAccept: 'application/json',\n\t\t},\n\t\tjson: true,\n\t};\n\tif (Object.keys(option)) {\n\t\tObject.assign(options, option);\n\t}\n\tif (options.url && !/^http(s)?:/.test(options.url)) {\n\t\toptions.url = (credentials.URL as string) + options.url;\n\t}\n\n\tlet results = null;\n\tlet keepLooking = true;\n\twhile (keepLooking) {\n\t\tconst response = await this.helpers.httpRequestWithAuthentication.call(\n\t\t\tthis,\n\t\t\t'koBoToolboxApi',\n\t\t\toptions,\n\t\t);\n\t\t// Append or set results\n\t\tresults = response.results ? concat(results || [], response.results) : response;\n\t\tif (returnAll && response.next) {\n\t\t\toptions.url = response.next;\n\t\t} else {\n\t\t\tkeepLooking = false;\n\t\t}\n\t}\n\n\treturn results;\n}\n\nexport async function koBoToolboxRawRequest(\n\tthis: IExecuteFunctions | IWebhookFunctions | IHookFunctions | ILoadOptionsFunctions,\n\toption: IHttpRequestOptions,\n): Promise<any> {\n\tconst credentials = await this.getCredentials('koBoToolboxApi');\n\n\tif (option.url && !/^http(s)?:/.test(option.url)) {\n\t\toption.url = (credentials.URL as string) + option.url;\n\t}\n\n\treturn await this.helpers.httpRequestWithAuthentication.call(this, 'koBoToolboxApi', option);\n}\n\nfunction parseGeoPoint(geoPoint: string): null | number[] {\n\t// Check if it looks like a \"lat lon z precision\" flat string e.g. \"-1.931161 30.079811 0 0\" (lat, lon, elevation, precision)\n\t// NOTE: we are discarding the elevation and precision values since they're not (well) supported in GeoJSON\n\tconst coordinates = split(geoPoint, ' ');\n\tif (\n\t\tcoordinates.length >= 2 &&\n\t\tevery(coordinates, (coord) => coord && /^-?\\d+(?:\\.\\d+)?$/.test(toString(coord)))\n\t) {\n\t\t// NOTE: GeoJSON uses lon, lat, while most common systems use lat, lon order!\n\t\treturn [toNumber(coordinates[1]), toNumber(coordinates[0])];\n\t}\n\treturn null;\n}\n\nexport function parseStringList(value: string): string[] {\n\treturn split(toString(value), /[\\s,]+/);\n}\n\nconst matchWildcard = (value: string, pattern: string): boolean => {\n\tconst regex = new RegExp(`^${escapeRegExp(pattern).replace('\\\\*', '.*')}$`);\n\treturn regex.test(value);\n};\n\nconst formatValue = (value: any, format: string): any => {\n\tif (isString(value)) {\n\t\t// Sanitize value\n\t\tvalue = toString(value);\n\n\t\t// Parse geoPoints\n\t\tconst geoPoint = parseGeoPoint(value as string);\n\t\tif (geoPoint) {\n\t\t\treturn {\n\t\t\t\ttype: 'Point',\n\t\t\t\tcoordinates: geoPoint,\n\t\t\t};\n\t\t}\n\n\t\t// Check if it's a closed polygon geo-shape: -1.954117 30.085159 0 0;-1.955005 30.084622 0 0;-1.956057 30.08506 0 0;-1.956393 30.086229 0 0;-1.955853 30.087143 0 0;-1.954609 30.08725 0 0;-1.953966 30.086735 0 0;-1.953805 30.085897 0 0;-1.954117 30.085159 0 0\n\t\tconst points = value.split(';');\n\t\tif (points.length >= 2 && /^[-\\d\\.\\s;]+$/.test(value as string)) {\n\t\t\t// Using the GeoJSON format as per https://geojson.org/\n\t\t\tconst coordinates = compact(points.map(parseGeoPoint) as number[]);\n\t\t\t// Only return if all values are properly parsed\n\t\t\tif (coordinates.length === points.length) {\n\t\t\t\t// If the shape is closed, declare it as Polygon, otherwise as LineString\n\n\t\t\t\tif (first(points) === last(points)) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: 'Polygon',\n\t\t\t\t\t\tcoordinates: [coordinates],\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn { type: 'LineString', coordinates };\n\t\t\t}\n\t\t}\n\n\t\t// Parse numbers\n\t\tif ('number' === format) {\n\t\t\treturn toNumber(value);\n\t\t}\n\n\t\t// Split multi-select\n\t\tif ('multiSelect' === format) {\n\t\t\treturn split(toString(value), ' ');\n\t\t}\n\t}\n\n\treturn value;\n};\n\nexport function formatSubmission(\n\tsubmission: IDataObject,\n\tselectMasks: string[] = [],\n\tnumberMasks: string[] = [],\n): IDataObject {\n\t// Create a shallow copy of the submission\n\tconst response = {} as IDataObject;\n\n\tfor (const key of Object.keys(submission)) {\n\t\tlet value = clone(submission[key]);\n\t\t// Sanitize key names: split by group, trim _\n\t\tconst sanitizedKey = key\n\t\t\t.split('/')\n\t\t\t.map((k) => trim(k, ' _'))\n\t\t\t.join('.');\n\t\tconst leafKey = sanitizedKey.split('.').pop() || '';\n\t\tlet format = 'string';\n\t\tif (some(numberMasks, (mask) => matchWildcard(leafKey, mask))) {\n\t\t\tformat = 'number';\n\t\t}\n\t\tif (some(selectMasks, (mask) => matchWildcard(leafKey, mask))) {\n\t\t\tformat = 'multiSelect';\n\t\t}\n\n\t\tvalue = formatValue(value, format);\n\n\t\tset(response, sanitizedKey, value);\n\t}\n\n\t// Reformat _geolocation\n\tif (\n\t\tisArray(response.geolocation) &&\n\t\tresponse.geolocation.length === 2 &&\n\t\tresponse.geolocation[0] &&\n\t\tresponse.geolocation[1]\n\t) {\n\t\tresponse.geolocation = {\n\t\t\ttype: 'Point',\n\t\t\tcoordinates: [response.geolocation[1], response.geolocation[0]],\n\t\t};\n\t}\n\n\treturn response;\n}\n\nexport async function downloadAttachments(\n\tthis: IExecuteFunctions | IWebhookFunctions,\n\tsubmission: IDataObject,\n\toptions: IDataObject,\n): Promise<INodeExecutionData> {\n\t// Initialize return object with the original submission JSON content\n\tconst binaryItem: INodeExecutionData = {\n\t\tjson: {\n\t\t\t...submission,\n\t\t},\n\t\tbinary: {},\n\t};\n\n\tconst credentials = await this.getCredentials('koBoToolboxApi');\n\n\t// Look for attachment links - there can be more than one\n\tconst attachmentList = (submission._attachments || submission.attachments) as any[];\n\n\tif (attachmentList?.length) {\n\t\tfor (const [index, attachment] of attachmentList.entries()) {\n\t\t\t// look for the question name linked to this attachment\n\t\t\tconst fileName = attachment.filename;\n\t\t\tconst sanitizedFileName = toString(fileName).replace(/_[^_]+(?=\\.\\w+)/, ''); // strip suffix\n\n\t\t\tlet relatedQuestion = null;\n\t\t\tif ('question' === options.binaryNamingScheme) {\n\t\t\t\tfor (const question of Object.keys(submission)) {\n\t\t\t\t\t// The logic to map attachments to question is sometimes ambiguous:\n\t\t\t\t\t// - If the attachment is linked to a question, the question's value is the same as the attachment's filename (with spaces replaced by underscores)\n\t\t\t\t\t// - BUT sometimes the attachment's filename has an extra suffix, e.g. \"My_Picture_0OdlaKJ.jpg\", would map to the question \"picture\": \"My Picture.jpg\"\n\t\t\t\t\tconst sanitizedQuestionValue = toString(submission[question]).replace(/\\s/g, '_'); // replace spaces with underscores\n\t\t\t\t\tif (sanitizedFileName === sanitizedQuestionValue) {\n\t\t\t\t\t\trelatedQuestion = question;\n\t\t\t\t\t\t// Just use the first match...\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Download attachment\n\t\t\t// NOTE: this needs to follow redirects (possibly across domains), while keeping Authorization headers\n\t\t\t// The Axios client will not propagate the Authorization header on redirects (see https://github.com/axios/axios/issues/3607), so we need to follow ourselves...\n\t\t\tlet response = null;\n\t\t\tconst attachmentUrl =\n\t\t\t\tattachment[options.version as string] || (attachment.download_url as string);\n\t\t\tlet final = false,\n\t\t\t\tredir = 0;\n\n\t\t\tconst axiosOptions: IHttpRequestOptions = {\n\t\t\t\turl: attachmentUrl,\n\t\t\t\tmethod: 'GET',\n\t\t\t\theaders: {\n\t\t\t\t\tAuthorization: `Token ${credentials.token}`,\n\t\t\t\t},\n\t\t\t\tignoreHttpStatusErrors: true,\n\t\t\t\treturnFullResponse: true,\n\t\t\t\tdisableFollowRedirect: true,\n\t\t\t\tencoding: 'arraybuffer',\n\t\t\t};\n\n\t\t\twhile (!final && redir < 5) {\n\t\t\t\tresponse = await this.helpers.httpRequest(axiosOptions);\n\n\t\t\t\tif (response?.headers.location) {\n\t\t\t\t\t// Follow redirect\n\t\t\t\t\taxiosOptions.url = response.headers.location;\n\t\t\t\t\tredir++;\n\t\t\t\t} else {\n\t\t\t\t\tfinal = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (response?.body) {\n\t\t\t\t// Use the provided prefix if any, otherwise try to use the original question name\n\t\t\t\tlet binaryName;\n\t\t\t\tif ('question' === options.binaryNamingScheme && relatedQuestion) {\n\t\t\t\t\tbinaryName = relatedQuestion;\n\t\t\t\t} else {\n\t\t\t\t\tbinaryName = `${options.dataPropertyAttachmentsPrefixName || 'attachment_'}${index}`;\n\t\t\t\t}\n\n\t\t\t\tbinaryItem.binary![binaryName] = await this.helpers.prepareBinaryData(\n\t\t\t\t\tresponse.body as Buffer,\n\t\t\t\t\tfileName as string,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdelete binaryItem.binary;\n\t}\n\n\t// Add item to final output - even if there's no attachment retrieved\n\treturn binaryItem;\n}\n\nexport async function loadForms(this: ILoadOptionsFunctions): Promise<INodePropertyOptions[]> {\n\tconst responseData = await koBoToolboxApiRequest.call(this, {\n\t\turl: '/api/v2/assets/',\n\t\tqs: {\n\t\t\tq: 'asset_type:survey',\n\t\t\tordering: 'name',\n\t\t},\n\t\tscroll: true,\n\t});\n\n\treturn responseData?.map((survey: any) => ({ name: survey.name, value: survey.uid })) || [];\n}\n"],"mappings":"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","names":["set","concat","split","every","toString","toNumber","escapeRegExp","isString","compact","first","last","clone","trim","some","isArray"]}
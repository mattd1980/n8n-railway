{"version":3,"sources":["../../../nodes/MQTT/GenericFunctions.ts"],"sourcesContent":["import { connect, type IClientOptions, type MqttClient } from 'mqtt';\nimport { ApplicationError, randomString } from 'n8n-workflow';\n\nimport { formatPrivateKey } from '@utils/utilities';\n\ninterface BaseMqttCredential {\n\tprotocol: 'mqtt' | 'mqtts' | 'ws';\n\thost: string;\n\tport: number;\n\tusername: string;\n\tpassword: string;\n\tclean: boolean;\n\tclientId: string;\n\tpasswordless?: boolean;\n}\n\ntype NonSslMqttCredential = BaseMqttCredential & {\n\tssl: false;\n};\n\ntype SslMqttCredential = BaseMqttCredential & {\n\tssl: true;\n\tca: string;\n\tcert: string;\n\tkey: string;\n\trejectUnauthorized?: boolean;\n};\nexport type MqttCredential = NonSslMqttCredential | SslMqttCredential;\n\nexport const createClient = async (credentials: MqttCredential): Promise<MqttClient> => {\n\tconst { protocol, host, port, clean, clientId, username, password } = credentials;\n\n\tconst clientOptions: IClientOptions = {\n\t\tprotocol,\n\t\thost,\n\t\tport,\n\t\tclean,\n\t\tclientId: clientId || `mqttjs_${randomString(8).toLowerCase()}`,\n\t};\n\n\tif (username && password) {\n\t\tclientOptions.username = username;\n\t\tclientOptions.password = password;\n\t}\n\n\tif (credentials.ssl) {\n\t\tclientOptions.ca = formatPrivateKey(credentials.ca);\n\t\tclientOptions.cert = formatPrivateKey(credentials.cert);\n\t\tclientOptions.key = formatPrivateKey(credentials.key);\n\t\tclientOptions.rejectUnauthorized = credentials.rejectUnauthorized;\n\t}\n\n\treturn await new Promise((resolve, reject) => {\n\t\tconst client = connect(clientOptions);\n\n\t\tconst onConnect = () => {\n\t\t\tclient.removeListener('connect', onConnect);\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-use-before-define\n\t\t\tclient.removeListener('error', onError);\n\t\t\tresolve(client);\n\t\t};\n\n\t\tconst onError = (error: Error) => {\n\t\t\tclient.removeListener('connect', onConnect);\n\t\t\tclient.removeListener('error', onError);\n\t\t\t// mqtt client has an automatic reconnect mechanism that will\n\t\t\t// keep trying to reconnect until it succeeds unless we\n\t\t\t// explicitly close the client\n\t\t\tclient.end();\n\t\t\treject(new ApplicationError(error.message));\n\t\t};\n\n\t\tclient.once('connect', onConnect);\n\t\tclient.once('error', onError);\n\t});\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAA8D;AAC9D,0BAA+C;AAE/C,uBAAiC;AA0B1B,MAAM,eAAe,OAAO,gBAAqD;AACvF,QAAM,EAAE,UAAU,MAAM,MAAM,OAAO,UAAU,UAAU,SAAS,IAAI;AAEtE,QAAM,gBAAgC;AAAA,IACrC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,YAAY,cAAU,kCAAa,CAAC,EAAE,YAAY,CAAC;AAAA,EAC9D;AAEA,MAAI,YAAY,UAAU;AACzB,kBAAc,WAAW;AACzB,kBAAc,WAAW;AAAA,EAC1B;AAEA,MAAI,YAAY,KAAK;AACpB,kBAAc,SAAK,mCAAiB,YAAY,EAAE;AAClD,kBAAc,WAAO,mCAAiB,YAAY,IAAI;AACtD,kBAAc,UAAM,mCAAiB,YAAY,GAAG;AACpD,kBAAc,qBAAqB,YAAY;AAAA,EAChD;AAEA,SAAO,MAAM,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC7C,UAAM,aAAS,qBAAQ,aAAa;AAEpC,UAAM,YAAY,MAAM;AACvB,aAAO,eAAe,WAAW,SAAS;AAE1C,aAAO,eAAe,SAAS,OAAO;AACtC,cAAQ,MAAM;AAAA,IACf;AAEA,UAAM,UAAU,CAAC,UAAiB;AACjC,aAAO,eAAe,WAAW,SAAS;AAC1C,aAAO,eAAe,SAAS,OAAO;AAItC,aAAO,IAAI;AACX,aAAO,IAAI,qCAAiB,MAAM,OAAO,CAAC;AAAA,IAC3C;AAEA,WAAO,KAAK,WAAW,SAAS;AAChC,WAAO,KAAK,SAAS,OAAO;AAAA,EAC7B,CAAC;AACF;","names":[]}
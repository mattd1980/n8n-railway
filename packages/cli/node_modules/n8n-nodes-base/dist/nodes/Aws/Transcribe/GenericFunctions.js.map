{"version":3,"sources":["../../../../nodes/Aws/Transcribe/GenericFunctions.ts"],"sourcesContent":["import type { Request } from 'aws4';\nimport { sign } from 'aws4';\nimport get from 'lodash/get';\nimport type {\n\tICredentialDataDecryptedObject,\n\tIDataObject,\n\tIExecuteFunctions,\n\tIHookFunctions,\n\tIHttpRequestMethods,\n\tILoadOptionsFunctions,\n\tIRequestOptions,\n\tIWebhookFunctions,\n\tJsonObject,\n} from 'n8n-workflow';\nimport { NodeApiError } from 'n8n-workflow';\nimport { URL } from 'url';\n\nfunction getEndpointForService(\n\tservice: string,\n\tcredentials: ICredentialDataDecryptedObject,\n): string {\n\tlet endpoint;\n\tif (service === 'lambda' && credentials.lambdaEndpoint) {\n\t\tendpoint = credentials.lambdaEndpoint;\n\t} else if (service === 'sns' && credentials.snsEndpoint) {\n\t\tendpoint = credentials.snsEndpoint;\n\t} else {\n\t\tendpoint = `https://${service}.${credentials.region}.amazonaws.com`;\n\t}\n\treturn (endpoint as string).replace('{region}', credentials.region as string);\n}\n\nexport async function awsApiRequest(\n\tthis: IHookFunctions | IExecuteFunctions | ILoadOptionsFunctions | IWebhookFunctions,\n\tservice: string,\n\tmethod: IHttpRequestMethods,\n\tpath: string,\n\tbody?: string,\n\theaders?: object,\n): Promise<any> {\n\tconst credentials = await this.getCredentials('aws');\n\n\t// Concatenate path and instantiate URL object so it parses correctly query strings\n\tconst endpoint = new URL(getEndpointForService(service, credentials) + path);\n\n\t// Sign AWS API request with the user credentials\n\tconst signOpts = { headers: headers || {}, host: endpoint.host, method, path, body } as Request;\n\tconst securityHeaders = {\n\t\taccessKeyId: `${credentials.accessKeyId}`.trim(),\n\t\tsecretAccessKey: `${credentials.secretAccessKey}`.trim(),\n\t\tsessionToken: credentials.temporaryCredentials\n\t\t\t? `${credentials.sessionToken}`.trim()\n\t\t\t: undefined,\n\t};\n\n\tsign(signOpts, securityHeaders);\n\n\tconst options: IRequestOptions = {\n\t\theaders: signOpts.headers,\n\t\tmethod,\n\t\turi: endpoint.href,\n\t\tbody: signOpts.body,\n\t};\n\n\ttry {\n\t\treturn await this.helpers.request(options);\n\t} catch (error) {\n\t\tthrow new NodeApiError(this.getNode(), error as JsonObject); // no XML parsing needed\n\t}\n}\n\nexport async function awsApiRequestREST(\n\tthis: IHookFunctions | IExecuteFunctions | ILoadOptionsFunctions,\n\tservice: string,\n\tmethod: IHttpRequestMethods,\n\tpath: string,\n\tbody?: string,\n\theaders?: object,\n): Promise<any> {\n\tconst response = await awsApiRequest.call(this, service, method, path, body, headers);\n\ttry {\n\t\treturn JSON.parse(response as string);\n\t} catch (error) {\n\t\treturn response;\n\t}\n}\n\nexport async function awsApiRequestRESTAllItems(\n\tthis: IHookFunctions | IExecuteFunctions | ILoadOptionsFunctions,\n\tpropertyName: string,\n\tservice: string,\n\tmethod: IHttpRequestMethods,\n\tpath: string,\n\tbody?: string,\n\tquery: IDataObject = {},\n\t_headers: IDataObject = {},\n\t_option: IDataObject = {},\n\t_region?: string,\n): Promise<any> {\n\tconst returnData: IDataObject[] = [];\n\n\tlet responseData;\n\n\tconst propertyNameArray = propertyName.split('.');\n\n\tdo {\n\t\tresponseData = await awsApiRequestREST.call(this, service, method, path, body, query);\n\n\t\tif (get(responseData, [propertyNameArray[0], propertyNameArray[1], 'NextToken'])) {\n\t\t\tquery.NextToken = get(responseData, [\n\t\t\t\tpropertyNameArray[0],\n\t\t\t\tpropertyNameArray[1],\n\t\t\t\t'NextToken',\n\t\t\t]);\n\t\t}\n\t\tif (get(responseData, propertyName)) {\n\t\t\tif (Array.isArray(get(responseData, propertyName))) {\n\t\t\t\treturnData.push.apply(returnData, get(responseData, propertyName) as IDataObject[]);\n\t\t\t} else {\n\t\t\t\treturnData.push(get(responseData, propertyName) as IDataObject);\n\t\t\t}\n\t\t}\n\t} while (\n\t\tget(responseData, [propertyNameArray[0], propertyNameArray[1], 'NextToken']) !== undefined\n\t);\n\n\treturn returnData;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,kBAAqB;AACrB,iBAAgB;AAYhB,0BAA6B;AAC7B,iBAAoB;AAEpB,SAAS,sBACR,SACA,aACS;AACT,MAAI;AACJ,MAAI,YAAY,YAAY,YAAY,gBAAgB;AACvD,eAAW,YAAY;AAAA,EACxB,WAAW,YAAY,SAAS,YAAY,aAAa;AACxD,eAAW,YAAY;AAAA,EACxB,OAAO;AACN,eAAW,WAAW,OAAO,IAAI,YAAY,MAAM;AAAA,EACpD;AACA,SAAQ,SAAoB,QAAQ,YAAY,YAAY,MAAgB;AAC7E;AAEA,eAAsB,cAErB,SACA,QACA,MACA,MACA,SACe;AACf,QAAM,cAAc,MAAM,KAAK,eAAe,KAAK;AAGnD,QAAM,WAAW,IAAI,eAAI,sBAAsB,SAAS,WAAW,IAAI,IAAI;AAG3E,QAAM,WAAW,EAAE,SAAS,WAAW,CAAC,GAAG,MAAM,SAAS,MAAM,QAAQ,MAAM,KAAK;AACnF,QAAM,kBAAkB;AAAA,IACvB,aAAa,GAAG,YAAY,WAAW,GAAG,KAAK;AAAA,IAC/C,iBAAiB,GAAG,YAAY,eAAe,GAAG,KAAK;AAAA,IACvD,cAAc,YAAY,uBACvB,GAAG,YAAY,YAAY,GAAG,KAAK,IACnC;AAAA,EACJ;AAEA,wBAAK,UAAU,eAAe;AAE9B,QAAM,UAA2B;AAAA,IAChC,SAAS,SAAS;AAAA,IAClB;AAAA,IACA,KAAK,SAAS;AAAA,IACd,MAAM,SAAS;AAAA,EAChB;AAEA,MAAI;AACH,WAAO,MAAM,KAAK,QAAQ,QAAQ,OAAO;AAAA,EAC1C,SAAS,OAAO;AACf,UAAM,IAAI,iCAAa,KAAK,QAAQ,GAAG,KAAmB;AAAA,EAC3D;AACD;AAEA,eAAsB,kBAErB,SACA,QACA,MACA,MACA,SACe;AACf,QAAM,WAAW,MAAM,cAAc,KAAK,MAAM,SAAS,QAAQ,MAAM,MAAM,OAAO;AACpF,MAAI;AACH,WAAO,KAAK,MAAM,QAAkB;AAAA,EACrC,SAAS,OAAO;AACf,WAAO;AAAA,EACR;AACD;AAEA,eAAsB,0BAErB,cACA,SACA,QACA,MACA,MACA,QAAqB,CAAC,GACtB,WAAwB,CAAC,GACzB,UAAuB,CAAC,GACxB,SACe;AACf,QAAM,aAA4B,CAAC;AAEnC,MAAI;AAEJ,QAAM,oBAAoB,aAAa,MAAM,GAAG;AAEhD,KAAG;AACF,mBAAe,MAAM,kBAAkB,KAAK,MAAM,SAAS,QAAQ,MAAM,MAAM,KAAK;AAEpF,YAAI,WAAAA,SAAI,cAAc,CAAC,kBAAkB,CAAC,GAAG,kBAAkB,CAAC,GAAG,WAAW,CAAC,GAAG;AACjF,YAAM,gBAAY,WAAAA,SAAI,cAAc;AAAA,QACnC,kBAAkB,CAAC;AAAA,QACnB,kBAAkB,CAAC;AAAA,QACnB;AAAA,MACD,CAAC;AAAA,IACF;AACA,YAAI,WAAAA,SAAI,cAAc,YAAY,GAAG;AACpC,UAAI,MAAM,YAAQ,WAAAA,SAAI,cAAc,YAAY,CAAC,GAAG;AACnD,mBAAW,KAAK,MAAM,gBAAY,WAAAA,SAAI,cAAc,YAAY,CAAkB;AAAA,MACnF,OAAO;AACN,mBAAW,SAAK,WAAAA,SAAI,cAAc,YAAY,CAAgB;AAAA,MAC/D;AAAA,IACD;AAAA,EACD,aACC,WAAAA,SAAI,cAAc,CAAC,kBAAkB,CAAC,GAAG,kBAAkB,CAAC,GAAG,WAAW,CAAC,MAAM;AAGlF,SAAO;AACR;","names":["get"]}
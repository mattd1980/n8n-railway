{"version":3,"sources":["../../../../../nodes/Google/Sheet/v1/GoogleSheet.ts"],"sourcesContent":["import get from 'lodash/get';\nimport type { IExecuteFunctions, ILoadOptionsFunctions, IDataObject } from 'n8n-workflow';\nimport { NodeOperationError } from 'n8n-workflow';\nimport { utils as xlsxUtils } from 'xlsx';\n\nimport { googleApiRequest } from './GenericFunctions';\n\nexport interface ISheetOptions {\n\tscope: string[];\n}\n\nexport interface IGoogleAuthCredentials {\n\temail: string;\n\tprivateKey: string;\n}\n\nexport interface ISheetUpdateData {\n\trange: string;\n\tvalues: string[][];\n}\n\nexport interface ILookupValues {\n\tlookupColumn: string;\n\tlookupValue: string;\n}\n\nexport interface IToDeleteRange {\n\tamount: number;\n\tstartIndex: number;\n\tsheetId: number;\n}\n\nexport interface IToDelete {\n\t[key: string]: IToDeleteRange[] | undefined;\n\tcolumns?: IToDeleteRange[];\n\trows?: IToDeleteRange[];\n}\n\nexport type ValueInputOption = 'RAW' | 'USER_ENTERED';\n\nexport type ValueRenderOption = 'FORMATTED_VALUE' | 'FORMULA' | 'UNFORMATTED_VALUE';\n\nexport class GoogleSheet {\n\tid: string;\n\n\texecuteFunctions: IExecuteFunctions | ILoadOptionsFunctions;\n\n\tconstructor(\n\t\tspreadsheetId: string,\n\t\texecuteFunctions: IExecuteFunctions | ILoadOptionsFunctions,\n\t\toptions?: ISheetOptions | undefined,\n\t) {\n\t\t// options = <SheetOptions>options || {};\n\t\tif (!options) {\n\t\t\toptions = {} as ISheetOptions;\n\t\t}\n\n\t\tthis.executeFunctions = executeFunctions;\n\t\tthis.id = spreadsheetId;\n\t}\n\n\t/**\n\t * Encodes the range that also none latin character work\n\t *\n\t */\n\tencodeRange(range: string): string {\n\t\tif (range.includes('!')) {\n\t\t\tconst [sheet, ranges] = range.split('!');\n\t\t\trange = `${encodeURIComponent(sheet)}!${ranges}`;\n\t\t}\n\t\treturn range;\n\t}\n\n\t/**\n\t * Clears values from a sheet\n\t *\n\t */\n\tasync clearData(range: string): Promise<object> {\n\t\tconst body = {\n\t\t\tspreadsheetId: this.id,\n\t\t\trange,\n\t\t};\n\n\t\tconst response = await googleApiRequest.call(\n\t\t\tthis.executeFunctions,\n\t\t\t'POST',\n\t\t\t`/v4/spreadsheets/${this.id}/values/${range}:clear`,\n\t\t\tbody,\n\t\t);\n\n\t\treturn response;\n\t}\n\n\t/**\n\t * Returns the cell values\n\t */\n\tasync getData(\n\t\trange: string,\n\t\tvalueRenderMode: ValueRenderOption,\n\t): Promise<string[][] | undefined> {\n\t\tconst query = {\n\t\t\tvalueRenderOption: valueRenderMode,\n\t\t};\n\n\t\tconst response = await googleApiRequest.call(\n\t\t\tthis.executeFunctions,\n\t\t\t'GET',\n\t\t\t`/v4/spreadsheets/${this.id}/values/${range}`,\n\t\t\t{},\n\t\t\tquery,\n\t\t);\n\n\t\treturn response.values as string[][] | undefined;\n\t}\n\n\t/**\n\t * Returns the sheets in a Spreadsheet\n\t */\n\tasync spreadsheetGetSheets() {\n\t\tconst query = {\n\t\t\tfields: 'sheets.properties',\n\t\t};\n\n\t\tconst response = await googleApiRequest.call(\n\t\t\tthis.executeFunctions,\n\t\t\t'GET',\n\t\t\t`/v4/spreadsheets/${this.id}`,\n\t\t\t{},\n\t\t\tquery,\n\t\t);\n\n\t\treturn response;\n\t}\n\n\t/**\n\t * Sets values in one or more ranges of a spreadsheet.\n\t */\n\tasync spreadsheetBatchUpdate(requests: IDataObject[]) {\n\t\tconst body = {\n\t\t\trequests,\n\t\t};\n\n\t\tconst response = await googleApiRequest.call(\n\t\t\tthis.executeFunctions,\n\t\t\t'POST',\n\t\t\t`/v4/spreadsheets/${this.id}:batchUpdate`,\n\t\t\tbody,\n\t\t);\n\n\t\treturn response;\n\t}\n\n\t/**\n\t * Sets the cell values\n\t */\n\tasync batchUpdate(updateData: ISheetUpdateData[], valueInputMode: ValueInputOption) {\n\t\tconst body = {\n\t\t\tdata: updateData,\n\t\t\tvalueInputOption: valueInputMode,\n\t\t};\n\n\t\tconst response = await googleApiRequest.call(\n\t\t\tthis.executeFunctions,\n\t\t\t'POST',\n\t\t\t`/v4/spreadsheets/${this.id}/values:batchUpdate`,\n\t\t\tbody,\n\t\t);\n\n\t\treturn response;\n\t}\n\n\t/**\n\t * Sets the cell values\n\t */\n\tasync setData(range: string, data: string[][], valueInputMode: ValueInputOption) {\n\t\tconst body = {\n\t\t\tvalueInputOption: valueInputMode,\n\t\t\tvalues: data,\n\t\t};\n\n\t\tconst response = await googleApiRequest.call(\n\t\t\tthis.executeFunctions,\n\t\t\t'POST',\n\t\t\t`/v4/spreadsheets/${this.id}/values/${range}`,\n\t\t\tbody,\n\t\t);\n\n\t\treturn response;\n\t}\n\n\t/**\n\t * Appends the cell values\n\t */\n\tasync appendData(range: string, data: string[][], valueInputMode: ValueInputOption) {\n\t\tconst body = {\n\t\t\trange: decodeURIComponent(range),\n\t\t\tvalues: data,\n\t\t};\n\n\t\tconst query = {\n\t\t\tvalueInputOption: valueInputMode,\n\t\t};\n\n\t\tconst response = await googleApiRequest.call(\n\t\t\tthis.executeFunctions,\n\t\t\t'POST',\n\t\t\t`/v4/spreadsheets/${this.id}/values/${range}:append`,\n\t\t\tbody,\n\t\t\tquery,\n\t\t);\n\n\t\treturn response;\n\t}\n\n\t/**\n\t * Returns the given sheet data in a structured way\n\t */\n\tstructureData(\n\t\tinputData: string[][],\n\t\tstartRow: number,\n\t\tkeys: string[],\n\t\taddEmpty?: boolean,\n\t): IDataObject[] {\n\t\tconst returnData = [];\n\n\t\tlet tempEntry: IDataObject, rowIndex: number, columnIndex: number, key: string;\n\n\t\tfor (rowIndex = startRow; rowIndex < inputData.length; rowIndex++) {\n\t\t\ttempEntry = {};\n\t\t\tfor (columnIndex = 0; columnIndex < inputData[rowIndex].length; columnIndex++) {\n\t\t\t\tkey = keys[columnIndex];\n\t\t\t\tif (key) {\n\t\t\t\t\t// Only add the data for which a key was given and ignore all others\n\t\t\t\t\ttempEntry[key] = inputData[rowIndex][columnIndex];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Object.keys(tempEntry).length || addEmpty === true) {\n\t\t\t\t// Only add the entry if data got found to not have empty ones\n\t\t\t\treturnData.push(tempEntry);\n\t\t\t}\n\t\t}\n\n\t\treturn returnData;\n\t}\n\n\t/**\n\t * Returns the given sheet data in a structured way using\n\t * the startRow as the one with the name of the key\n\t */\n\tstructureArrayDataByColumn(\n\t\tinputData: string[][],\n\t\tkeyRow: number,\n\t\tdataStartRow: number,\n\t): IDataObject[] {\n\t\tconst keys: string[] = [];\n\n\t\tif (keyRow < 0 || dataStartRow < keyRow || keyRow >= inputData.length) {\n\t\t\t// The key row does not exist so it is not possible to structure data\n\t\t\treturn [];\n\t\t}\n\n\t\t// Create the keys array\n\t\tfor (let columnIndex = 0; columnIndex < inputData[keyRow].length; columnIndex++) {\n\t\t\tkeys.push(inputData[keyRow][columnIndex]);\n\t\t}\n\n\t\treturn this.structureData(inputData, dataStartRow, keys);\n\t}\n\n\tasync appendSheetData(\n\t\tinputData: IDataObject[],\n\t\trange: string,\n\t\tkeyRowIndex: number,\n\t\tvalueInputMode: ValueInputOption,\n\t\tusePathForKeyRow: boolean,\n\t): Promise<string[][]> {\n\t\tconst data = await this.convertStructuredDataToArray(\n\t\t\tinputData,\n\t\t\trange,\n\t\t\tkeyRowIndex,\n\t\t\tusePathForKeyRow,\n\t\t);\n\t\treturn await this.appendData(range, data, valueInputMode);\n\t}\n\n\tgetColumnWithOffset(startColumn: string, offset: number): string {\n\t\tconst columnIndex = xlsxUtils.decode_col(startColumn) + offset;\n\t\treturn xlsxUtils.encode_col(columnIndex);\n\t}\n\n\t/**\n\t * Updates data in a sheet\n\t *\n\t * @param {IDataObject[]} inputData Data to update Sheet with\n\t * @param {string} indexKey The name of the key which gets used to know which rows to update\n\t * @param {string} range The range to look for data\n\t * @param {number} keyRowIndex Index of the row which contains the keys\n\t * @param {number} dataStartRowIndex Index of the first row which contains data\n\t */\n\tasync updateSheetData(\n\t\tinputData: IDataObject[],\n\t\tindexKey: string,\n\t\trange: string,\n\t\tkeyRowIndex: number,\n\t\tdataStartRowIndex: number,\n\t\tvalueInputMode: ValueInputOption,\n\t\tvalueRenderMode: ValueRenderOption,\n\t\tupsert = false,\n\t): Promise<string[][]> {\n\t\t// Get current data in Google Sheet\n\t\tlet rangeFull: string;\n\t\tlet sheet: string | undefined = undefined;\n\t\tif (range.includes('!')) {\n\t\t\t[sheet, rangeFull] = range.split('!');\n\t\t} else {\n\t\t\trangeFull = range;\n\t\t}\n\t\tconst [rangeStart, rangeEnd] = rangeFull.split(':');\n\n\t\tconst rangeStartSplit = rangeStart.match(/([a-zA-Z]{1,10})([0-9]{0,10})/);\n\t\tconst rangeEndSplit = rangeEnd.match(/([a-zA-Z]{1,10})([0-9]{0,10})/);\n\n\t\tif (\n\t\t\trangeStartSplit === null ||\n\t\t\trangeStartSplit.length !== 3 ||\n\t\t\trangeEndSplit === null ||\n\t\t\trangeEndSplit.length !== 3\n\t\t) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.executeFunctions.getNode(),\n\t\t\t\t`The range \"${range}\" is not valid.`,\n\t\t\t);\n\t\t}\n\n\t\tconst keyRowRange = `${sheet ? sheet + '!' : ''}${rangeStartSplit[1]}${keyRowIndex + 1}:${\n\t\t\trangeEndSplit[1]\n\t\t}${keyRowIndex + 1}`;\n\n\t\tconst sheetDatakeyRow = await this.getData(this.encodeRange(keyRowRange), valueRenderMode);\n\n\t\tif (sheetDatakeyRow === undefined) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.executeFunctions.getNode(),\n\t\t\t\t'Could not retrieve the key row!',\n\t\t\t);\n\t\t}\n\n\t\tconst keyColumnOrder = sheetDatakeyRow[0];\n\n\t\tconst keyIndex = keyColumnOrder.indexOf(indexKey);\n\n\t\tif (keyIndex === -1) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.executeFunctions.getNode(),\n\t\t\t\t`Could not find column for key \"${indexKey}\"!`,\n\t\t\t);\n\t\t}\n\n\t\tconst startRowIndex = rangeStartSplit[2] || dataStartRowIndex;\n\t\tconst endRowIndex = rangeEndSplit[2] || '';\n\n\t\tconst keyColumn = this.getColumnWithOffset(rangeStartSplit[1], keyIndex);\n\t\tconst keyColumnRange = `${\n\t\t\tsheet ? sheet + '!' : ''\n\t\t}${keyColumn}${startRowIndex}:${keyColumn}${endRowIndex}`;\n\n\t\tconst sheetDataKeyColumn = await this.getData(\n\t\t\tthis.encodeRange(keyColumnRange),\n\t\t\tvalueRenderMode,\n\t\t);\n\n\t\tif (sheetDataKeyColumn === undefined) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.executeFunctions.getNode(),\n\t\t\t\t'Could not retrieve the key column!',\n\t\t\t);\n\t\t}\n\n\t\t// TODO: The data till here can be cached optionally. Maybe add an option which can\n\t\t//       can be activated if it is used in a loop and nothing else updates the data.\n\n\t\t// Remove the first row which contains the key\n\t\tsheetDataKeyColumn.shift();\n\n\t\t// Create an Array which all the key-values of the Google Sheet\n\t\tconst keyColumnIndexLookup = sheetDataKeyColumn.map((rowContent) => rowContent[0]);\n\n\t\tconst updateData: ISheetUpdateData[] = [];\n\t\tlet itemKey: string | number | undefined | null;\n\t\tlet propertyName: string;\n\t\tlet itemKeyIndex: number;\n\t\tlet updateRowIndex: number;\n\t\tlet updateColumnName: string;\n\t\tfor (const inputItem of inputData) {\n\t\t\titemKey = inputItem[indexKey] as string;\n\t\t\t// if ([undefined, null].includes(inputItem[indexKey] as string | undefined | null)) {\n\t\t\tif (itemKey === undefined || itemKey === null) {\n\t\t\t\t// Item does not have the indexKey so we can ignore it or append it if upsert true\n\t\t\t\tif (upsert) {\n\t\t\t\t\tawait this.appendSheetData(\n\t\t\t\t\t\t[inputItem],\n\t\t\t\t\t\tthis.encodeRange(range),\n\t\t\t\t\t\tkeyRowIndex,\n\t\t\t\t\t\tvalueInputMode,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Item does have the key so check if it exists in Sheet\n\t\t\titemKeyIndex = keyColumnIndexLookup.indexOf(itemKey);\n\t\t\tif (itemKeyIndex === -1) {\n\t\t\t\t// Key does not exist in the Sheet so it can not be updated so skip it or append it if upsert true\n\t\t\t\tif (upsert) {\n\t\t\t\t\tawait this.appendSheetData(\n\t\t\t\t\t\t[inputItem],\n\t\t\t\t\t\tthis.encodeRange(range),\n\t\t\t\t\t\tkeyRowIndex,\n\t\t\t\t\t\tvalueInputMode,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Get the row index in which the data should be updated\n\t\t\tupdateRowIndex = keyColumnIndexLookup.indexOf(itemKey) + dataStartRowIndex + 1;\n\n\t\t\t// Check all the properties in the sheet and check which ones exist on the\n\t\t\t// item and should be updated\n\t\t\tfor (propertyName of keyColumnOrder) {\n\t\t\t\tif (propertyName === indexKey) {\n\t\t\t\t\t// Ignore the key itself as that does not get changed it gets\n\t\t\t\t\t// only used to find the correct row to update\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (inputItem[propertyName] === undefined || inputItem[propertyName] === null) {\n\t\t\t\t\t// Property does not exist so skip it\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Property exists so add it to the data to update\n\n\t\t\t\t// Get the column name in which the property data can be found\n\t\t\t\tupdateColumnName = this.getColumnWithOffset(\n\t\t\t\t\trangeStartSplit[1],\n\t\t\t\t\tkeyColumnOrder.indexOf(propertyName),\n\t\t\t\t);\n\n\t\t\t\tupdateData.push({\n\t\t\t\t\trange: `${sheet ? sheet + '!' : ''}${updateColumnName}${updateRowIndex}`,\n\t\t\t\t\tvalues: [[inputItem[propertyName] as string]],\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn await this.batchUpdate(updateData, valueInputMode);\n\t}\n\n\t/**\n\t * Looks for a specific value in a column and if it gets found it returns the whole row\n\t *\n\t * @param {string[][]} inputData Data to check for lookup value in\n\t * @param {number} keyRowIndex Index of the row which contains the keys\n\t * @param {number} dataStartRowIndex Index of the first row which contains data\n\t * @param {ILookupValues[]} lookupValues The lookup values which decide what data to return\n\t * @param {boolean} [returnAllMatches] Returns all the found matches instead of only the first one\n\t */\n\tasync lookupValues(\n\t\tinputData: string[][],\n\t\tkeyRowIndex: number,\n\t\tdataStartRowIndex: number,\n\t\tlookupValues: ILookupValues[],\n\t\treturnAllMatches?: boolean,\n\t): Promise<IDataObject[]> {\n\t\tconst keys: string[] = [];\n\n\t\tif (keyRowIndex < 0 || dataStartRowIndex < keyRowIndex || keyRowIndex >= inputData.length) {\n\t\t\t// The key row does not exist so it is not possible to look up the data\n\t\t\tthrow new NodeOperationError(this.executeFunctions.getNode(), 'The key row does not exist!');\n\t\t}\n\n\t\t// Create the keys array\n\t\tfor (let columnIndex = 0; columnIndex < inputData[keyRowIndex].length; columnIndex++) {\n\t\t\tkeys.push(inputData[keyRowIndex][columnIndex]);\n\t\t}\n\n\t\tconst returnData = [inputData[keyRowIndex]];\n\n\t\t// Standardise values array, if rows is [[]], map it to [['']] (Keep the columns into consideration)\n\t\tfor (let rowIndex = 0; rowIndex < inputData?.length; rowIndex++) {\n\t\t\tif (inputData[rowIndex].length === 0) {\n\t\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\t\tinputData[rowIndex][i] = '';\n\t\t\t\t}\n\t\t\t} else if (inputData[rowIndex].length < keys.length) {\n\t\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\t\tif (inputData[rowIndex][i] === undefined) {\n\t\t\t\t\t\tinputData[rowIndex].push('');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Loop over all the lookup values and try to find a row to return\n\t\tlet rowIndex: number;\n\t\tlet returnColumnIndex: number;\n\n\t\tlookupLoop: for (const lookupValue of lookupValues) {\n\t\t\treturnColumnIndex = keys.indexOf(lookupValue.lookupColumn);\n\n\t\t\tif (returnColumnIndex === -1) {\n\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\tthis.executeFunctions.getNode(),\n\t\t\t\t\t`The column \"${lookupValue.lookupColumn}\" could not be found!`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Loop over all the items and find the one with the matching value\n\t\t\tfor (rowIndex = dataStartRowIndex; rowIndex < inputData.length; rowIndex++) {\n\t\t\t\tif (\n\t\t\t\t\tinputData[rowIndex][returnColumnIndex]?.toString() === lookupValue.lookupValue.toString()\n\t\t\t\t) {\n\t\t\t\t\treturnData.push(inputData[rowIndex]);\n\n\t\t\t\t\tif (returnAllMatches !== true) {\n\t\t\t\t\t\tcontinue lookupLoop;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If value could not be found add an empty one that the order of\n\t\t\t// the returned items stays the same\n\t\t\tif (returnAllMatches !== true) {\n\t\t\t\treturnData.push([]);\n\t\t\t}\n\t\t}\n\n\t\treturn this.structureData(returnData, 1, keys, true);\n\t}\n\n\tasync convertStructuredDataToArray(\n\t\tinputData: IDataObject[],\n\t\trange: string,\n\t\tkeyRowIndex: number,\n\t\tusePathForKeyRow: boolean,\n\t): Promise<string[][]> {\n\t\tlet sheet: string | undefined = undefined;\n\t\tif (range.includes('!')) {\n\t\t\t[sheet, range] = range.split('!');\n\t\t}\n\t\tconst [startColumn, endColumn] = range.split(':');\n\n\t\tlet getRange = `${startColumn}${keyRowIndex + 1}:${endColumn}${keyRowIndex + 1}`;\n\n\t\tif (sheet !== undefined) {\n\t\t\tgetRange = `${sheet}!${getRange}`;\n\t\t}\n\n\t\tconst keyColumnData = await this.getData(getRange, 'UNFORMATTED_VALUE');\n\n\t\tif (keyColumnData === undefined) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.executeFunctions.getNode(),\n\t\t\t\t'Could not retrieve the column data!',\n\t\t\t);\n\t\t}\n\n\t\tconst keyColumnOrder = keyColumnData[0];\n\n\t\tconst setData: string[][] = [];\n\n\t\tlet rowData: string[] = [];\n\t\tinputData.forEach((item) => {\n\t\t\trowData = [];\n\t\t\tkeyColumnOrder.forEach((key) => {\n\t\t\t\tconst value = get(item, key) as string;\n\t\t\t\tif (usePathForKeyRow && value !== undefined && value !== null) {\n\t\t\t\t\t//match by key path\n\t\t\t\t\trowData.push(value.toString());\n\t\t\t\t} else if (\n\t\t\t\t\t!usePathForKeyRow &&\n\t\t\t\t\titem.hasOwnProperty(key) &&\n\t\t\t\t\titem[key] !== null &&\n\t\t\t\t\titem[key] !== undefined\n\t\t\t\t) {\n\t\t\t\t\t//match by exact key name\n\t\t\t\t\trowData.push(item[key].toString());\n\t\t\t\t} else {\n\t\t\t\t\trowData.push('');\n\t\t\t\t}\n\t\t\t});\n\t\t\tsetData.push(rowData);\n\t\t});\n\n\t\treturn setData;\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAgB;AAEhB,0BAAmC;AACnC,kBAAmC;AAEnC,8BAAiC;AAqC1B,MAAM,YAAY;AAAA,EAKxB,YACC,eACA,kBACA,SACC;AAED,QAAI,CAAC,SAAS;AACb,gBAAU,CAAC;AAAA,IACZ;AAEA,SAAK,mBAAmB;AACxB,SAAK,KAAK;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,OAAuB;AAClC,QAAI,MAAM,SAAS,GAAG,GAAG;AACxB,YAAM,CAAC,OAAO,MAAM,IAAI,MAAM,MAAM,GAAG;AACvC,cAAQ,GAAG,mBAAmB,KAAK,CAAC,IAAI,MAAM;AAAA,IAC/C;AACA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,UAAU,OAAgC;AAC/C,UAAM,OAAO;AAAA,MACZ,eAAe,KAAK;AAAA,MACpB;AAAA,IACD;AAEA,UAAM,WAAW,MAAM,yCAAiB;AAAA,MACvC,KAAK;AAAA,MACL;AAAA,MACA,oBAAoB,KAAK,EAAE,WAAW,KAAK;AAAA,MAC3C;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QACL,OACA,iBACkC;AAClC,UAAM,QAAQ;AAAA,MACb,mBAAmB;AAAA,IACpB;AAEA,UAAM,WAAW,MAAM,yCAAiB;AAAA,MACvC,KAAK;AAAA,MACL;AAAA,MACA,oBAAoB,KAAK,EAAE,WAAW,KAAK;AAAA,MAC3C,CAAC;AAAA,MACD;AAAA,IACD;AAEA,WAAO,SAAS;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,uBAAuB;AAC5B,UAAM,QAAQ;AAAA,MACb,QAAQ;AAAA,IACT;AAEA,UAAM,WAAW,MAAM,yCAAiB;AAAA,MACvC,KAAK;AAAA,MACL;AAAA,MACA,oBAAoB,KAAK,EAAE;AAAA,MAC3B,CAAC;AAAA,MACD;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,uBAAuB,UAAyB;AACrD,UAAM,OAAO;AAAA,MACZ;AAAA,IACD;AAEA,UAAM,WAAW,MAAM,yCAAiB;AAAA,MACvC,KAAK;AAAA,MACL;AAAA,MACA,oBAAoB,KAAK,EAAE;AAAA,MAC3B;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,YAAgC,gBAAkC;AACnF,UAAM,OAAO;AAAA,MACZ,MAAM;AAAA,MACN,kBAAkB;AAAA,IACnB;AAEA,UAAM,WAAW,MAAM,yCAAiB;AAAA,MACvC,KAAK;AAAA,MACL;AAAA,MACA,oBAAoB,KAAK,EAAE;AAAA,MAC3B;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ,OAAe,MAAkB,gBAAkC;AAChF,UAAM,OAAO;AAAA,MACZ,kBAAkB;AAAA,MAClB,QAAQ;AAAA,IACT;AAEA,UAAM,WAAW,MAAM,yCAAiB;AAAA,MACvC,KAAK;AAAA,MACL;AAAA,MACA,oBAAoB,KAAK,EAAE,WAAW,KAAK;AAAA,MAC3C;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,WAAW,OAAe,MAAkB,gBAAkC;AACnF,UAAM,OAAO;AAAA,MACZ,OAAO,mBAAmB,KAAK;AAAA,MAC/B,QAAQ;AAAA,IACT;AAEA,UAAM,QAAQ;AAAA,MACb,kBAAkB;AAAA,IACnB;AAEA,UAAM,WAAW,MAAM,yCAAiB;AAAA,MACvC,KAAK;AAAA,MACL;AAAA,MACA,oBAAoB,KAAK,EAAE,WAAW,KAAK;AAAA,MAC3C;AAAA,MACA;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,cACC,WACA,UACA,MACA,UACgB;AAChB,UAAM,aAAa,CAAC;AAEpB,QAAI,WAAwB,UAAkB,aAAqB;AAEnE,SAAK,WAAW,UAAU,WAAW,UAAU,QAAQ,YAAY;AAClE,kBAAY,CAAC;AACb,WAAK,cAAc,GAAG,cAAc,UAAU,QAAQ,EAAE,QAAQ,eAAe;AAC9E,cAAM,KAAK,WAAW;AACtB,YAAI,KAAK;AAER,oBAAU,GAAG,IAAI,UAAU,QAAQ,EAAE,WAAW;AAAA,QACjD;AAAA,MACD;AACA,UAAI,OAAO,KAAK,SAAS,EAAE,UAAU,aAAa,MAAM;AAEvD,mBAAW,KAAK,SAAS;AAAA,MAC1B;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,2BACC,WACA,QACA,cACgB;AAChB,UAAM,OAAiB,CAAC;AAExB,QAAI,SAAS,KAAK,eAAe,UAAU,UAAU,UAAU,QAAQ;AAEtE,aAAO,CAAC;AAAA,IACT;AAGA,aAAS,cAAc,GAAG,cAAc,UAAU,MAAM,EAAE,QAAQ,eAAe;AAChF,WAAK,KAAK,UAAU,MAAM,EAAE,WAAW,CAAC;AAAA,IACzC;AAEA,WAAO,KAAK,cAAc,WAAW,cAAc,IAAI;AAAA,EACxD;AAAA,EAEA,MAAM,gBACL,WACA,OACA,aACA,gBACA,kBACsB;AACtB,UAAM,OAAO,MAAM,KAAK;AAAA,MACvB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD;AACA,WAAO,MAAM,KAAK,WAAW,OAAO,MAAM,cAAc;AAAA,EACzD;AAAA,EAEA,oBAAoB,aAAqB,QAAwB;AAChE,UAAM,cAAc,YAAAA,MAAU,WAAW,WAAW,IAAI;AACxD,WAAO,YAAAA,MAAU,WAAW,WAAW;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,gBACL,WACA,UACA,OACA,aACA,mBACA,gBACA,iBACA,SAAS,OACa;AAEtB,QAAI;AACJ,QAAI,QAA4B;AAChC,QAAI,MAAM,SAAS,GAAG,GAAG;AACxB,OAAC,OAAO,SAAS,IAAI,MAAM,MAAM,GAAG;AAAA,IACrC,OAAO;AACN,kBAAY;AAAA,IACb;AACA,UAAM,CAAC,YAAY,QAAQ,IAAI,UAAU,MAAM,GAAG;AAElD,UAAM,kBAAkB,WAAW,MAAM,+BAA+B;AACxE,UAAM,gBAAgB,SAAS,MAAM,+BAA+B;AAEpE,QACC,oBAAoB,QACpB,gBAAgB,WAAW,KAC3B,kBAAkB,QAClB,cAAc,WAAW,GACxB;AACD,YAAM,IAAI;AAAA,QACT,KAAK,iBAAiB,QAAQ;AAAA,QAC9B,cAAc,KAAK;AAAA,MACpB;AAAA,IACD;AAEA,UAAM,cAAc,GAAG,QAAQ,QAAQ,MAAM,EAAE,GAAG,gBAAgB,CAAC,CAAC,GAAG,cAAc,CAAC,IACrF,cAAc,CAAC,CAChB,GAAG,cAAc,CAAC;AAElB,UAAM,kBAAkB,MAAM,KAAK,QAAQ,KAAK,YAAY,WAAW,GAAG,eAAe;AAEzF,QAAI,oBAAoB,QAAW;AAClC,YAAM,IAAI;AAAA,QACT,KAAK,iBAAiB,QAAQ;AAAA,QAC9B;AAAA,MACD;AAAA,IACD;AAEA,UAAM,iBAAiB,gBAAgB,CAAC;AAExC,UAAM,WAAW,eAAe,QAAQ,QAAQ;AAEhD,QAAI,aAAa,IAAI;AACpB,YAAM,IAAI;AAAA,QACT,KAAK,iBAAiB,QAAQ;AAAA,QAC9B,kCAAkC,QAAQ;AAAA,MAC3C;AAAA,IACD;AAEA,UAAM,gBAAgB,gBAAgB,CAAC,KAAK;AAC5C,UAAM,cAAc,cAAc,CAAC,KAAK;AAExC,UAAM,YAAY,KAAK,oBAAoB,gBAAgB,CAAC,GAAG,QAAQ;AACvE,UAAM,iBAAiB,GACtB,QAAQ,QAAQ,MAAM,EACvB,GAAG,SAAS,GAAG,aAAa,IAAI,SAAS,GAAG,WAAW;AAEvD,UAAM,qBAAqB,MAAM,KAAK;AAAA,MACrC,KAAK,YAAY,cAAc;AAAA,MAC/B;AAAA,IACD;AAEA,QAAI,uBAAuB,QAAW;AACrC,YAAM,IAAI;AAAA,QACT,KAAK,iBAAiB,QAAQ;AAAA,QAC9B;AAAA,MACD;AAAA,IACD;AAMA,uBAAmB,MAAM;AAGzB,UAAM,uBAAuB,mBAAmB,IAAI,CAAC,eAAe,WAAW,CAAC,CAAC;AAEjF,UAAM,aAAiC,CAAC;AACxC,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,eAAW,aAAa,WAAW;AAClC,gBAAU,UAAU,QAAQ;AAE5B,UAAI,YAAY,UAAa,YAAY,MAAM;AAE9C,YAAI,QAAQ;AACX,gBAAM,KAAK;AAAA,YACV,CAAC,SAAS;AAAA,YACV,KAAK,YAAY,KAAK;AAAA,YACtB;AAAA,YACA;AAAA,YACA;AAAA,UACD;AAAA,QACD;AACA;AAAA,MACD;AAGA,qBAAe,qBAAqB,QAAQ,OAAO;AACnD,UAAI,iBAAiB,IAAI;AAExB,YAAI,QAAQ;AACX,gBAAM,KAAK;AAAA,YACV,CAAC,SAAS;AAAA,YACV,KAAK,YAAY,KAAK;AAAA,YACtB;AAAA,YACA;AAAA,YACA;AAAA,UACD;AAAA,QACD;AACA;AAAA,MACD;AAGA,uBAAiB,qBAAqB,QAAQ,OAAO,IAAI,oBAAoB;AAI7E,WAAK,gBAAgB,gBAAgB;AACpC,YAAI,iBAAiB,UAAU;AAG9B;AAAA,QACD;AACA,YAAI,UAAU,YAAY,MAAM,UAAa,UAAU,YAAY,MAAM,MAAM;AAE9E;AAAA,QACD;AAKA,2BAAmB,KAAK;AAAA,UACvB,gBAAgB,CAAC;AAAA,UACjB,eAAe,QAAQ,YAAY;AAAA,QACpC;AAEA,mBAAW,KAAK;AAAA,UACf,OAAO,GAAG,QAAQ,QAAQ,MAAM,EAAE,GAAG,gBAAgB,GAAG,cAAc;AAAA,UACtE,QAAQ,CAAC,CAAC,UAAU,YAAY,CAAW,CAAC;AAAA,QAC7C,CAAC;AAAA,MACF;AAAA,IACD;AAEA,WAAO,MAAM,KAAK,YAAY,YAAY,cAAc;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,aACL,WACA,aACA,mBACA,cACA,kBACyB;AACzB,UAAM,OAAiB,CAAC;AAExB,QAAI,cAAc,KAAK,oBAAoB,eAAe,eAAe,UAAU,QAAQ;AAE1F,YAAM,IAAI,uCAAmB,KAAK,iBAAiB,QAAQ,GAAG,6BAA6B;AAAA,IAC5F;AAGA,aAAS,cAAc,GAAG,cAAc,UAAU,WAAW,EAAE,QAAQ,eAAe;AACrF,WAAK,KAAK,UAAU,WAAW,EAAE,WAAW,CAAC;AAAA,IAC9C;AAEA,UAAM,aAAa,CAAC,UAAU,WAAW,CAAC;AAG1C,aAASC,YAAW,GAAGA,YAAW,WAAW,QAAQA,aAAY;AAChE,UAAI,UAAUA,SAAQ,EAAE,WAAW,GAAG;AACrC,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACrC,oBAAUA,SAAQ,EAAE,CAAC,IAAI;AAAA,QAC1B;AAAA,MACD,WAAW,UAAUA,SAAQ,EAAE,SAAS,KAAK,QAAQ;AACpD,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACrC,cAAI,UAAUA,SAAQ,EAAE,CAAC,MAAM,QAAW;AACzC,sBAAUA,SAAQ,EAAE,KAAK,EAAE;AAAA,UAC5B;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAEA,QAAI;AACJ,QAAI;AAEJ,eAAY,YAAW,eAAe,cAAc;AACnD,0BAAoB,KAAK,QAAQ,YAAY,YAAY;AAEzD,UAAI,sBAAsB,IAAI;AAC7B,cAAM,IAAI;AAAA,UACT,KAAK,iBAAiB,QAAQ;AAAA,UAC9B,eAAe,YAAY,YAAY;AAAA,QACxC;AAAA,MACD;AAGA,WAAK,WAAW,mBAAmB,WAAW,UAAU,QAAQ,YAAY;AAC3E,YACC,UAAU,QAAQ,EAAE,iBAAiB,GAAG,SAAS,MAAM,YAAY,YAAY,SAAS,GACvF;AACD,qBAAW,KAAK,UAAU,QAAQ,CAAC;AAEnC,cAAI,qBAAqB,MAAM;AAC9B,qBAAS;AAAA,UACV;AAAA,QACD;AAAA,MACD;AAIA,UAAI,qBAAqB,MAAM;AAC9B,mBAAW,KAAK,CAAC,CAAC;AAAA,MACnB;AAAA,IACD;AAEA,WAAO,KAAK,cAAc,YAAY,GAAG,MAAM,IAAI;AAAA,EACpD;AAAA,EAEA,MAAM,6BACL,WACA,OACA,aACA,kBACsB;AACtB,QAAI,QAA4B;AAChC,QAAI,MAAM,SAAS,GAAG,GAAG;AACxB,OAAC,OAAO,KAAK,IAAI,MAAM,MAAM,GAAG;AAAA,IACjC;AACA,UAAM,CAAC,aAAa,SAAS,IAAI,MAAM,MAAM,GAAG;AAEhD,QAAI,WAAW,GAAG,WAAW,GAAG,cAAc,CAAC,IAAI,SAAS,GAAG,cAAc,CAAC;AAE9E,QAAI,UAAU,QAAW;AACxB,iBAAW,GAAG,KAAK,IAAI,QAAQ;AAAA,IAChC;AAEA,UAAM,gBAAgB,MAAM,KAAK,QAAQ,UAAU,mBAAmB;AAEtE,QAAI,kBAAkB,QAAW;AAChC,YAAM,IAAI;AAAA,QACT,KAAK,iBAAiB,QAAQ;AAAA,QAC9B;AAAA,MACD;AAAA,IACD;AAEA,UAAM,iBAAiB,cAAc,CAAC;AAEtC,UAAM,UAAsB,CAAC;AAE7B,QAAI,UAAoB,CAAC;AACzB,cAAU,QAAQ,CAAC,SAAS;AAC3B,gBAAU,CAAC;AACX,qBAAe,QAAQ,CAAC,QAAQ;AAC/B,cAAM,YAAQ,WAAAC,SAAI,MAAM,GAAG;AAC3B,YAAI,oBAAoB,UAAU,UAAa,UAAU,MAAM;AAE9D,kBAAQ,KAAK,MAAM,SAAS,CAAC;AAAA,QAC9B,WACC,CAAC,oBACD,KAAK,eAAe,GAAG,KACvB,KAAK,GAAG,MAAM,QACd,KAAK,GAAG,MAAM,QACb;AAED,kBAAQ,KAAK,KAAK,GAAG,EAAE,SAAS,CAAC;AAAA,QAClC,OAAO;AACN,kBAAQ,KAAK,EAAE;AAAA,QAChB;AAAA,MACD,CAAC;AACD,cAAQ,KAAK,OAAO;AAAA,IACrB,CAAC;AAED,WAAO;AAAA,EACR;AACD;","names":["xlsxUtils","rowIndex","get"]}
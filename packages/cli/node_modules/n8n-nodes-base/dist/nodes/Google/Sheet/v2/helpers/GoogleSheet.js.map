{"version":3,"sources":["../../../../../../nodes/Google/Sheet/v2/helpers/GoogleSheet.ts"],"sourcesContent":["import get from 'lodash/get';\nimport type {\n\tIDataObject,\n\tIExecuteFunctions,\n\tILoadOptionsFunctions,\n\tINode,\n\tIPollFunctions,\n} from 'n8n-workflow';\nimport { ApplicationError, NodeOperationError } from 'n8n-workflow';\nimport { utils as xlsxUtils } from 'xlsx';\n\nimport type {\n\tILookupValues,\n\tISheetUpdateData,\n\tResourceLocator,\n\tSheetCellDecoded,\n\tSheetRangeData,\n\tSheetRangeDecoded,\n\tSpreadSheetResponse,\n\tValueInputOption,\n\tValueRenderOption,\n} from './GoogleSheets.types';\nimport { getSheetId, removeEmptyColumns } from './GoogleSheets.utils';\nimport { apiRequest } from '../transport';\n\nexport class GoogleSheet {\n\tid: string;\n\n\texecuteFunctions: IExecuteFunctions | ILoadOptionsFunctions | IPollFunctions;\n\n\tconstructor(\n\t\tspreadsheetId: string,\n\t\texecuteFunctions: IExecuteFunctions | ILoadOptionsFunctions | IPollFunctions,\n\t) {\n\t\tthis.executeFunctions = executeFunctions;\n\t\tthis.id = spreadsheetId;\n\t}\n\n\t/**\n\t * Encodes the range that also none latin character work\n\t *\n\t * @param {string} range\n\t * @returns {string}\n\t * @memberof GoogleSheet\n\t */\n\tprivate encodeRange(range: string): string {\n\t\tif (range.includes('!')) {\n\t\t\tconst [sheet, ranges] = range.split('!');\n\t\t\treturn `${encodeURIComponent(sheet)}!${ranges}`;\n\t\t}\n\t\t// Use '' so that sheet is not interpreted as range\n\t\treturn encodeURIComponent(`'${range}'`);\n\t}\n\n\t/**\n\t * Clears values from a sheet\n\t *\n\t * @param {string} range\n\t * @returns {Promise<object>}\n\t * @memberof GoogleSheet\n\t */\n\tasync clearData(range: string): Promise<object> {\n\t\tconst body = {\n\t\t\tspreadsheetId: this.id,\n\t\t\trange,\n\t\t};\n\n\t\tconst response = await apiRequest.call(\n\t\t\tthis.executeFunctions,\n\t\t\t'POST',\n\t\t\t`/v4/spreadsheets/${this.id}/values/${this.encodeRange(range)}:clear`,\n\t\t\tbody,\n\t\t);\n\n\t\treturn response;\n\t}\n\n\t/**\n\t * Returns the cell values\n\t */\n\tasync getData(range: string, valueRenderMode: ValueRenderOption, dateTimeRenderOption?: string) {\n\t\tconst query: IDataObject = {\n\t\t\tvalueRenderOption: valueRenderMode,\n\t\t\tdateTimeRenderOption: 'FORMATTED_STRING',\n\t\t};\n\n\t\tif (dateTimeRenderOption) {\n\t\t\tquery.dateTimeRenderOption = dateTimeRenderOption;\n\t\t}\n\n\t\tconst response = await apiRequest.call(\n\t\t\tthis.executeFunctions,\n\t\t\t'GET',\n\t\t\t`/v4/spreadsheets/${this.id}/values/${this.encodeRange(range)}`,\n\t\t\t{},\n\t\t\tquery,\n\t\t);\n\n\t\treturn response.values as string[][] | undefined;\n\t}\n\n\t/**\n\t * Returns the sheets in a Spreadsheet\n\t */\n\tasync spreadsheetGetSheets() {\n\t\tconst query = {\n\t\t\tfields: 'sheets.properties',\n\t\t};\n\n\t\tconst response = await apiRequest.call(\n\t\t\tthis.executeFunctions,\n\t\t\t'GET',\n\t\t\t`/v4/spreadsheets/${this.id}`,\n\t\t\t{},\n\t\t\tquery,\n\t\t);\n\n\t\treturn response;\n\t}\n\n\t/**\n\t *  Returns the sheet within a spreadsheet based on name or ID\n\t */\n\tasync spreadsheetGetSheet(node: INode, mode: ResourceLocator, value: string) {\n\t\tconst query = {\n\t\t\tfields: 'sheets.properties',\n\t\t};\n\n\t\tconst response = (await apiRequest.call(\n\t\t\tthis.executeFunctions,\n\t\t\t'GET',\n\t\t\t`/v4/spreadsheets/${this.id}`,\n\t\t\t{},\n\t\t\tquery,\n\t\t)) as SpreadSheetResponse;\n\n\t\tconst foundItem = response.sheets.find((item) => {\n\t\t\tif (mode === 'name') return item.properties.title === value;\n\t\t\treturn item.properties.sheetId === getSheetId(value);\n\t\t});\n\n\t\tif (!foundItem?.properties?.title) {\n\t\t\tconst error = new Error(`Sheet with ${mode === 'name' ? 'name' : 'ID'} ${value} not found`);\n\t\t\tthrow new NodeOperationError(node, error, { level: 'warning' });\n\t\t}\n\n\t\treturn foundItem.properties;\n\t}\n\n\t/**\n\t *  Returns the grid properties of a sheet\n\t */\n\tasync getDataRange(sheetId: string) {\n\t\tconst query = {\n\t\t\tfields: 'sheets.properties',\n\t\t};\n\n\t\tconst response = await apiRequest.call(\n\t\t\tthis.executeFunctions,\n\t\t\t'GET',\n\t\t\t`/v4/spreadsheets/${this.id}`,\n\t\t\t{},\n\t\t\tquery,\n\t\t);\n\t\tconst foundItem = response.sheets.find(\n\t\t\t(item: { properties: { sheetId: string } }) => item.properties.sheetId === sheetId,\n\t\t);\n\t\treturn foundItem.properties.gridProperties;\n\t}\n\n\t/**\n\t * Sets values in one or more ranges of a spreadsheet.\n\t */\n\tasync spreadsheetBatchUpdate(requests: IDataObject[]) {\n\t\tconst body = {\n\t\t\trequests,\n\t\t};\n\n\t\tconst response = await apiRequest.call(\n\t\t\tthis.executeFunctions,\n\t\t\t'POST',\n\t\t\t`/v4/spreadsheets/${this.id}:batchUpdate`,\n\t\t\tbody,\n\t\t);\n\n\t\treturn response;\n\t}\n\n\t/**\n\t * Sets the cell values\n\t */\n\tasync batchUpdate(updateData: ISheetUpdateData[], valueInputMode: ValueInputOption) {\n\t\tconst body = {\n\t\t\tdata: updateData,\n\t\t\tvalueInputOption: valueInputMode,\n\t\t};\n\n\t\tconst response = await apiRequest.call(\n\t\t\tthis.executeFunctions,\n\t\t\t'POST',\n\t\t\t`/v4/spreadsheets/${this.id}/values:batchUpdate`,\n\t\t\tbody,\n\t\t);\n\n\t\treturn response;\n\t}\n\n\tasync appendEmptyRowsOrColumns(sheetId: string, rowsToAdd = 1, columnsToAdd = 1) {\n\t\tconst requests: IDataObject[] = [];\n\n\t\tif (rowsToAdd > 0) {\n\t\t\trequests.push({\n\t\t\t\tappendDimension: {\n\t\t\t\t\tsheetId,\n\t\t\t\t\tdimension: 'ROWS',\n\t\t\t\t\tlength: rowsToAdd,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tif (columnsToAdd > 0) {\n\t\t\trequests.push({\n\t\t\t\tappendDimension: {\n\t\t\t\t\tsheetId,\n\t\t\t\t\tdimension: 'COLUMNS',\n\t\t\t\t\tlength: columnsToAdd,\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tif (requests.length === 0) {\n\t\t\tthrow new ApplicationError('Must specify at least one column or row to add', {\n\t\t\t\tlevel: 'warning',\n\t\t\t});\n\t\t}\n\n\t\tconst response = await apiRequest.call(\n\t\t\tthis.executeFunctions,\n\t\t\t'POST',\n\t\t\t`/v4/spreadsheets/${this.id}:batchUpdate`,\n\t\t\t{ requests },\n\t\t);\n\n\t\treturn response;\n\t}\n\n\t/**\n\t * Appends the cell values\n\t */\n\tasync appendData(\n\t\trange: string,\n\t\tdata: string[][],\n\t\tvalueInputMode: ValueInputOption,\n\t\tlastRow?: number,\n\t\tuseAppend?: boolean,\n\t) {\n\t\tconst lastRowWithData =\n\t\t\tlastRow ||\n\t\t\t(((await this.getData(range, 'UNFORMATTED_VALUE')) as string[][]) || []).length + 1;\n\n\t\tconst response = await this.updateRows(\n\t\t\trange,\n\t\t\tdata,\n\t\t\tvalueInputMode,\n\t\t\tlastRowWithData,\n\t\t\tdata.length,\n\t\t\tuseAppend,\n\t\t);\n\n\t\treturn response;\n\t}\n\n\tasync updateRows(\n\t\tsheetName: string,\n\t\tdata: string[][],\n\t\tvalueInputMode: ValueInputOption,\n\t\trow: number,\n\t\trowsLength?: number,\n\t\tuseAppend?: boolean,\n\t) {\n\t\tconst [name, _sheetRange] = sheetName.split('!');\n\t\tconst range = `${name}!${row}:${rowsLength ? row + rowsLength - 1 : row}`;\n\n\t\tconst body = {\n\t\t\trange,\n\t\t\tvalues: data,\n\t\t};\n\n\t\tconst query = {\n\t\t\tvalueInputOption: valueInputMode,\n\t\t};\n\n\t\tlet response;\n\n\t\tif (useAppend) {\n\t\t\tresponse = await apiRequest.call(\n\t\t\t\tthis.executeFunctions,\n\t\t\t\t'POST',\n\t\t\t\t`/v4/spreadsheets/${this.id}/values/${this.encodeRange(range)}:append`,\n\t\t\t\tbody,\n\t\t\t\tquery,\n\t\t\t);\n\t\t} else {\n\t\t\tresponse = await apiRequest.call(\n\t\t\t\tthis.executeFunctions,\n\t\t\t\t'PUT',\n\t\t\t\t`/v4/spreadsheets/${this.id}/values/${this.encodeRange(range)}`,\n\t\t\t\tbody,\n\t\t\t\tquery,\n\t\t\t);\n\t\t}\n\n\t\treturn response;\n\t}\n\n\t/**\n\t * Returns the given sheet data in a structured way\n\t */\n\tconvertSheetDataArrayToObjectArray(\n\t\tdata: SheetRangeData,\n\t\tstartRow: number,\n\t\tcolumnKeys: string[],\n\t\taddEmpty?: boolean,\n\t): IDataObject[] {\n\t\tconst returnData = [];\n\n\t\tfor (let rowIndex = startRow; rowIndex < data.length; rowIndex++) {\n\t\t\tconst item: IDataObject = {};\n\t\t\tfor (let columnIndex = 0; columnIndex < data[rowIndex].length; columnIndex++) {\n\t\t\t\tconst key = columnKeys[columnIndex];\n\t\t\t\tif (key) {\n\t\t\t\t\titem[key] = data[rowIndex][columnIndex];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Object.keys(item).length || addEmpty === true) {\n\t\t\t\treturnData.push(item);\n\t\t\t}\n\t\t}\n\n\t\treturn returnData;\n\t}\n\n\t/**\n\t * Returns the given sheet data in a structured way using\n\t * the startRow as the one with the name of the key\n\t */\n\tstructureArrayDataByColumn(\n\t\tinputData: string[][],\n\t\tkeyRow: number,\n\t\tdataStartRow: number,\n\t): IDataObject[] {\n\t\tconst keys: string[] = [];\n\n\t\tif (keyRow < 0 || dataStartRow < keyRow || keyRow >= inputData.length) {\n\t\t\t// The key row does not exist so it is not possible to structure data\n\t\t\treturn [];\n\t\t}\n\n\t\tconst longestRow = inputData.reduce((a, b) => (a.length > b.length ? a : b), []).length;\n\t\tfor (let columnIndex = 0; columnIndex < longestRow; columnIndex++) {\n\t\t\tkeys.push(inputData[keyRow][columnIndex] || `col_${columnIndex}`);\n\t\t}\n\n\t\treturn this.convertSheetDataArrayToObjectArray(inputData, dataStartRow, keys);\n\t}\n\n\ttestFilter(inputData: string[][], keyRow: number, dataStartRow: number): string[] {\n\t\tconst keys: string[] = [];\n\t\t//const returnData = [];\n\n\t\tif (keyRow < 0 || dataStartRow < keyRow || keyRow >= inputData.length) {\n\t\t\t// The key row does not exist so it is not possible to structure data\n\t\t\treturn [];\n\t\t}\n\n\t\t// Create the keys array\n\t\tfor (let columnIndex = 0; columnIndex < inputData[keyRow].length; columnIndex++) {\n\t\t\tkeys.push(inputData[keyRow][columnIndex]);\n\t\t}\n\n\t\treturn keys;\n\t}\n\n\tasync appendSheetData({\n\t\tinputData,\n\t\trange,\n\t\tkeyRowIndex,\n\t\tvalueInputMode,\n\t\tusePathForKeyRow,\n\t\tcolumnNamesList,\n\t\tlastRow,\n\t\tuseAppend,\n\t}: {\n\t\tinputData: IDataObject[];\n\t\trange: string;\n\t\tkeyRowIndex: number;\n\t\tvalueInputMode: ValueInputOption;\n\t\tusePathForKeyRow?: boolean;\n\t\tcolumnNamesList?: string[][];\n\t\tlastRow?: number;\n\t\tuseAppend?: boolean;\n\t}): Promise<string[][]> {\n\t\tconst data = await this.convertObjectArrayToSheetDataArray(\n\t\t\tinputData,\n\t\t\trange,\n\t\t\tkeyRowIndex,\n\t\t\tusePathForKeyRow,\n\t\t\tcolumnNamesList,\n\t\t\tuseAppend ? null : '',\n\t\t);\n\t\treturn await this.appendData(range, data, valueInputMode, lastRow, useAppend);\n\t}\n\n\tgetColumnWithOffset(startColumn: string, offset: number): string {\n\t\tconst columnIndex = xlsxUtils.decode_col(startColumn) + offset;\n\t\treturn xlsxUtils.encode_col(columnIndex);\n\t}\n\n\tasync getColumnValues({\n\t\trange,\n\t\tkeyIndex,\n\t\tdataStartRowIndex,\n\t\tvalueRenderMode,\n\t\tsheetData,\n\t}: {\n\t\trange: string;\n\t\tkeyIndex: number;\n\t\tdataStartRowIndex: number;\n\t\tvalueRenderMode: ValueRenderOption;\n\t\tsheetData?: string[][];\n\t}): Promise<string[]> {\n\t\tlet columnValuesList;\n\t\tif (sheetData) {\n\t\t\tcolumnValuesList = sheetData.slice(dataStartRowIndex - 1).map((row) => row[keyIndex]);\n\t\t} else {\n\t\t\tconst decodedRange = this.getDecodedSheetRange(range);\n\t\t\tconst startRowIndex = decodedRange.start?.row || dataStartRowIndex;\n\t\t\tconst endRowIndex = decodedRange.end?.row || '';\n\n\t\t\tconst keyColumn = this.getColumnWithOffset(decodedRange.start?.column || 'A', keyIndex);\n\t\t\tconst keyColumnRange = `${decodedRange.name}!${keyColumn}${startRowIndex}:${keyColumn}${endRowIndex}`;\n\t\t\tcolumnValuesList = await this.getData(keyColumnRange, valueRenderMode);\n\t\t}\n\n\t\tif (columnValuesList === undefined) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.executeFunctions.getNode(),\n\t\t\t\t'Could not retrieve the data from key column',\n\t\t\t);\n\t\t}\n\n\t\t//Remove the first row which contains the key and flaten the array\n\t\treturn columnValuesList.splice(1).flatMap((value) => value);\n\t}\n\n\t/**\n\t * Updates data in a sheet\n\t *\n\t * @param {IDataObject[]} inputData Data to update Sheet with\n\t * @param {string} indexKey The name of the key which gets used to know which rows to update\n\t * @param {string} range The range to look for data\n\t * @param {number} keyRowIndex Index of the row which contains the keys\n\t * @param {number} dataStartRowIndex Index of the first row which contains data\n\t * @returns {Promise<string[][]>}\n\t * @memberof GoogleSheet\n\t */\n\tasync prepareDataForUpdateOrUpsert({\n\t\tinputData,\n\t\tindexKey,\n\t\trange,\n\t\tkeyRowIndex,\n\t\tdataStartRowIndex,\n\t\tvalueRenderMode,\n\t\tupsert = false,\n\t\tcolumnNamesList,\n\t\tcolumnValuesList,\n\t}: {\n\t\tinputData: IDataObject[];\n\t\tindexKey: string;\n\t\trange: string;\n\t\tkeyRowIndex: number;\n\t\tdataStartRowIndex: number;\n\t\tvalueRenderMode: ValueRenderOption;\n\t\tupsert?: boolean;\n\t\tcolumnNamesList?: string[][];\n\t\tcolumnValuesList?: string[];\n\t}) {\n\t\tconst decodedRange = this.getDecodedSheetRange(range);\n\t\tconst keyRowRange = `${decodedRange.name}!${decodedRange.start?.column || ''}${keyRowIndex + 1}:${decodedRange.end?.column || ''}${keyRowIndex + 1}`;\n\n\t\tconst sheetDatakeyRow = columnNamesList || (await this.getData(keyRowRange, valueRenderMode));\n\n\t\tif (sheetDatakeyRow === undefined) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.executeFunctions.getNode(),\n\t\t\t\t'Could not retrieve the key row',\n\t\t\t);\n\t\t}\n\n\t\tconst columnNames = sheetDatakeyRow[0];\n\n\t\tconst keyIndex = columnNames.indexOf(indexKey);\n\n\t\tif (keyIndex === -1 && !upsert) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.executeFunctions.getNode(),\n\t\t\t\t`Could not find column for key \"${indexKey}\"`,\n\t\t\t);\n\t\t}\n\n\t\tconst columnValues: Array<string | number> =\n\t\t\tcolumnValuesList ||\n\t\t\t(await this.getColumnValues({ range, keyIndex, dataStartRowIndex, valueRenderMode }));\n\n\t\tconst updateData: ISheetUpdateData[] = [];\n\t\tconst appendData: IDataObject[] = [];\n\n\t\tconst getKeyIndex = (key: string | number, data: Array<string | number>) => {\n\t\t\tlet index = -1;\n\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i]?.toString() === key.toString()) {\n\t\t\t\t\tindex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn index;\n\t\t};\n\n\t\tfor (const item of inputData) {\n\t\t\tconst inputIndexKey = item[indexKey] as string;\n\n\t\t\tif (inputIndexKey === undefined || inputIndexKey === null) {\n\t\t\t\t// Item does not have the indexKey so we can ignore it or append it if upsert true\n\t\t\t\tif (upsert) {\n\t\t\t\t\tappendData.push(item);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Item does have the key so check if it exists in Sheet\n\t\t\tconst indexOfIndexKeyInSheet = getKeyIndex(inputIndexKey, columnValues);\n\n\t\t\tif (indexOfIndexKeyInSheet === -1) {\n\t\t\t\t// Key does not exist in the Sheet so it can not be updated so skip it or append it if upsert true\n\t\t\t\tif (upsert) {\n\t\t\t\t\tappendData.push(item);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Get the row index in which the data should be updated\n\t\t\tconst updateRowIndex = indexOfIndexKeyInSheet + dataStartRowIndex + 1;\n\n\t\t\t// Check all the properties in the sheet and check which ones exist on the\n\t\t\t// item and should be updated\n\t\t\tfor (const name of columnNames) {\n\t\t\t\tif (name === indexKey) {\n\t\t\t\t\t// Ignore the key itself as that does not get changed it gets\n\t\t\t\t\t// only used to find the correct row to update\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (item[name] === undefined || item[name] === null) {\n\t\t\t\t\t// Property does not exist so skip it\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Property exists so add it to the data to update\n\t\t\t\t// Get the column name in which the property data can be found\n\t\t\t\tconst columnToUpdate = this.getColumnWithOffset(\n\t\t\t\t\tdecodedRange.start?.column || 'A',\n\t\t\t\t\tcolumnNames.indexOf(name),\n\t\t\t\t);\n\n\t\t\t\tlet updateValue = item[name] as string;\n\t\t\t\tif (typeof updateValue === 'object') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tupdateValue = JSON.stringify(updateValue);\n\t\t\t\t\t} catch (error) {}\n\t\t\t\t}\n\t\t\t\tupdateData.push({\n\t\t\t\t\trange: `${decodedRange.name}!${columnToUpdate}${updateRowIndex}`,\n\t\t\t\t\tvalues: [[updateValue]],\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn { updateData, appendData };\n\t}\n\n\t/**\n\t * Updates data in a sheet\n\t *\n\t * @param {IDataObject[]} inputData Data to update Sheet with\n\t * @param {string} range The range to look for data\n\t * @param {number} dataStartRowIndex Index of the first row which contains data\n\t * @param {string[][]} columnNamesList The column names to use\n\t * @returns {Promise<string[][]>}\n\t * @memberof GoogleSheet\n\t */\n\tprepareDataForUpdatingByRowNumber(\n\t\tinputData: IDataObject[],\n\t\trange: string,\n\t\tcolumnNamesList: string[][],\n\t) {\n\t\tconst decodedRange = this.getDecodedSheetRange(range);\n\t\tconst columnNames = columnNamesList[0];\n\t\tconst updateData: ISheetUpdateData[] = [];\n\n\t\tfor (const item of inputData) {\n\t\t\tconst updateRowIndex = item.row_number as number;\n\n\t\t\tfor (const name of columnNames) {\n\t\t\t\tif (name === 'row_number') continue;\n\t\t\t\tif (item[name] === undefined || item[name] === null) continue;\n\n\t\t\t\tconst columnToUpdate = this.getColumnWithOffset(\n\t\t\t\t\tdecodedRange.start?.column || 'A',\n\t\t\t\t\tcolumnNames.indexOf(name),\n\t\t\t\t);\n\n\t\t\t\tlet updateValue = item[name] as string;\n\t\t\t\tif (typeof updateValue === 'object') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tupdateValue = JSON.stringify(updateValue);\n\t\t\t\t\t} catch (error) {}\n\t\t\t\t}\n\t\t\t\tupdateData.push({\n\t\t\t\t\trange: `${decodedRange.name}!${columnToUpdate}${updateRowIndex}`,\n\t\t\t\t\tvalues: [[updateValue]],\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn { updateData };\n\t}\n\n\t/**\n\t * Looks for a specific value in a column and if it gets found it returns the whole row\n\t *\n\t * @param {string[][]} inputData Data to check for lookup value in\n\t * @param {number} keyRowIndex Index of the row which contains the keys\n\t * @param {number} dataStartRowIndex Index of the first row which contains data\n\t * @param {ILookupValues[]} lookupValues The lookup values which decide what data to return\n\t * @param {boolean} [returnAllMatches] Returns all the found matches instead of only the first one\n\t * @returns {Promise<IDataObject[]>}\n\t * @memberof GoogleSheet\n\t */\n\tasync lookupValues({\n\t\tinputData,\n\t\tkeyRowIndex,\n\t\tdataStartRowIndex,\n\t\tlookupValues,\n\t\treturnAllMatches,\n\t\tnodeVersion,\n\t\tcombineFilters = 'OR',\n\t}: {\n\t\tinputData: string[][];\n\t\tkeyRowIndex: number;\n\t\tdataStartRowIndex: number;\n\t\tlookupValues: ILookupValues[];\n\t\tnodeVersion: number;\n\t\treturnAllMatches?: boolean;\n\t\tcombineFilters?: 'AND' | 'OR';\n\t}): Promise<IDataObject[]> {\n\t\tconst keys: string[] = [];\n\n\t\tif (keyRowIndex < 0 || dataStartRowIndex < keyRowIndex || keyRowIndex >= inputData.length) {\n\t\t\t// The key row does not exist so it is not possible to look up the data\n\t\t\tthrow new NodeOperationError(this.executeFunctions.getNode(), 'The key row does not exist');\n\t\t}\n\n\t\t// Create the keys array\n\t\tfor (let columnIndex = 0; columnIndex < inputData[keyRowIndex].length; columnIndex++) {\n\t\t\tkeys.push(inputData[keyRowIndex][columnIndex] || `col_${columnIndex}`);\n\t\t}\n\n\t\t// Standardize values array, if rows is [[]], map it to [['']] (Keep the columns into consideration)\n\t\tfor (let rowIndex = 0; rowIndex < inputData?.length; rowIndex++) {\n\t\t\tif (inputData[rowIndex].length === 0) {\n\t\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\t\tinputData[rowIndex][i] = '';\n\t\t\t\t}\n\t\t\t} else if (inputData[rowIndex].length < keys.length) {\n\t\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\t\tif (inputData[rowIndex][i] === undefined) {\n\t\t\t\t\t\tinputData[rowIndex].push('');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Loop over all the lookup values and try to find a row to return\n\t\tlet rowIndex: number;\n\t\tlet returnColumnIndex: number;\n\t\tconst addedRows: number[] = [];\n\n\t\t// const returnData = [inputData[keyRowIndex]];\n\t\tconst returnData = [keys];\n\n\t\tif (combineFilters === 'OR') {\n\t\t\tlookupLoop: for (const lookupValue of lookupValues) {\n\t\t\t\treturnColumnIndex = keys.indexOf(lookupValue.lookupColumn);\n\n\t\t\t\tif (returnColumnIndex === -1) {\n\t\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\t\tthis.executeFunctions.getNode(),\n\t\t\t\t\t\t`The column \"${lookupValue.lookupColumn}\" could not be found`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Loop over all the items and find the one with the matching value\n\t\t\t\tfor (rowIndex = dataStartRowIndex; rowIndex < inputData.length; rowIndex++) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tinputData[rowIndex][returnColumnIndex]?.toString() ===\n\t\t\t\t\t\tlookupValue.lookupValue.toString()\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (addedRows.indexOf(rowIndex) === -1) {\n\t\t\t\t\t\t\treturnData.push(inputData[rowIndex]);\n\t\t\t\t\t\t\taddedRows.push(rowIndex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (returnAllMatches !== true) {\n\t\t\t\t\t\t\tif (nodeVersion >= 4.6) {\n\t\t\t\t\t\t\t\tbreak lookupLoop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue lookupLoop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlookupLoop: for (rowIndex = dataStartRowIndex; rowIndex < inputData.length; rowIndex++) {\n\t\t\t\tlet allMatch = true;\n\n\t\t\t\tfor (const lookupValue of lookupValues) {\n\t\t\t\t\treturnColumnIndex = keys.indexOf(lookupValue.lookupColumn);\n\n\t\t\t\t\tif (returnColumnIndex === -1) {\n\t\t\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\t\t\tthis.executeFunctions.getNode(),\n\t\t\t\t\t\t\t`The column \"${lookupValue.lookupColumn}\" could not be found`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tinputData[rowIndex][returnColumnIndex]?.toString() !==\n\t\t\t\t\t\tlookupValue.lookupValue.toString()\n\t\t\t\t\t) {\n\t\t\t\t\t\tallMatch = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (allMatch) {\n\t\t\t\t\tif (addedRows.indexOf(rowIndex) === -1) {\n\t\t\t\t\t\treturnData.push(inputData[rowIndex]);\n\t\t\t\t\t\taddedRows.push(rowIndex);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (returnAllMatches !== true) {\n\t\t\t\t\t\tbreak lookupLoop;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst dataWithoutEmptyColumns = removeEmptyColumns(returnData);\n\t\treturn this.convertSheetDataArrayToObjectArray(\n\t\t\tdataWithoutEmptyColumns,\n\t\t\t1,\n\t\t\tdataWithoutEmptyColumns[0] as string[],\n\t\t\ttrue,\n\t\t);\n\t}\n\n\tprivate async convertObjectArrayToSheetDataArray(\n\t\tinputData: IDataObject[],\n\t\trange: string,\n\t\tkeyRowIndex: number,\n\t\tusePathForKeyRow?: boolean,\n\t\tcolumnNamesList?: string[][],\n\t\temptyValue: string | null = '',\n\t): Promise<string[][]> {\n\t\tconst decodedRange = this.getDecodedSheetRange(range);\n\n\t\tconst columnNamesRow =\n\t\t\tcolumnNamesList ||\n\t\t\t(await this.getData(\n\t\t\t\t`${decodedRange.name}!${keyRowIndex}:${keyRowIndex}`,\n\t\t\t\t'UNFORMATTED_VALUE',\n\t\t\t));\n\n\t\tif (columnNamesRow === undefined) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.executeFunctions.getNode(),\n\t\t\t\t'Could not retrieve the column data',\n\t\t\t);\n\t\t}\n\n\t\tconst columnNames = columnNamesRow ? columnNamesRow[0] : [];\n\t\tconst setData: string[][] = [];\n\n\t\tinputData.forEach((item) => {\n\t\t\tconst rowData: string[] = [];\n\t\t\tcolumnNames.forEach((key) => {\n\t\t\t\tlet value;\n\t\t\t\tif (usePathForKeyRow) {\n\t\t\t\t\tvalue = get(item, key) as string;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = item[key] as string;\n\t\t\t\t}\n\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\trowData.push(emptyValue as string);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (typeof value === 'object') {\n\t\t\t\t\trowData.push(JSON.stringify(value));\n\t\t\t\t} else {\n\t\t\t\t\trowData.push(value);\n\t\t\t\t}\n\t\t\t});\n\t\t\tsetData.push(rowData);\n\t\t});\n\t\treturn setData;\n\t}\n\n\tprivate getDecodedSheetRange(stringToDecode: string): SheetRangeDecoded {\n\t\tconst decodedRange: IDataObject = {};\n\t\tconst [name, range] = stringToDecode.split('!');\n\n\t\tdecodedRange.nameWithRange = stringToDecode;\n\t\tdecodedRange.name = name;\n\t\tdecodedRange.range = range || '';\n\t\tdecodedRange.start = {};\n\t\tdecodedRange.end = {};\n\n\t\tif (range) {\n\t\t\tconst [startCell, endCell] = range.split(':');\n\t\t\tif (startCell) {\n\t\t\t\tdecodedRange.start = this.splitCellRange(startCell, range);\n\t\t\t}\n\t\t\tif (endCell) {\n\t\t\t\tdecodedRange.end = this.splitCellRange(endCell, range);\n\t\t\t}\n\t\t}\n\n\t\treturn decodedRange as SheetRangeDecoded;\n\t}\n\n\tprivate splitCellRange(cell: string, range: string): SheetCellDecoded {\n\t\tconst cellData = cell.match(/([a-zA-Z]{1,10})([0-9]{0,10})/) || [];\n\n\t\tif (cellData === null || cellData.length !== 3) {\n\t\t\tthrow new NodeOperationError(\n\t\t\t\tthis.executeFunctions.getNode(),\n\t\t\t\t`The range \"${range}\" is not valid`,\n\t\t\t);\n\t\t}\n\n\t\treturn { cell: cellData[0], column: cellData[1], row: +cellData[2] };\n\t}\n}\n"],"mappings":"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","names":["xlsxUtils","rowIndex","get"]}
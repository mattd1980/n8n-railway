{"version":3,"sources":["../../../../nodes/Transform/SplitOut/SplitOut.node.ts"],"sourcesContent":["import get from 'lodash/get';\nimport unset from 'lodash/unset';\nimport { NodeOperationError, deepCopy, NodeConnectionTypes } from 'n8n-workflow';\nimport type {\n\tIBinaryData,\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeDescription,\n\tNodeExecutionHint,\n} from 'n8n-workflow';\n\nimport { prepareFieldsArray } from '../utils/utils';\n\nexport class SplitOut implements INodeType {\n\tdescription: INodeTypeDescription = {\n\t\tdisplayName: 'Split Out',\n\t\tname: 'splitOut',\n\t\ticon: 'file:splitOut.svg',\n\t\tgroup: ['transform'],\n\t\tsubtitle: '',\n\t\tversion: 1,\n\t\tdescription: 'Turn a list inside item(s) into separate items',\n\t\tdefaults: {\n\t\t\tname: 'Split Out',\n\t\t},\n\t\tinputs: [NodeConnectionTypes.Main],\n\t\toutputs: [NodeConnectionTypes.Main],\n\t\tproperties: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Fields To Split Out',\n\t\t\t\tname: 'fieldToSplitOut',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\trequired: true,\n\t\t\t\tplaceholder: 'Drag fields from the left or type their names',\n\t\t\t\tdescription:\n\t\t\t\t\t'The name of the input fields to break out into separate items. Separate multiple field names by commas. For binary data, use $binary.',\n\t\t\t\trequiresDataPath: 'multiple',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Include',\n\t\t\t\tname: 'include',\n\t\t\t\ttype: 'options',\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'No Other Fields',\n\t\t\t\t\t\tvalue: 'noOtherFields',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'All Other Fields',\n\t\t\t\t\t\tvalue: 'allOtherFields',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'Selected Other Fields',\n\t\t\t\t\t\tvalue: 'selectedOtherFields',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tdefault: 'noOtherFields',\n\t\t\t\tdescription: 'Whether to copy any other fields into the new items',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Fields To Include',\n\t\t\t\tname: 'fieldsToInclude',\n\t\t\t\ttype: 'string',\n\t\t\t\tplaceholder: 'e.g. email, name',\n\t\t\t\trequiresDataPath: 'multiple',\n\t\t\t\tdescription: 'Fields in the input items to aggregate together',\n\t\t\t\tdefault: '',\n\t\t\t\tdisplayOptions: {\n\t\t\t\t\tshow: {\n\t\t\t\t\t\tinclude: ['selectedOtherFields'],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Options',\n\t\t\t\tname: 'options',\n\t\t\t\ttype: 'collection',\n\t\t\t\tplaceholder: 'Add Field',\n\t\t\t\tdefault: {},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Disable Dot Notation',\n\t\t\t\t\t\tname: 'disableDotNotation',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: false,\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'Whether to disallow referencing child fields using `parent.child` in the field name',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Destination Field Name',\n\t\t\t\t\t\tname: 'destinationFieldName',\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\trequiresDataPath: 'multiple',\n\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t\tdescription: 'The field in the output under which to put the split field contents',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Include Binary',\n\t\t\t\t\t\tname: 'includeBinary',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: false,\n\t\t\t\t\t\tdescription: 'Whether to include the binary data in the new items',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t};\n\n\tasync execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {\n\t\tconst returnData: INodeExecutionData[] = [];\n\t\tconst items = this.getInputData();\n\t\tconst notFoundedFields: { [key: string]: boolean[] } = {};\n\n\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\tconst fieldsToSplitOut = (this.getNodeParameter('fieldToSplitOut', i) as string)\n\t\t\t\t.split(',')\n\t\t\t\t.map((field) => field.trim().replace(/^\\$json\\./, ''));\n\n\t\t\tconst options = this.getNodeParameter('options', i, {});\n\n\t\t\tconst disableDotNotation = options.disableDotNotation as boolean;\n\n\t\t\tconst destinationFields = ((options.destinationFieldName as string) || '')\n\t\t\t\t.split(',')\n\t\t\t\t.filter((field) => field.trim() !== '')\n\t\t\t\t.map((field) => field.trim());\n\n\t\t\tif (destinationFields.length && destinationFields.length !== fieldsToSplitOut.length) {\n\t\t\t\tthrow new NodeOperationError(\n\t\t\t\t\tthis.getNode(),\n\t\t\t\t\t'If multiple fields to split out are given, the same number of destination fields must be given',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst include = this.getNodeParameter('include', i) as\n\t\t\t\t| 'selectedOtherFields'\n\t\t\t\t| 'allOtherFields'\n\t\t\t\t| 'noOtherFields';\n\n\t\t\tconst multiSplit = fieldsToSplitOut.length > 1;\n\n\t\t\tconst item = { ...items[i].json };\n\t\t\tconst splited: INodeExecutionData[] = [];\n\t\t\tfor (const [entryIndex, fieldToSplitOut] of fieldsToSplitOut.entries()) {\n\t\t\t\tconst destinationFieldName = destinationFields[entryIndex] || '';\n\n\t\t\t\tlet entityToSplit: IDataObject[] = [];\n\n\t\t\t\tif (fieldToSplitOut === '$binary') {\n\t\t\t\t\tentityToSplit = Object.entries(items[i].binary || {}).map(([key, value]) => ({\n\t\t\t\t\t\t[key]: value,\n\t\t\t\t\t}));\n\t\t\t\t} else {\n\t\t\t\t\tif (!disableDotNotation) {\n\t\t\t\t\t\tentityToSplit = get(item, fieldToSplitOut) as IDataObject[];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tentityToSplit = item[fieldToSplitOut] as IDataObject[];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (entityToSplit === undefined) {\n\t\t\t\t\t\tentityToSplit = [];\n\t\t\t\t\t\tif (!notFoundedFields[fieldToSplitOut]) {\n\t\t\t\t\t\t\tnotFoundedFields[fieldToSplitOut] = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnotFoundedFields[fieldToSplitOut].push(false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (notFoundedFields[fieldToSplitOut]) {\n\t\t\t\t\t\t\tnotFoundedFields[fieldToSplitOut].push(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof entityToSplit !== 'object' || entityToSplit === null) {\n\t\t\t\t\t\tentityToSplit = [entityToSplit];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!Array.isArray(entityToSplit)) {\n\t\t\t\t\t\tentityToSplit = Object.values(entityToSplit);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const [elementIndex, element] of entityToSplit.entries()) {\n\t\t\t\t\tif (splited[elementIndex] === undefined) {\n\t\t\t\t\t\tsplited[elementIndex] = { json: {}, pairedItem: { item: i } };\n\t\t\t\t\t}\n\n\t\t\t\t\tconst fieldName = destinationFieldName || fieldToSplitOut;\n\n\t\t\t\t\tif (fieldToSplitOut === '$binary') {\n\t\t\t\t\t\tif (splited[elementIndex].binary === undefined) {\n\t\t\t\t\t\t\tsplited[elementIndex].binary = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsplited[elementIndex].binary[Object.keys(element)[0]] = Object.values(\n\t\t\t\t\t\t\telement,\n\t\t\t\t\t\t)[0] as IBinaryData;\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof element === 'object' && element !== null && include === 'noOtherFields') {\n\t\t\t\t\t\tif (destinationFieldName === '' && !multiSplit) {\n\t\t\t\t\t\t\tsplited[elementIndex] = {\n\t\t\t\t\t\t\t\tjson: { ...splited[elementIndex].json, ...element },\n\t\t\t\t\t\t\t\tpairedItem: { item: i },\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsplited[elementIndex].json[fieldName] = element;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsplited[elementIndex].json[fieldName] = element;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const splitEntry of splited) {\n\t\t\t\tlet newItem: INodeExecutionData = splitEntry;\n\n\t\t\t\tif (include === 'allOtherFields') {\n\t\t\t\t\tconst itemCopy = deepCopy(item);\n\t\t\t\t\tfor (const fieldToSplitOut of fieldsToSplitOut) {\n\t\t\t\t\t\tif (!disableDotNotation) {\n\t\t\t\t\t\t\tunset(itemCopy, fieldToSplitOut);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdelete itemCopy[fieldToSplitOut];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnewItem.json = { ...itemCopy, ...splitEntry.json };\n\t\t\t\t}\n\n\t\t\t\tif (include === 'selectedOtherFields') {\n\t\t\t\t\tconst fieldsToInclude = prepareFieldsArray(\n\t\t\t\t\t\tthis.getNodeParameter('fieldsToInclude', i, '') as string,\n\t\t\t\t\t\t'Fields To Include',\n\t\t\t\t\t);\n\n\t\t\t\t\tif (!fieldsToInclude.length) {\n\t\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'No fields specified', {\n\t\t\t\t\t\t\tdescription: 'Please add a field to include',\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const field of fieldsToInclude) {\n\t\t\t\t\t\tif (!disableDotNotation) {\n\t\t\t\t\t\t\tsplitEntry.json[field] = get(item, field);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsplitEntry.json[field] = item[field];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tnewItem = splitEntry;\n\t\t\t\t}\n\n\t\t\t\tconst includeBinary = options.includeBinary as boolean;\n\n\t\t\t\tif (includeBinary) {\n\t\t\t\t\tif (items[i].binary && !newItem.binary) {\n\t\t\t\t\t\tnewItem.binary = items[i].binary;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturnData.push(newItem);\n\t\t\t}\n\t\t}\n\n\t\tif (Object.keys(notFoundedFields).length) {\n\t\t\tconst hints: NodeExecutionHint[] = [];\n\n\t\t\tfor (const [field, values] of Object.entries(notFoundedFields)) {\n\t\t\t\tif (values.every((value) => !value)) {\n\t\t\t\t\thints.push({\n\t\t\t\t\t\tmessage: `The field '${field}' wasn't found in any input item`,\n\t\t\t\t\t\tlocation: 'outputPane',\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hints.length) {\n\t\t\t\tthis.addExecutionHints(...hints);\n\t\t\t}\n\t\t}\n\n\t\treturn [returnData];\n\t}\n}\n"],"mappings":"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","names":["get","unset"]}
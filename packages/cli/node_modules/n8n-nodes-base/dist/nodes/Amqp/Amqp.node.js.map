{"version":3,"sources":["../../../nodes/Amqp/Amqp.node.ts"],"sourcesContent":["import type {\n\tIExecuteFunctions,\n\tIDataObject,\n\tINodeExecutionData,\n\tINodeType,\n\tINodeTypeDescription,\n\tICredentialTestFunctions,\n\tINodeCredentialTestResult,\n\tICredentialsDecrypted,\n\tICredentialDataDecryptedObject,\n} from 'n8n-workflow';\nimport { NodeConnectionTypes, NodeOperationError } from 'n8n-workflow';\nimport type { Connection, ContainerOptions, Dictionary, EventContext, Sender } from 'rhea';\nimport { create_container } from 'rhea';\n\nasync function checkIfCredentialsValid(\n\tcredentials: IDataObject,\n): Promise<INodeCredentialTestResult> {\n\tconst connectOptions: ContainerOptions = {\n\t\treconnect: false,\n\t\thost: credentials.hostname as string,\n\t\thostname: credentials.hostname as string,\n\t\tport: credentials.port as number,\n\t\tusername: credentials.username ? (credentials.username as string) : undefined,\n\t\tpassword: credentials.password ? (credentials.password as string) : undefined,\n\t\ttransport: credentials.transportType ? (credentials.transportType as string) : undefined,\n\t};\n\n\tlet conn: Connection | undefined = undefined;\n\ttry {\n\t\tconst container = create_container();\n\t\tawait new Promise<void>((resolve, reject) => {\n\t\t\tcontainer.on('connection_open', function (_context: EventContext) {\n\t\t\t\tresolve();\n\t\t\t});\n\t\t\tcontainer.on('disconnected', function (context: EventContext) {\n\t\t\t\treject(context.error ?? new Error('unknown error'));\n\t\t\t});\n\t\t\tconn = container.connect(connectOptions);\n\t\t});\n\t} catch (error) {\n\t\treturn {\n\t\t\tstatus: 'Error',\n\t\t\tmessage: (error as Error).message,\n\t\t};\n\t} finally {\n\t\tif (conn) (conn as Connection).close();\n\t}\n\n\treturn {\n\t\tstatus: 'OK',\n\t\tmessage: 'Connection successful!',\n\t};\n}\n\nexport class Amqp implements INodeType {\n\tdescription: INodeTypeDescription = {\n\t\tdisplayName: 'AMQP Sender',\n\t\tname: 'amqp',\n\t\ticon: 'file:amqp.svg',\n\t\tgroup: ['transform'],\n\t\tversion: 1,\n\t\tdescription: 'Sends a raw-message via AMQP 1.0, executed once per item',\n\t\tdefaults: {\n\t\t\tname: 'AMQP Sender',\n\t\t},\n\t\tusableAsTool: true,\n\t\tinputs: [NodeConnectionTypes.Main],\n\t\toutputs: [NodeConnectionTypes.Main],\n\t\tcredentials: [\n\t\t\t{\n\t\t\t\tname: 'amqp',\n\t\t\t\trequired: true,\n\t\t\t\ttestedBy: 'amqpConnectionTest',\n\t\t\t},\n\t\t],\n\t\tproperties: [\n\t\t\t{\n\t\t\t\tdisplayName: 'Queue / Topic',\n\t\t\t\tname: 'sink',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\tplaceholder: 'e.g. topic://sourcename.something',\n\t\t\t\tdescription: 'Name of the queue of topic to publish to',\n\t\t\t},\n\t\t\t// Header Parameters\n\t\t\t{\n\t\t\t\tdisplayName: 'Headers',\n\t\t\t\tname: 'headerParametersJson',\n\t\t\t\ttype: 'json',\n\t\t\t\tdefault: '',\n\t\t\t\tdescription:\n\t\t\t\t\t'Header parameters as JSON (flat object). Sent as application_properties in amqp-message meta info.',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Options',\n\t\t\t\tname: 'options',\n\t\t\t\ttype: 'collection',\n\t\t\t\tplaceholder: 'Add option',\n\t\t\t\tdefault: {},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Container ID',\n\t\t\t\t\t\tname: 'containerId',\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t\tdescription: 'Will be used to pass to the RHEA Backend as container_id',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Data as Object',\n\t\t\t\t\t\tname: 'dataAsObject',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: false,\n\t\t\t\t\t\tdescription: 'Whether to send the data as an object',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Reconnect',\n\t\t\t\t\t\tname: 'reconnect',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: true,\n\t\t\t\t\t\tdescription: 'Whether to automatically reconnect if disconnected',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Reconnect Limit',\n\t\t\t\t\t\tname: 'reconnectLimit',\n\t\t\t\t\t\ttype: 'number',\n\t\t\t\t\t\tdefault: 50,\n\t\t\t\t\t\tdescription: 'Maximum number of reconnect attempts',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Send Property',\n\t\t\t\t\t\tname: 'sendOnlyProperty',\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t\tdescription: 'The only property to send. If empty the whole item will be sent.',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t};\n\n\tmethods = {\n\t\tcredentialTest: {\n\t\t\tasync amqpConnectionTest(\n\t\t\t\tthis: ICredentialTestFunctions,\n\t\t\t\tcredential: ICredentialsDecrypted,\n\t\t\t): Promise<INodeCredentialTestResult> {\n\t\t\t\tconst credentials = credential.data as ICredentialDataDecryptedObject;\n\t\t\t\treturn await checkIfCredentialsValid(credentials);\n\t\t\t},\n\t\t},\n\t};\n\n\tasync execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {\n\t\tconst container = create_container();\n\t\tlet connection: Connection | undefined = undefined;\n\t\tlet sender: Sender | undefined = undefined;\n\n\t\ttry {\n\t\t\tconst credentials = await this.getCredentials('amqp');\n\n\t\t\t// check if credentials are valid to avoid unnecessary reconnects\n\t\t\tconst credentialsTestResult = await checkIfCredentialsValid(credentials);\n\t\t\tif (credentialsTestResult.status === 'Error') {\n\t\t\t\tthrow new NodeOperationError(this.getNode(), credentialsTestResult.message, {\n\t\t\t\t\tdescription: 'Check your credentials and try again',\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst sink = this.getNodeParameter('sink', 0, '') as string;\n\t\t\tconst applicationProperties = this.getNodeParameter('headerParametersJson', 0, {}) as\n\t\t\t\t| string\n\t\t\t\t| object;\n\t\t\tconst options = this.getNodeParameter('options', 0, {});\n\t\t\tconst containerId = options.containerId as string;\n\t\t\tconst containerReconnect = (options.reconnect as boolean) || true;\n\t\t\tconst containerReconnectLimit = (options.reconnectLimit as number) || 50;\n\n\t\t\tlet headerProperties: Dictionary<any>;\n\t\t\tif (typeof applicationProperties === 'string' && applicationProperties !== '') {\n\t\t\t\theaderProperties = JSON.parse(applicationProperties);\n\t\t\t} else {\n\t\t\t\theaderProperties = applicationProperties as object;\n\t\t\t}\n\n\t\t\tif (sink === '') {\n\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Queue or Topic required!');\n\t\t\t}\n\n\t\t\t/*\n\t\t\t\tValues are documented here: https://github.com/amqp/rhea#container\n\t\t\t*/\n\t\t\tconst connectOptions: ContainerOptions = {\n\t\t\t\thost: credentials.hostname,\n\t\t\t\thostname: credentials.hostname,\n\t\t\t\tport: credentials.port,\n\t\t\t\tusername: credentials.username ? credentials.username : undefined,\n\t\t\t\tpassword: credentials.password ? credentials.password : undefined,\n\t\t\t\ttransport: credentials.transportType ? credentials.transportType : undefined,\n\t\t\t\tcontainer_id: containerId ? containerId : undefined,\n\t\t\t\tid: containerId ? containerId : undefined,\n\t\t\t\treconnect: containerReconnect,\n\t\t\t\treconnect_limit: containerReconnectLimit,\n\t\t\t};\n\n\t\t\tconst node = this.getNode();\n\n\t\t\tconst responseData: INodeExecutionData[] = await new Promise((resolve, reject) => {\n\t\t\t\tconnection = container.connect(connectOptions);\n\t\t\t\tsender = connection.open_sender(sink);\n\t\t\t\tlet limit = containerReconnectLimit;\n\n\t\t\t\tcontainer.on('disconnected', function (context: EventContext) {\n\t\t\t\t\t//handling this manually as container, despite reconnect_limit, does reconnect on disconnect\n\t\t\t\t\tif (limit <= 0) {\n\t\t\t\t\t\tconnection!.options.reconnect = false;\n\t\t\t\t\t\tconst error = new NodeOperationError(\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\t((context.error as Error) ?? {}).message ?? 'Disconnected',\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdescription: `Check your credentials${options.reconnect ? '' : ', and consider enabling reconnect in the options'}`,\n\t\t\t\t\t\t\t\titemIndex: 0,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tlimit--;\n\t\t\t\t});\n\n\t\t\t\tcontainer.once('sendable', (context: EventContext) => {\n\t\t\t\t\tconst returnData: INodeExecutionData[] = [];\n\n\t\t\t\t\tconst items = this.getInputData();\n\t\t\t\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\t\t\t\tconst item = items[i];\n\n\t\t\t\t\t\tlet body: IDataObject | string = item.json;\n\t\t\t\t\t\tconst sendOnlyProperty = options.sendOnlyProperty as string;\n\n\t\t\t\t\t\tif (sendOnlyProperty) {\n\t\t\t\t\t\t\tbody = body[sendOnlyProperty] as string;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (options.dataAsObject !== true) {\n\t\t\t\t\t\t\tbody = JSON.stringify(body);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst result = context.sender?.send({\n\t\t\t\t\t\t\tapplication_properties: headerProperties,\n\t\t\t\t\t\t\tbody,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturnData.push({ json: { id: result?.id }, pairedItems: { item: i } });\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(returnData);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn [responseData];\n\t\t} catch (error) {\n\t\t\tif (this.continueOnFail()) {\n\t\t\t\treturn [[{ json: { error: error.message }, pairedItems: { item: 0 } }]];\n\t\t\t} else {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t} finally {\n\t\t\tif (sender) (sender as Sender).close();\n\t\t\tif (connection) (connection as Connection).close();\n\t\t}\n\t}\n}\n"],"mappings":"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","names":[]}
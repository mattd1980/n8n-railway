{"version":3,"sources":["../../../nodes/Amqp/AmqpTrigger.node.ts"],"sourcesContent":["import type {\n\tITriggerFunctions,\n\tIDataObject,\n\tINodeType,\n\tINodeTypeDescription,\n\tITriggerResponse,\n\tIDeferredPromise,\n\tIRun,\n} from 'n8n-workflow';\nimport { deepCopy, jsonParse, NodeConnectionTypes, NodeOperationError } from 'n8n-workflow';\nimport type { ContainerOptions, EventContext, Message, ReceiverOptions } from 'rhea';\nimport { create_container } from 'rhea';\n\nexport class AmqpTrigger implements INodeType {\n\tdescription: INodeTypeDescription = {\n\t\tdisplayName: 'AMQP Trigger',\n\t\tname: 'amqpTrigger',\n\t\ticon: 'file:amqp.svg',\n\t\tgroup: ['trigger'],\n\t\tversion: 1,\n\t\tdescription: 'Listens to AMQP 1.0 Messages',\n\t\tdefaults: {\n\t\t\tname: 'AMQP Trigger',\n\t\t},\n\t\tinputs: [],\n\t\toutputs: [NodeConnectionTypes.Main],\n\t\tcredentials: [\n\t\t\t{\n\t\t\t\tname: 'amqp',\n\t\t\t\trequired: true,\n\t\t\t},\n\t\t],\n\t\tproperties: [\n\t\t\t// Node properties which the user gets displayed and\n\t\t\t// can change on the node.\n\t\t\t{\n\t\t\t\tdisplayName: 'Queue / Topic',\n\t\t\t\tname: 'sink',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\tplaceholder: 'topic://sourcename.something',\n\t\t\t\tdescription: 'Name of the queue of topic to listen to',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Clientname',\n\t\t\t\tname: 'clientname',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\tplaceholder: 'e.g. n8n',\n\t\t\t\tdescription: 'Leave empty for non-durable topic subscriptions or queues',\n\t\t\t\thint: 'for durable/persistent topic subscriptions',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Subscription',\n\t\t\t\tname: 'subscription',\n\t\t\t\ttype: 'string',\n\t\t\t\tdefault: '',\n\t\t\t\tplaceholder: 'e.g. order-worker',\n\t\t\t\tdescription: 'Leave empty for non-durable topic subscriptions or queues',\n\t\t\t\thint: 'for durable/persistent topic subscriptions',\n\t\t\t},\n\t\t\t{\n\t\t\t\tdisplayName: 'Options',\n\t\t\t\tname: 'options',\n\t\t\t\ttype: 'collection',\n\t\t\t\tplaceholder: 'Add option',\n\t\t\t\tdefault: {},\n\t\t\t\toptions: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Container ID',\n\t\t\t\t\t\tname: 'containerId',\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdefault: '',\n\t\t\t\t\t\tdescription: 'Will be used to pass to the RHEA Backend as container_id',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Convert Body To String',\n\t\t\t\t\t\tname: 'jsonConvertByteArrayToString',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: false,\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t'Whether to convert JSON Body content ([\"body\"][\"content\"]) from Byte Array to string. Needed for Azure Service Bus.',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'JSON Parse Body',\n\t\t\t\t\t\tname: 'jsonParseBody',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: false,\n\t\t\t\t\t\tdescription: 'Whether to parse the body to an object',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Messages per Cicle',\n\t\t\t\t\t\tname: 'pullMessagesNumber',\n\t\t\t\t\t\ttype: 'number',\n\t\t\t\t\t\tdefault: 100,\n\t\t\t\t\t\tdescription: 'Number of messages to pull from the bus for every cicle',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Only Body',\n\t\t\t\t\t\tname: 'onlyBody',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: false,\n\t\t\t\t\t\tdescription: 'Whether to return only the body property',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Parallel Processing',\n\t\t\t\t\t\tname: 'parallelProcessing',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: true,\n\t\t\t\t\t\tdescription: 'Whether to process messages in parallel',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Reconnect',\n\t\t\t\t\t\tname: 'reconnect',\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdefault: true,\n\t\t\t\t\t\tdescription: 'Whether to automatically reconnect if disconnected',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Reconnect Limit',\n\t\t\t\t\t\tname: 'reconnectLimit',\n\t\t\t\t\t\ttype: 'number',\n\t\t\t\t\t\tdefault: 50,\n\t\t\t\t\t\tdescription: 'Maximum number of reconnect attempts',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplayName: 'Sleep Time',\n\t\t\t\t\t\tname: 'sleepTime',\n\t\t\t\t\t\ttype: 'number',\n\t\t\t\t\t\tdefault: 10,\n\t\t\t\t\t\tdescription: 'Milliseconds to sleep after every cicle',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t],\n\t};\n\n\tasync trigger(this: ITriggerFunctions): Promise<ITriggerResponse> {\n\t\tconst credentials = await this.getCredentials('amqp');\n\n\t\tconst sink = this.getNodeParameter('sink', '') as string;\n\t\tconst clientname = this.getNodeParameter('clientname', '') as string;\n\t\tconst subscription = this.getNodeParameter('subscription', '') as string;\n\t\tconst options = this.getNodeParameter('options', {}) as IDataObject;\n\t\tconst parallelProcessing = this.getNodeParameter('options.parallelProcessing', true) as boolean;\n\t\tconst pullMessagesNumber = (options.pullMessagesNumber as number) || 100;\n\t\tconst containerId = options.containerId as string;\n\t\tconst containerReconnect = (options.reconnect as boolean) || true;\n\t\tconst containerReconnectLimit = (options.reconnectLimit as number) || 50;\n\n\t\tif (sink === '') {\n\t\t\tthrow new NodeOperationError(this.getNode(), 'Queue or Topic required!');\n\t\t}\n\n\t\tlet durable = false;\n\n\t\tif (subscription && clientname) {\n\t\t\tdurable = true;\n\t\t}\n\n\t\tconst container = create_container();\n\n\t\tlet lastMsgId: string | number | Buffer | undefined = undefined;\n\n\t\tcontainer.on('receiver_open', (context: EventContext) => {\n\t\t\tcontext.receiver?.add_credit(pullMessagesNumber);\n\t\t});\n\n\t\tcontainer.on('message', async (context: EventContext) => {\n\t\t\t// No message in the context\n\t\t\tif (!context.message) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// ignore duplicate message check, don't think it's necessary, but it was in the rhea-lib example code\n\t\t\tif (context.message.message_id && context.message.message_id === lastMsgId) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastMsgId = context.message.message_id;\n\n\t\t\tlet data = context.message;\n\n\t\t\tif (options.jsonConvertByteArrayToString === true && data.body.content !== undefined) {\n\t\t\t\t// The buffer is not ready... Stringify and parse back to load it.\n\t\t\t\tconst cont = deepCopy(data.body.content);\n\t\t\t\tdata.body = String.fromCharCode.apply(null, cont.data as number[]);\n\t\t\t}\n\n\t\t\tif (options.jsonConvertByteArrayToString === true && data.body.content !== undefined) {\n\t\t\t\t// The buffer is not ready... Stringify and parse back to load it.\n\t\t\t\tconst cont = deepCopy(data.body.content);\n\t\t\t\tdata.body = String.fromCharCode.apply(null, cont.data as number[]);\n\t\t\t}\n\n\t\t\tif (options.jsonConvertByteArrayToString === true && data.body.content !== undefined) {\n\t\t\t\t// The buffer is not ready... Stringify and parse back to load it.\n\t\t\t\tconst content = deepCopy(data.body.content);\n\t\t\t\tdata.body = String.fromCharCode.apply(null, content.data as number[]);\n\t\t\t}\n\n\t\t\tif (options.jsonParseBody === true) {\n\t\t\t\tdata.body = jsonParse(data.body as string);\n\t\t\t}\n\t\t\tif (options.onlyBody === true) {\n\t\t\t\tdata = data.body;\n\t\t\t}\n\n\t\t\tlet responsePromise: IDeferredPromise<IRun> | undefined = undefined;\n\t\t\tif (!parallelProcessing) {\n\t\t\t\tresponsePromise = this.helpers.createDeferredPromise();\n\t\t\t}\n\t\t\tif (responsePromise) {\n\t\t\t\tthis.emit([this.helpers.returnJsonArray([data as any])], undefined, responsePromise);\n\t\t\t\tawait responsePromise.promise;\n\t\t\t} else {\n\t\t\t\tthis.emit([this.helpers.returnJsonArray([data as any])]);\n\t\t\t}\n\n\t\t\tif (!context.receiver?.has_credit()) {\n\t\t\t\tsetTimeout(\n\t\t\t\t\t() => {\n\t\t\t\t\t\tcontext.receiver?.add_credit(pullMessagesNumber);\n\t\t\t\t\t},\n\t\t\t\t\t(options.sleepTime as number) || 10,\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\t/*\n\t\t\tValues are documentet here: https://github.com/amqp/rhea#container\n\t\t */\n\t\tconst connectOptions: ContainerOptions = {\n\t\t\thost: credentials.hostname,\n\t\t\thostname: credentials.hostname,\n\t\t\tport: credentials.port,\n\t\t\treconnect: containerReconnect,\n\t\t\treconnect_limit: containerReconnectLimit,\n\t\t\tusername: credentials.username ? credentials.username : undefined,\n\t\t\tpassword: credentials.password ? credentials.password : undefined,\n\t\t\ttransport: credentials.transportType ? credentials.transportType : undefined,\n\t\t\tcontainer_id: containerId ? containerId : undefined,\n\t\t\tid: containerId ? containerId : undefined,\n\t\t};\n\t\tconst connection = container.connect(connectOptions);\n\n\t\tconst clientOptions: ReceiverOptions = {\n\t\t\tname: subscription ? subscription : undefined,\n\t\t\tsource: {\n\t\t\t\taddress: sink,\n\t\t\t\tdurable: durable ? 2 : undefined,\n\t\t\t\texpiry_policy: durable ? 'never' : undefined,\n\t\t\t},\n\t\t\tcredit_window: 0, // prefetch 1\n\t\t};\n\t\tconnection.open_receiver(clientOptions);\n\n\t\t// The \"closeFunction\" function gets called by n8n whenever\n\t\t// the workflow gets deactivated and can so clean up.\n\t\tasync function closeFunction() {\n\t\t\tcontainer.removeAllListeners('receiver_open');\n\t\t\tcontainer.removeAllListeners('message');\n\t\t\tconnection.close();\n\t\t}\n\n\t\t// The \"manualTriggerFunction\" function gets called by n8n\n\t\t// when a user is in the workflow editor and starts the\n\t\t// workflow manually.\n\t\t// for AMQP it doesn't make much sense to wait here but\n\t\t// for a new user who doesn't know how this works, it's better to wait and show a respective info message\n\t\tconst manualTriggerFunction = async () => {\n\t\t\tawait new Promise((resolve, reject) => {\n\t\t\t\tconst timeoutHandler = setTimeout(() => {\n\t\t\t\t\tcontainer.removeAllListeners('receiver_open');\n\t\t\t\t\tcontainer.removeAllListeners('message');\n\t\t\t\t\tconnection.close();\n\n\t\t\t\t\treject(\n\t\t\t\t\t\tnew NodeOperationError(\n\t\t\t\t\t\t\tthis.getNode(),\n\t\t\t\t\t\t\t'Aborted because no message received within 15 seconds',\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\t\t'This 15sec timeout is only set for \"manually triggered execution\". Active Workflows will listen indefinitely.',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}, 15000);\n\t\t\t\tcontainer.on('message', (context: EventContext) => {\n\t\t\t\t\t// Check if the only property present in the message is body\n\t\t\t\t\t// in which case we only emit the content of the body property\n\t\t\t\t\t// otherwise we emit all properties and their content\n\t\t\t\t\tconst message = context.message as Message;\n\t\t\t\t\tif (Object.keys(message)[0] === 'body' && Object.keys(message).length === 1) {\n\t\t\t\t\t\tthis.emit([this.helpers.returnJsonArray([message.body])]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.emit([this.helpers.returnJsonArray([message as any])]);\n\t\t\t\t\t}\n\t\t\t\t\tclearTimeout(timeoutHandler);\n\t\t\t\t\tresolve(true);\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\treturn {\n\t\t\tcloseFunction,\n\t\t\tmanualTriggerFunction,\n\t\t};\n\t}\n}\n"],"mappings":"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","names":[]}